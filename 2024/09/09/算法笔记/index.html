

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="uert">
  <meta name="keywords" content="">
  
    <meta name="description" content="本笔记以c++为主，其他语言也有相关代码 c++代码的基础内容头文件 1.基础数据结构和算法 #include &lt;iostream&gt;：用于输入输出流，如 std::cin 和 std::cout。  #include &lt;vector&gt;：用于动态数组 std::vector。  #include &lt;string&gt;：用于 std::string 字符串操作。  #i">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://theganlove.github.io/2024/09/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本笔记以c++为主，其他语言也有相关代码 c++代码的基础内容头文件 1.基础数据结构和算法 #include &lt;iostream&gt;：用于输入输出流，如 std::cin 和 std::cout。  #include &lt;vector&gt;：用于动态数组 std::vector。  #include &lt;string&gt;：用于 std::string 字符串操作。  #i">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-09T11:20:21.000Z">
<meta property="article:modified_time" content="2024-11-04T14:42:35.857Z">
<meta property="article:author" content="uert">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算法笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"theganlove.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>主题</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-09 19:20" pubdate>
          2024年9月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          47k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          392 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>本笔记以c++为主，其他语言也有相关代码</p>
<h1 id="c-代码的基础内容"><a href="#c-代码的基础内容" class="headerlink" title="c++代码的基础内容"></a>c++代码的基础内容</h1><p>头文件</p>
<h3 id="1-基础数据结构和算法"><a href="#1-基础数据结构和算法" class="headerlink" title="1.基础数据结构和算法"></a>1.<strong>基础数据结构和算法</strong></h3><ul>
<li><p><code>#include &lt;iostream&gt;</code>：用于输入输出流，如 <code>std::cin</code> 和 <code>std::cout</code>。</p>
</li>
<li><p><code>#include &lt;vector&gt;</code>：用于动态数组 <code>std::vector</code>。</p>
</li>
<li><p><code>#include &lt;string&gt;</code>：用于 <code>std::string</code> 字符串操作。</p>
</li>
<li><p><code>#include &lt;deque&gt;</code>：用于双端队列 <code>std::deque</code>。</p>
</li>
<li><p><code>#include &lt;stack&gt;</code>：用于栈数据结构 <code>std::stack</code>。</p>
</li>
<li><p><code>#include &lt;queue&gt;</code>：用于队列和优先队列 <code>std::queue</code>, <code>std::priority_queue</code>。</p>
</li>
<li><p><code>#include &lt;list&gt;</code>：用于双向链表 <code>std::list</code>。</p>
</li>
<li><p><code>#include &lt;set&gt;</code>：用于集合 <code>std::set</code>，有序唯一元素。</p>
</li>
<li><p><code>#include &lt;map&gt;</code>：用于键值对映射 <code>std::map</code>（有序映射）。</p>
</li>
<li><p><code>#include &lt;unordered_map&gt;</code>：用于哈希表 <code>std::unordered_map</code>（无序映射）。</p>
</li>
<li><p><code>#include &lt;unordered_set&gt;</code>：用于哈希表实现的集合 <code>std::unordered_set</code>。</p>
</li>
<li><p>#include <cmath><code>double sqrt(double x);</code>：返回 <code>x</code> 的平方根。</p>
<p><code>double cbrt(double x);</code>：返回 <code>x</code> 的立方根。</p>
<p><code>double pow(double base, double exponent);</code>：计算 <code>base</code> 的 <code>exponent</code> 次幂。</p>
<p><code>double abs(double x);</code>：返回 <code>x</code> 的绝对值（整数的绝对值可以用 <code>std::abs</code>，位于 <code>&lt;cstdlib&gt;</code> 中）。</p>
<p><code>double hypot(double x, double y);</code>：返回 <code>sqrt(x*x + y*y)</code>，即两个数作为直角边的斜边长度。</p>
<p><code>double fmod(double x, double y);</code>：返回 <code>x</code> 除以 <code>y</code> 的浮点数余数。</p>
</li>
<li><p><code>#include &lt;utility&gt;</code>: std::pair：一个可以存储两个值的模板类，通常用于表示键值对。std::make_pair：一个函数模板，用于创建std::pair类型的对象std::swap：一个函数模板，用于交换两个变量的值。std::forward：一个模板函数，用于完美转发参数。std::move：一个模板函数，用于表示将对象的状态或所有权转移到另一个对象。std::exchange：一个模板函数，用于替换变量的值并返回其旧值。</p>
</li>
<li><p>#include &lt;bits&#x2F;stdc++.h&gt;是 GCC 特有的，不是 C++ 标准库的一部分。因此，在 Visual Studio 等不支持 GCC 的编译器上可能无法使用。，比如 <code>&lt;iostream&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;algorithm&gt;</code>, <code>&lt;cmath&gt;</code> 等，不需要一一手动包含</p>
<p><strong>GCC</strong>：在 Linux 和 Windows 上的 MinGW 环境中，GCC 默认支持 <code>bits/stdc++.h</code>，因为它是 GCC 库的一部分。</p>
<p><strong>Clang with GCC compatibility</strong>：在 Linux 上使用 Clang 时，如果它和 GCC 兼容，通常可以支持 <code>bits/stdc++.h</code>。</p>
</li>
</ul>
<h3 id="2-基础语法与数据类型"><a href="#2-基础语法与数据类型" class="headerlink" title="2. 基础语法与数据类型"></a>2. <strong>基础语法与数据类型</strong></h3><p>C++ 支持多种基本数据类型，常用的数据类型如下：</p>
<ul>
<li><p><code>int</code>: 整型，表示整数。</p>
</li>
<li><p><code>double</code>: 双精度浮点型，表示小数。</p>
</li>
<li><p><code>char</code>: 字符型，表示单个字符。</p>
</li>
<li><p><code>bool</code>: 布尔型，表示真 (<code>true</code>) 或假 (<code>false</code>)。</p>
</li>
<li><p><code>std::string</code>: 字符串类型，需要包含 <code>&lt;string&gt;</code> 头文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 整型</span><br>    <span class="hljs-type">double</span> b = <span class="hljs-number">3.14</span>;  <span class="hljs-comment">// 浮点型</span><br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;  <span class="hljs-comment">// 字符型</span><br>    <span class="hljs-type">bool</span> isTrue = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 布尔型</span><br>    std::string name = <span class="hljs-string">&quot;Alice&quot;</span>;  <span class="hljs-comment">// 字符串类型</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>C++ 通过 <code>cin</code> 和 <code>cout</code> 来处理输入和输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> age;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Enter your age: &quot;</span>;<br>    std::cin &gt;&gt; age;  <span class="hljs-comment">// 输入年龄</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Your age is: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;  <span class="hljs-comment">// 输出年龄</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>std::cin</code>: 从用户输入读取数据。</li>
</ul>
</li>
<li><p><code>&gt;&gt;</code>: 输入运算符，用于从 <code>cin</code> 接收数据</p>
</li>
</ul>
<h4 id="一-STL-的主要组成部分"><a href="#一-STL-的主要组成部分" class="headerlink" title="一.STL 的主要组成部分"></a>一.STL 的主要组成部分</h4><ol>
<li>**容器 (Containers)**：用来存储和管理数据的集合。</li>
<li>**算法 (Algorithms)**：用于对数据进行操作，如排序、查找、修改等。</li>
<li>**迭代器 (Iterators)**：用于遍历容器中的元素，提供统一的访问接口。</li>
</ol>
<h4 id="二、容器-Containers"><a href="#二、容器-Containers" class="headerlink" title="二、容器 (Containers)"></a>二、容器 (Containers)</h4><p>STL 容器分为三类：<strong>顺序容器</strong>、<strong>关联容器</strong>和<strong>无序关联容器</strong>。</p>
<h4 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1. 顺序容器"></a>1. <strong>顺序容器</strong></h4><p>顺序容器存储数据时，元素按插入顺序排列，常见的顺序容器有：</p>
<ul>
<li>**<code>vector</code>**：动态数组，支持快速随机访问。</li>
<li>**<code>deque</code>**：双端队列，支持两端快速插入和删除。</li>
<li>**<code>list</code>**：双向链表，支持双向遍历，插入和删除操作效率较高。</li>
<li>**<code>array</code>**：定长数组（C++11 引入），存储固定大小的数据。</li>
<li>**<code>forward_list</code>**：单向链表（C++11 引入），支持单向遍历。</li>
</ul>
<h5 id="vector-动态数组"><a href="#vector-动态数组" class="headerlink" title="vector 动态数组"></a><strong><code>vector</code></strong> 动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 初始化</span><br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 尾部添加元素</span><br>    vec[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;        <span class="hljs-comment">// 随机访问</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 5 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a><strong><code>deque</code></strong> 双端队列</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; dq = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入元素</span><br>    dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入元素</span><br>    dq.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-comment">// 移除头部元素</span><br>    dq.<span class="hljs-built_in">pop_back</span>();     <span class="hljs-comment">// 移除尾部元素</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : dq) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：2 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="list-双向链表"><a href="#list-双向链表" class="headerlink" title="list 双向链表"></a><strong><code>list</code></strong> 双向链表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入</span><br>    lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入</span><br>    lst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 移除值为2的元素</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : lst) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：0 1 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="array-定长数组（C-11）"><a href="#array-定长数组（C-11）" class="headerlink" title="array 定长数组（C++11）"></a><strong><code>array</code></strong> 定长数组（C++11）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp复制代码<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 固定大小为3的数组</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="forward-list-单向链表（C-11）"><a href="#forward-list-单向链表（C-11）" class="headerlink" title="forward_list 单向链表（C++11）"></a><strong><code>forward_list</code></strong> 单向链表（C++11）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp复制代码<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::forward_list&lt;<span class="hljs-type">int</span>&gt; flst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    flst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 头部插入</span><br>    flst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 移除值为2的元素</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : flst) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：0 1 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2. 关联容器"></a>2. <strong>关联容器</strong></h4><p>关联容器基于平衡二叉树（通常是红黑树）实现，元素按键值排序，支持快速查找、插入和删除操作。常见的关联容器有：</p>
<ul>
<li>**<code>set</code>**：存储唯一的元素，自动按元素的键值排序。</li>
<li>**<code>map</code>**：键值对（key-value）形式存储元素，按键排序。</li>
<li>**<code>multiset</code>**：存储允许重复的元素，按键排序。</li>
<li>**<code>multimap</code>**：存储允许重复的键值对，按键排序。</li>
</ul>
<h5 id="set-存储唯一元素，自动排序"><a href="#set-存储唯一元素，自动排序" class="headerlink" title="set 存储唯一元素，自动排序"></a><strong><code>set</code></strong> 存储唯一元素，自动排序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动排序，重复元素被忽略</span><br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : s) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3 4 5</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="map-键值对形式存储，按键排序"><a href="#map-键值对形式存储，按键排序" class="headerlink" title="map 键值对形式存储，按键排序"></a><strong><code>map</code></strong> 键值对形式存储，按键排序</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; m;<br>    m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>    m[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>    m[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : m) &#123;<br>        std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-comment">// 输出：</span><br>        <span class="hljs-comment">// apple: 3</span><br>        <span class="hljs-comment">// banana: 2</span><br>        <span class="hljs-comment">// orange: 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="multiset-存储允许重复元素，按键排序"><a href="#multiset-存储允许重复元素，按键排序" class="headerlink" title="multiset 存储允许重复元素，按键排序"></a><strong><code>multiset</code></strong> 存储允许重复元素，按键排序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::multiset&lt;<span class="hljs-type">int</span>&gt; ms = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 插入重复元素</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ms) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 1 2 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="multimap-存储允许重复的键值对，按键排序"><a href="#multimap-存储允许重复的键值对，按键排序" class="headerlink" title="multimap 存储允许重复的键值对，按键排序"></a><strong><code>multimap</code></strong> 存储允许重复的键值对，按键排序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::multimap&lt;std::string, <span class="hljs-type">int</span>&gt; mm;<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;);<br>    mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>&#125;);  <span class="hljs-comment">// 相同键可以重复插入</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : mm) &#123;<br>        std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-comment">// 输出：</span><br>        <span class="hljs-comment">// apple: 3</span><br>        <span class="hljs-comment">// apple: 5</span><br>        <span class="hljs-comment">// banana: 2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-无序关联容器"><a href="#3-无序关联容器" class="headerlink" title="3. 无序关联容器"></a>3. <strong>无序关联容器</strong></h4><p>无序关联容器是基于哈希表实现的容器，元素无序排列，但支持常数时间复杂度的查找、插入和删除操作。常见的无序关联容器有：</p>
<ul>
<li>**<code>unordered_set</code>**：无序集合，元素唯一。</li>
<li>**<code>unordered_map</code>**：无序键值对，基于哈希表存储。</li>
<li>**<code>unordered_multiset</code>**：无序多重集合，允许重复元素。</li>
<li>**<code>unordered_multimap</code>**：无序多重键值对，允许重复键。</li>
</ul>
<h5 id="unordered-set-无序集合，元素唯一"><a href="#unordered-set-无序集合，元素唯一" class="headerlink" title="unordered_set 无序集合，元素唯一"></a><strong><code>unordered_set</code></strong> 无序集合，元素唯一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; uset = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">// 重复的1被忽略</span><br>    uset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : uset) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出顺序不固定，例如：3 1 2 4 5</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="unordered-map-无序键值对，基于哈希表存储"><a href="#unordered-map-无序键值对，基于哈希表存储" class="headerlink" title="unordered_map 无序键值对，基于哈希表存储"></a><strong><code>unordered_map</code></strong> 无序键值对，基于哈希表存储</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; umap;<br>    umap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>    umap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>    umap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : umap) &#123;<br>        std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-comment">// 输出顺序不固定，例如：</span><br>        <span class="hljs-comment">// banana: 2</span><br>        <span class="hljs-comment">// apple: 3</span><br>        <span class="hljs-comment">// orange: 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="unordered-multiset-无序多重集合，允许重复元素"><a href="#unordered-multiset-无序多重集合，允许重复元素" class="headerlink" title="unordered_multiset 无序多重集合，允许重复元素"></a><strong><code>unordered_multiset</code></strong> 无序多重集合，允许重复元素</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_multiset&lt;<span class="hljs-type">int</span>&gt; ums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    ums.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 插入重复元素</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ums) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出顺序不固定，例如：1 1 2 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="unordered-multimap-无序多重键值对，允许重复键"><a href="#unordered-multimap-无序多重键值对，允许重复键" class="headerlink" title="unordered_multimap 无序多重键值对，允许重复键"></a><strong><code>unordered_multimap</code></strong> 无序多重键值对，允许重复键</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_multimap&lt;std::string, <span class="hljs-type">int</span>&gt; umm;<br>    umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>    umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;);<br>    umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>&#125;);  <span class="hljs-comment">// 相同键可以重复插入</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : umm) &#123;<br>        std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-comment">// 输出顺序不固定，例如：</span><br>        <span class="hljs-comment">// apple: 3</span><br>        <span class="hljs-comment">// apple: 5</span><br>        <span class="hljs-comment">// banana: 2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="三、算法-Algorithms"><a href="#三、算法-Algorithms" class="headerlink" title="三、算法 (Algorithms)"></a>三、算法 (Algorithms)</h4><p>STL 提供了一系列的算法来操作容器，如排序、查找、修改等。这些算法定义在头文件 <code>&lt;algorithm&gt;</code> 中，并且可以通过迭代器访问容器的元素。</p>
<h4 id="1-常用算法"><a href="#1-常用算法" class="headerlink" title="1. 常用算法"></a>1. <strong>常用算法</strong></h4><ul>
<li>**<code>sort</code>**：对容器进行排序。</li>
<li>**<code>find</code>**：查找某个元素。</li>
<li>**<code>binary_search</code>**：二分查找，要求容器是有序的。</li>
<li>**<code>reverse</code>**：将容器中的元素反转。</li>
<li>**<code>accumulate</code>**：计算容器中元素的累加和。</li>
<li>**<code>count</code>**：统计容器中某个元素的出现次数。</li>
</ul>
<h4 id="sort-对容器进行排序"><a href="#sort-对容器进行排序" class="headerlink" title="sort 对容器进行排序"></a><strong><code>sort</code></strong> 对容器进行排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::sort</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 升序排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3 4 5</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="find-查找某个元素"><a href="#find-查找某个元素" class="headerlink" title="find 查找某个元素"></a><strong><code>find</code></strong> 查找某个元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::find</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found: 3</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="binary-search-二分查找（要求容器是有序的）"><a href="#binary-search-二分查找（要求容器是有序的）" class="headerlink" title="binary_search 二分查找（要求容器是有序的）"></a><strong><code>binary_search</code></strong> 二分查找（要求容器是有序的）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::binary_search</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">bool</span> found = std::<span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">if</span> (found) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="reverse-将容器中的元素反转"><a href="#reverse-将容器中的元素反转" class="headerlink" title="reverse 将容器中的元素反转"></a><strong><code>reverse</code></strong> 将容器中的元素反转</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::reverse</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::<span class="hljs-built_in">reverse</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="accumulate-计算容器中元素的累加和"><a href="#accumulate-计算容器中元素的累加和" class="headerlink" title="accumulate 计算容器中元素的累加和"></a><strong><code>accumulate</code></strong> 计算容器中元素的累加和</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>  <span class="hljs-comment">// std::accumulate</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 初始值为0</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：Sum: 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="count-统计容器中某个元素的出现次数"><a href="#count-统计容器中某个元素的出现次数" class="headerlink" title="count 统计容器中某个元素的出现次数"></a><strong><code>count</code></strong> 统计容器中某个元素的出现次数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::count</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> cnt = std::<span class="hljs-built_in">count</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Count of 2: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：Count of 2: 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-自定义比较函数"><a href="#2-自定义比较函数" class="headerlink" title="2. 自定义比较函数"></a>2. <strong>自定义比较函数</strong></h4><hr>
<h4 id="sort-使用自定义比较函数"><a href="#sort-使用自定义比较函数" class="headerlink" title="sort 使用自定义比较函数"></a><strong><code>sort</code></strong> 使用自定义比较函数</h4><p>默认情况下，<code>std::sort</code> 会进行升序排序。我们可以通过传递一个自定义比较函数来控制排序方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::sort</span></span><br><br><span class="hljs-comment">// 自定义比较函数，实现降序排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), descending);  <span class="hljs-comment">// 使用自定义比较函数</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="find-if-使用自定义条件"><a href="#find-if-使用自定义条件" class="headerlink" title="find_if 使用自定义条件"></a><strong><code>find_if</code></strong> 使用自定义条件</h4><p><code>std::find_if</code> 可根据自定义的 <strong>谓词函数</strong> 查找符合条件的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::find_if</span></span><br><br><span class="hljs-comment">// 自定义谓词函数，查找第一个大于3的元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">greaterThanThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), greaterThanThree);<br><br>    <span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;First element greater than 3: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：4</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No element found\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="binary-search-自定义比较函数"><a href="#binary-search-自定义比较函数" class="headerlink" title="binary_search 自定义比较函数"></a><strong><code>binary_search</code></strong> 自定义比较函数</h4><p><code>std::binary_search</code> 也可以接受自定义的比较函数，但要求容器中的元素按该规则预先排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// std::binary_search, std::sort</span></span><br><br><span class="hljs-comment">// 自定义比较函数，进行降序比较</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), descending);  <span class="hljs-comment">// 降序排序</span><br><br>    <span class="hljs-type">bool</span> found = std::<span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, descending);<br>    <span class="hljs-keyword">if</span> (found) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="set-自定义比较函数（按降序存储）"><a href="#set-自定义比较函数（按降序存储）" class="headerlink" title="set 自定义比较函数（按降序存储）"></a><strong><code>set</code></strong> 自定义比较函数（按降序存储）</h4><p>C++ 中的 <strong><code>std::set</code></strong> 默认是升序排序。我们可以自定义一个比较函数来改变排序顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-comment">// 自定义比较函数，按降序排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Descending</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;<span class="hljs-type">int</span>, Descending&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : s) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="priority-queue-自定义比较函数（实现小顶堆）"><a href="#priority-queue-自定义比较函数（实现小顶堆）" class="headerlink" title="priority_queue 自定义比较函数（实现小顶堆）"></a><strong><code>priority_queue</code></strong> 自定义比较函数（实现小顶堆）</h4><p><code>std::priority_queue</code> 默认是大顶堆，我们可以通过自定义比较函数创建小顶堆。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 自定义比较函数，实现小顶堆</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 使较小的元素拥有更高优先级</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, Compare&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 3 5</span><br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="四、迭代器-Iterators"><a href="#四、迭代器-Iterators" class="headerlink" title="四、迭代器 (Iterators)"></a>四、迭代器 (Iterators)</h4><p>迭代器提供了一种统一的方式来遍历 STL 容器。常见的迭代器类型有：</p>
<ul>
<li>**<code>begin()</code> 和 <code>end()</code>**：返回指向容器第一个元素和尾后元素的迭代器。</li>
<li>**<code>rbegin()</code> 和 <code>rend()</code>**：返回逆序迭代器，分别指向最后一个元素和第一个元素之前的位置。</li>
<li>**<code>cbegin()</code> 和 <code>cend()</code>**：返回常量迭代器，不能用于修改元素。</li>
</ul>
<p>迭代器可以通过 <code>*it</code> 解引用访问元素，通过 <code>++it</code> 或 <code>--it</code> 移动到下一个或上一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 使用普通迭代器遍历</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using iterator: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用常量迭代器遍历</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using const_iterator: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">cbegin</span>(); it != vec.<span class="hljs-built_in">cend</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用逆序迭代器遍历</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using reverse_iterator: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">rbegin</span>(); it != vec.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="五-辅助工具类（Utility-Components）"><a href="#五-辅助工具类（Utility-Components）" class="headerlink" title="五.辅助工具类（Utility Components）"></a>五.辅助工具类（Utility Components）</h4><ul>
<li><strong>数据结构</strong>：<code>pair</code>、<code>tuple</code>、<code>make_pair</code>、<code>make_tuple</code></li>
<li><strong>移动语义和转发</strong>：<code>std::move</code>、<code>std::forward</code></li>
<li><strong>交换和引用</strong>：<code>std::swap</code>、<code>std::reference_wrapper</code></li>
<li><strong>关系运算符</strong>：<code>std::rel_ops</code></li>
<li><strong>类型特性工具</strong>：<code>std::declval</code>、<code>std::enable_if</code></li>
<li><strong>解构支持</strong>：<code>std::tie</code></li>
</ul>
<h4 id="pair-的基本使用"><a href="#pair-的基本使用" class="headerlink" title="pair 的基本使用"></a><strong><code>pair</code> 的基本使用</strong></h4><p><code>pair</code> 的定义在 <code>&lt;utility&gt;</code> 头文件中，通常用 <code>std::make_pair</code> 函数来创建一个 <code>pair</code>，也可以直接使用构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>  <span class="hljs-comment">// 引入pair所需的头文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 make_pair 函数创建一个 pair</span><br>    std::pair&lt;std::string, <span class="hljs-type">int</span>&gt; student = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">23</span>);<br><br>    <span class="hljs-comment">// 访问 pair 中的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; student.first &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; student.second &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 也可以直接使用构造函数初始化 pair</span><br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">score</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">98.5</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Rank: &quot;</span> &lt;&lt; score.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; score.second &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>pair</code> 的成员</strong></li>
</ol>
<ul>
<li><code>first</code>: 表示 <code>pair</code> 中的第一个元素。</li>
<li><code>second</code>: 表示 <code>pair</code> 中的第二个元素。</li>
</ul>
<p>可以通过 <code>pair.first</code> 和 <code>pair.second</code> 分别访问两个值。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>)</span></span>;  <span class="hljs-comment">// 初始化pair，第一个元素是int，第二个是char</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p.first &lt;&lt; std::endl;  <span class="hljs-comment">// 输出10</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Second: &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;  <span class="hljs-comment">// 输出&#x27;A&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>与容器结合使用</strong></li>
</ol>
<p><code>pair</code> 在 STL 容器中非常常用，特别是在关联容器（如 <code>map</code> 和 <code>set</code>）中，<code>pair</code> 用于表示键值对。在 <code>map</code> 中，键值对的每个元素实际上是一个 <code>pair</code>，其中 <code>first</code> 是键，<code>second</code> 是值。</p>
<p>在 <code>map</code> 中使用 <code>pair</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 map 来存储学生姓名和分数</span><br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; studentScores;<br><br>    <span class="hljs-comment">// 插入键值对，使用 make_pair 函数</span><br>    studentScores.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90</span>));<br>    studentScores.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">85</span>));<br><br>    <span class="hljs-comment">// 访问 map 中的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : studentScores) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; entry.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; entry.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 也可以通过 [] 操作符直接访问键值对</span><br>    studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] = <span class="hljs-number">88</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Charlie&#x27;s Score: &quot;</span> &lt;&lt; studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>比较 <code>pair</code></strong></li>
</ol>
<p><code>pair</code> 支持比较操作（如 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等）。比较规则是先比较 <code>first</code> 元素，如果 <code>first</code> 相等，则比较 <code>second</code> 元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 is less than p2&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 比较的是 first，若相等，则比较 second</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>p1</code> 和 <code>p2</code> 的 <code>first</code> 部分相同，比较结果取决于 <code>second</code> 部分。</p>
<ol start="5">
<li><strong><code>pair</code> 的常见用法</strong></li>
</ol>
<ul>
<li><p><strong>作为函数的返回值</strong>：当你需要从函数中返回多个值时，<code>pair</code> 可以作为方便的结构体来返回两个值，而不需要创建专门的结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">getMinMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(a, b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(b, a);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getMinMax</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Min: &quot;</span> &lt;&lt; result.first &lt;&lt; <span class="hljs-string">&quot;, Max: &quot;</span> &lt;&lt; result.second &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><strong><code>tuple</code> 作为扩展</strong></li>
</ol>
<p><code>pair</code> 只能存储两个相关联的值。如果你需要存储更多的值，可以使用 C++11 引入的 <code>tuple</code>，它是 <code>pair</code> 的扩展版，可以存储任意多个元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-type">double</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90.5</span>)</span></span>;<br><br>    <span class="hljs-comment">// 访问 tuple 中的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ID: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Score: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>tuple</code> 可以通过 <code>std::get&lt;index&gt;</code> 来访问每个元素，并且可以存储任意数量和类型的元素。</p>
<p><strong><code>pair</code>：一对数据存储</strong></p>
<ul>
<li><p><strong>功能：</strong> 存储两个不同类型的数据对，常用于 <strong><code>map</code></strong> 中的键值对存储。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br>std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：1, apple</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="tuple：多数据存储"><a href="#tuple：多数据存储" class="headerlink" title="tuple：多数据存储"></a><code>tuple</code>：多数据存储</h4><ul>
<li><p><strong>功能：</strong> 可存储任意数量、任意类型的元素，比 <code>pair</code> 更灵活。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3.14</span>);<br>std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-comment">// 输出：1, apple, 3.14</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="make-pair-和-make-tuple：简化对象创建"><a href="#make-pair-和-make-tuple：简化对象创建" class="headerlink" title="make_pair 和 make_tuple：简化对象创建"></a><strong><code>make_pair</code> 和 <code>make_tuple</code>：简化对象创建</strong></h4><ul>
<li><p><strong>功能：</strong> 分别用于创建 <code>pair</code> 和 <code>tuple</code>，自动推导类型，简化代码。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code>, <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">auto</span> p = std::make_pair(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br><span class="hljs-attribute">auto</span> t = std::make_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>.<span class="hljs-number">5</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="std-move：移动语义"><a href="#std-move：移动语义" class="headerlink" title="std::move：移动语义"></a><code>std::move</code>：移动语义</h4><ul>
<li><p><strong>功能：</strong> 用于将对象的资源移动到另一个对象，而不是复制，提高性能。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::string newStr = std::<span class="hljs-title function_ invoke__">move</span>(<span class="hljs-type">str</span>);  <span class="hljs-comment">// 将 str 移动到 newStr</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="std-forward：完美转发"><a href="#std-forward：完美转发" class="headerlink" title="std::forward：完美转发"></a><strong><code>std::forward</code>：完美转发</strong></h4><ul>
<li><p><strong>功能：</strong> 在模板函数中用于保持参数的值类别（左值或右值）。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> forwarded = std::forward&lt;T&gt;(arg);  <span class="hljs-comment">// 完美转发</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="std-swap：交换两个对象的值"><a href="#std-swap：交换两个对象的值" class="headerlink" title="std::swap：交换两个对象的值"></a><code>std::swap</code>：交换两个对象的值</h4><ul>
<li><p><strong>功能：</strong> 用于交换两个对象的内容。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-attribute">std</span>::swap(a, b);  // a 变为 <span class="hljs-number">20</span>，b 变为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>** <code>std::rel_ops</code>：自动实现关系运算符**</p>
<ul>
<li><p><strong>功能：</strong> 提供通用的关系运算符（如 <code>!=</code>, <code>&lt;=</code>），基于 <code>==</code> 和 <code>&lt;</code> 自动推导。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::rel_ops;  <span class="hljs-comment">// 开启运算符自动推导</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="std-reference-wrapper：引用包装器"><a href="#std-reference-wrapper：引用包装器" class="headerlink" title="std::reference_wrapper：引用包装器"></a><code>std::reference_wrapper</code>：引用包装器</h4><ul>
<li><p><strong>功能：</strong> 用于包装引用类型，方便存储在容器中。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;functional&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> n = <span class="hljs-number">10</span>;<br>std::<span class="hljs-built_in">ref</span>erence_wrapper&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">ref</span> = n;<br><span class="hljs-built_in">ref</span>.<span class="hljs-keyword">get</span>() = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 修改原始变量 n 的值为 20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="类型特性工具：std-declval、std-enable-if-等"><a href="#类型特性工具：std-declval、std-enable-if-等" class="headerlink" title="类型特性工具：std::declval、std::enable_if 等"></a>类型特性工具：<code>std::declval</code>、<code>std::enable_if</code> 等</h4><ul>
<li><p><strong>功能：</strong> 帮助在模板元编程中处理类型推导和 SFINAE（替换失败不为错误）等问题。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code>、<code>&lt;type_traits&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">template</span> &lt;typename <span class="hljs-type">T</span>&gt;<br><span class="hljs-title">auto</span> create() -&gt; decl<span class="hljs-keyword">type</span>(<span class="hljs-type">T</span>()) &#123;<br>    return <span class="hljs-type">T</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="std-tie：解构-tuple-或-pair"><a href="#std-tie：解构-tuple-或-pair" class="headerlink" title="std::tie：解构 tuple 或 pair"></a><strong><code>std::tie</code>：解构 <code>tuple</code> 或 <code>pair</code></strong></h4><ul>
<li><p><strong>功能：</strong> 将 <code>tuple</code> 或 <code>pair</code> 中的元素解构为多个变量。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>std::string c;<br>std::<span class="hljs-built_in">tie</span>(a, b, c) = t;  <span class="hljs-comment">// 解构 tuple</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>指针与引用</strong></p>
<p><strong>指针</strong></p>
<p>指针是存储内存地址的变量，通常在算法中用于动态内存分配或指向数组等复杂数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>* p = &amp;x;  <span class="hljs-comment">// 定义一个指针指向变量 x</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value of x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Pointer p points to value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;  <span class="hljs-comment">// 解引用指针</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>引用</strong></p>
<p>引用是变量的别名，常用于函数参数传递，以避免不必要的拷贝操作。它比指针更安全，不能是空引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span> </span>&#123;<br>    a++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">increment</span>(x);  <span class="hljs-comment">// 引用传递</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value of x after increment: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-常见的高级数据结构"><a href="#3-常见的高级数据结构" class="headerlink" title="3.常见的高级数据结构"></a>3.常见的高级数据结构</h3><h4 id="1-堆（Heap）"><a href="#1-堆（Heap）" class="headerlink" title="1. 堆（Heap）"></a>1. <strong>堆（Heap）</strong></h4><p>堆是一种特殊的二叉树，可以用数组表示，通常用于实现优先队列。在 C++ 中，STL 提供了 <code>priority_queue</code> 实现最大堆和最小堆。</p>
<p>最大堆的实现 (C++ 中的 <code>priority_queue</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; maxHeap;  <span class="hljs-comment">// 默认是最大堆</span><br><br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">15</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Max Heap top: &quot;</span> &lt;&lt; maxHeap.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出20</span><br>    maxHeap.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 删除堆顶元素</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After pop, Max Heap top: &quot;</span> &lt;&lt; maxHeap.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最小堆的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用greater&lt;int&gt;来实现最小堆</span><br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><br>    minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">15</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Min Heap top: &quot;</span> &lt;&lt; minHeap.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出10</span><br>    minHeap.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 删除堆顶元素</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After pop, Min Heap top: &quot;</span> &lt;&lt; minHeap.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-平衡二叉搜索树-BST"><a href="#2-平衡二叉搜索树-BST" class="headerlink" title="2. 平衡二叉搜索树 (BST)"></a>2. <strong>平衡二叉搜索树 (BST)</strong></h4><p>C++ 提供了 <code>set</code> 和 <code>map</code>，它们基于红黑树 (Red-Black Tree) 实现，用于维护元素的有序性并实现高效的查找、插入和删除操作，时间复杂度均为 O(log n)。</p>
<p><code>set</code> 示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; bst;  <span class="hljs-comment">// 底层是红黑树</span><br><br>    bst.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    bst.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br>    bst.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Set contains: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : bst) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出 5 10 20</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">if</span> (bst.<span class="hljs-built_in">find</span>(<span class="hljs-number">10</span>) != bst.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found 10 in the set&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    bst.<span class="hljs-built_in">erase</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 删除元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After erasing 10, Set contains: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : bst) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出 5 20</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-哈希表（Hash-Table）"><a href="#3-哈希表（Hash-Table）" class="headerlink" title="3. 哈希表（Hash Table）"></a>3. <strong>哈希表（Hash Table）</strong></h4><p>C++ 提供了 <code>unordered_set</code> 和 <code>unordered_map</code>，分别是基于哈希表实现的无序集合和映射。它们的查找、插入和删除的平均时间复杂度是 O(1)。</p>
<p><code>unordered_map</code> 示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; hashMap;<br><br>    hashMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">1</span>;<br>    hashMap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>    hashMap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">3</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;apple: &quot;</span> &lt;&lt; hashMap[<span class="hljs-string">&quot;apple&quot;</span>] &lt;&lt; std::endl;<br>    <br>    hashMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;banana&quot;</span>);  <span class="hljs-comment">// 删除键为 &quot;banana&quot; 的键值对</span><br><br>    <span class="hljs-comment">// 遍历所有键值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : hashMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-并查集-Union-Find"><a href="#4-并查集-Union-Find" class="headerlink" title="4. 并查集 (Union-Find)"></a>4. <strong>并查集 (Union-Find)</strong></h4><p>并查集是一种树型数据结构，用于处理不相交集合的合并与查询操作，通常用于图算法（如寻找连通分量）。</p>
<p>并查集实现：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> size) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(size);<br>        rank.<span class="hljs-built_in">resize</span>(size, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化秩为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            parent[i] = i;  <span class="hljs-comment">// 初始化父节点为自己</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parent[p] != p) &#123;<br>            parent[p] = <span class="hljs-built_in">find</span>(parent[p]);  <span class="hljs-comment">// 路径压缩</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[p];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootP = <span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ = <span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span> (rootP != rootQ) &#123;<br>            <span class="hljs-keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;<br>                parent[rootQ] = rootP;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootP] &lt; rank[rootQ]) &#123;<br>                parent[rootP] = rootQ;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent[rootQ] = rootP;<br>                rank[rootP] += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; rank;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>    uf.<span class="hljs-built_in">unionSet</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    uf.<span class="hljs-built_in">unionSet</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Find 1: &quot;</span> &lt;&lt; uf.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Find 3: &quot;</span> &lt;&lt; uf.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-常见的高级算法"><a href="#4-常见的高级算法" class="headerlink" title="4.常见的高级算法"></a>4.常见的高级算法</h3><h4 id="1-二分查找-Binary-Search"><a href="#1-二分查找-Binary-Search" class="headerlink" title="1. 二分查找 (Binary Search)"></a>1. <strong>二分查找 (Binary Search)</strong></h4><p>二分查找用于在有序数组中高效查找元素，时间复杂度为 O(log n)。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 没有找到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">7</span>;<br><br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">binarySearch</span>(nums, target);<br>    <span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found at index: &quot;</span> &lt;&lt; index &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-Dijkstra-最短路径算法"><a href="#2-Dijkstra-最短路径算法" class="headerlink" title="2. Dijkstra 最短路径算法"></a>2. <strong>Dijkstra 最短路径算法</strong></h4><p>Dijkstra 算法用于找到加权图中从起点到其他节点的最短路径，时间复杂度为 O(E log V)，其中 E 是边数，V 是顶点数。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">max</span>();<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; graph, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist)</span> </span>&#123;<br>    dist[start] = <span class="hljs-number">0</span>;<br>    std::priority_queue&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, std::greater&lt;&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = pq.<span class="hljs-built_in">top</span>().second;<br>        <span class="hljs-type">int</span> d = pq.<span class="hljs-built_in">top</span>().first;<br>        pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (d &gt; dist[u]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : graph[u]) &#123;<br>            <span class="hljs-type">int</span> v = edge.first;<br>            <span class="hljs-type">int</span> weight = edge.second;<br>            <span class="hljs-keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;<br>                dist[v] = dist[u] + weight;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> V = <span class="hljs-number">5</span>;<br>    std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">graph</span>(V);<br><br>    <span class="hljs-comment">// 构建图 (u, v, weight)</span><br>    graph[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">10</span>&#125;);<br>    graph[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>    graph[<span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;);<br>    graph[<span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;);<br>    graph[<span class="hljs-number">2</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>    graph[<span class="hljs-number">3</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;);<br>    graph[<span class="hljs-number">4</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;);<br>    graph[<span class="hljs-number">4</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">9</span>&#125;);<br>    graph[<span class="hljs-number">4</span>].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(V, INF)</span></span>;<br>    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">0</span>, graph, dist);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Distance from 0 to &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; dist[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-快速排序-Quick-Sort"><a href="#3-快速排序-Quick-Sort" class="headerlink" title="3. 快速排序 (Quick Sort)"></a>3. <strong>快速排序 (Quick Sort)</strong></h4><p>快速排序是一种分治算法，时间复杂度为 O(n log n)，最差情况下为 O(n^2)。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[high];<br>    <span class="hljs-type">int</span> i = low - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt; high; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>            i++;<br>            std::<span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[high]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, low, high);<br>        <span class="hljs-built_in">quickSort</span>(arr, low, pi - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pi + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">quickSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sorted array: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="5-优化技巧"><a href="#5-优化技巧" class="headerlink" title="5.优化技巧"></a>5.优化技巧</h3><p>在算法竞赛中，为了编写简洁高效的代码，争取时间并减少输入输出的繁琐步骤，常见的简便操作可以帮助你在紧张的比赛环境中提高编写和执行代码的效率。以下是一些常见的简便操作和优化技巧：</p>
<h4 id="1-快速输入输出"><a href="#1-快速输入输出" class="headerlink" title="1. 快速输入输出"></a>1. <strong>快速输入输出</strong></h4><p>在算法竞赛中，输入输出速度非常关键，尤其是对于大规模数据集。C++ 标准的 <code>cin</code> 和 <code>cout</code> 是比较方便的输入输出方式，但默认速度较慢，可以通过以下方式加速：</p>
<p><strong>加速 <code>cin</code> 和 <code>cout</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 关闭同步功能</span><br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 取消输入输出的绑定</span><br>    <br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Number: &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>ios::sync_with_stdio(false);</code>：关闭 <code>cin</code> 与 <code>scanf</code>，<code>cout</code> 与 <code>printf</code> 的同步，显著提高输入输出速度。</li>
<li><code>cin.tie(0);</code>：取消 <code>cin</code> 与 <code>cout</code> 的绑定，防止每次输入时都刷新输出缓冲区，可以提高效率。</li>
</ul>
<h4 id="2-使用宏定义减少代码量"><a href="#2-使用宏定义减少代码量" class="headerlink" title="2.使用宏定义减少代码量"></a>2.<strong>使用宏定义减少代码量</strong></h4><p>宏可以用于减少输入输出、常用算法或者常用数据结构的代码量。虽然宏定义过多可能影响代码的可读性，但在竞赛中可以帮助你快速编写代码。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long  <span class="hljs-comment">// 定义long long，避免重复写</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back   <span class="hljs-comment">// 定义push_back，缩短容器操作</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FAST_IO ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    FAST_IO  <span class="hljs-comment">// 使用宏快速加速I/O</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    vec.<span class="hljs-built_in">pb</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 使用宏减少代码长度</span><br>    vec.<span class="hljs-built_in">pb</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : vec) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-使用结构化绑定（C-17）"><a href="#3-使用结构化绑定（C-17）" class="headerlink" title="3. 使用结构化绑定（C++17）"></a>3. <strong>使用结构化绑定（C++17）</strong></h4><p>结构化绑定可以使得处理数据更加简洁，尤其在处理 <code>pair</code> 或 <code>tuple</code> 时，避免使用 <code>first</code>、<code>second</code> 等显式字段。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : vp) &#123;  <span class="hljs-comment">// 结构化绑定，简化代码</span><br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-使用-STL-简化操作"><a href="#4-使用-STL-简化操作" class="headerlink" title="4. 使用 STL 简化操作"></a>4. <strong>使用 STL 简化操作</strong></h4><p>C++ 标准模板库（STL）提供了丰富的容器和算法，可以大幅减少代码量和开发时间。在竞赛中常用的有：</p>
<p><strong><code>std::vector</code> 和 <code>std::pair</code></strong></p>
<ul>
<li><code>vector</code> 是动态数组，非常适合存储大规模数据。</li>
<li><code>pair</code> 用于存储两个相关联的值，常用于排序和存储坐标、键值对等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;&#125;;<br>    <br>    <span class="hljs-comment">// 使用sort对pair进行排序，按照first排序</span><br>    <span class="hljs-built_in">sort</span>(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : vp) &#123;<br>        cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>常用 STL 函数：<code>sort</code>、<code>max_element</code>、<code>min_element</code></strong></p>
<p>使用 STL 提供的算法库，如 <code>sort</code>、<code>max_element</code> 等，可以快速实现排序和最大最小值的查找，避免手动实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 查找最大值和最小值</span><br>    <span class="hljs-type">int</span> maxVal = *<span class="hljs-built_in">max_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> minVal = *<span class="hljs-built_in">min_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Max: &quot;</span> &lt;&lt; maxVal &lt;&lt; <span class="hljs-string">&quot;, Min: &quot;</span> &lt;&lt; minVal &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-适当使用inline-函数"><a href="#5-适当使用inline-函数" class="headerlink" title="5. 适当使用inline 函数"></a>5. <strong>适当使用<code>inline</code> 函数</strong></h4><p><code>inline</code> 函数可以减少函数调用的开销，尤其在竞赛中，当某些函数被频繁调用时，<code>inline</code> 关键字可以提升性能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">inline <span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    <span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-避免不必要的拷贝"><a href="#6-避免不必要的拷贝" class="headerlink" title="6. 避免不必要的拷贝"></a>6. <strong>避免不必要的拷贝</strong></h4><p>在处理较大数据时，尽量避免不必要的拷贝操作。可以使用引用传递或移动语义（C++11），提高效率。</p>
<p>引用传递示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;  <span class="hljs-comment">// 使用引用避免拷贝</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; data = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">printVector</span>(data);  <span class="hljs-comment">// 使用引用传递</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-使用-auto-减少冗长的类型声明"><a href="#7-使用-auto-减少冗长的类型声明" class="headerlink" title="7. 使用 auto 减少冗长的类型声明"></a>7. <strong>使用 <code>auto</code> 减少冗长的类型声明</strong></h4><p><code>auto</code> 关键字允许编译器自动推导变量类型，特别是在使用复杂的 STL 容器时，它可以显著减少代码的长度和复杂性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vec = vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动推导类型</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : vec) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出 1 2 3</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-提前规划代码结构"><a href="#8-提前规划代码结构" class="headerlink" title="8. 提前规划代码结构"></a>8. <strong>提前规划代码结构</strong></h4><p>为了应对竞赛中的多题目情境，提前写好一些常用的模板，比如快速输入输出模板、二分查找、DFS、BFS、动态规划等常用代码结构，在比赛时只需要专注于核心算法部分。</p>
<p>二分查找模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;  <span class="hljs-comment">// 找到目标</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未找到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; data = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">binarySearch</span>(data, target);<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Index of target: &quot;</span> &lt;&lt; index &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-预处理技巧"><a href="#9-预处理技巧" class="headerlink" title="9. 预处理技巧"></a>9. <strong>预处理技巧</strong></h4><p>有些算法问题中，可以通过预处理数据来加速查询或计算。例如在某些数学问题中，可以提前计算出所有可能的结果，避免重复计算。</p>
<p>预处理 <code>n!</code> 阶乘的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">1000</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">factorial</span><span class="hljs-params">(MAX_N + <span class="hljs-number">1</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">precomputeFactorials</span><span class="hljs-params">()</span> </span>&#123;<br>    factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= MAX_N; ++i) &#123;<br>        factorial[i] = factorial[i - <span class="hljs-number">1</span>] * i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">precomputeFactorials</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;10! = &quot;</span> &lt;&lt; factorial[<span class="hljs-number">10</span>] &lt;&lt; endl;  <span class="hljs-comment">// 输出 10!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="10-使用编译器优化"><a href="#10-使用编译器优化" class="headerlink" title="10. 使用编译器优化"></a>10. <strong>使用编译器优化</strong></h4><p>在算法竞赛中，可以使用编译器优化选项，如 <code>-O2</code> 或 <code>-O3</code> 来提升程序运行效率。</p>
<p>编译时使用 <code>g++</code>：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-literal">-</span><span class="hljs-comment">O2</span> <span class="hljs-literal">-</span><span class="hljs-comment">std=c</span><span class="hljs-literal">++</span><span class="hljs-comment">17 solution</span><span class="hljs-string">.</span><span class="hljs-comment">cpp</span> <span class="hljs-literal">-</span><span class="hljs-comment">o solution</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>-O2</code>：启用一般优化，适合大部分竞赛情况。</li>
<li><code>-O3</code>：更激进的优化，但在某些极限条件下可能会导致代码的非预期行为。</li>
</ul>
<h4 id="11-记忆化搜索"><a href="#11-记忆化搜索" class="headerlink" title="11. 记忆化搜索"></a>11. <strong>记忆化搜索</strong></h4><p>记忆化搜索是动态规划的一种方式，结合了递归和缓存结果的技术，避免重复计算。它常用于解决带有重叠子问题的递归问题，比如递归求解斐波那契数列。</p>
<p>示例：记忆化斐波那契数列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">memo</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">// 初始化一个数组来存储已经计算过的结果</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">if</span> (memo[n] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> memo[n];  <span class="hljs-comment">// 如果已经计算过，直接返回缓存的结果</span><br><br>    memo[n] = <span class="hljs-built_in">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fibonacci</span>(n - <span class="hljs-number">2</span>);  <span class="hljs-comment">// 递归计算并缓存结果</span><br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Fibonacci of &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">fibonacci</span>(n) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优点</strong>：大大减少了重复计算，尤其是当递归深度较大时，记忆化可以有效提升算法效率。</p>
<hr>
<h4 id="12-位操作优化"><a href="#12-位操作优化" class="headerlink" title="12. 位操作优化"></a>12. <strong>位操作优化</strong></h4><p>位操作是非常高效的操作，它能让很多算法在常数时间内完成操作。常见的应用包括判断奇偶性、交换数值、位掩码操作等。</p>
<p><strong>常见的位操作技巧</strong>：</p>
<ul>
<li><p><strong>判断奇偶</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &amp; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果 n 的最低位是 1 则为奇数，否则为偶数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>交换两个数</strong>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">void</span> swap(int &amp;a, int &amp;b) &#123;<br>    <span class="hljs-attribute">a</span> = a<span class="hljs-regexp"> ^</span> b;<br>    <span class="hljs-attribute">b</span> = a<span class="hljs-regexp"> ^</span> b;<br>    <span class="hljs-attribute">a</span> = a<span class="hljs-regexp"> ^</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>快速计算 2 的幂</strong>：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">bool isPowerOfTwo(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>    return (<span class="hljs-built_in">n</span> &gt; <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">n</span> &amp; (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;  // <span class="hljs-built_in">n</span> 是 <span class="hljs-number">2</span> 的幂时，其二进制中只有一个 <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="13-处理大整数运算"><a href="#13-处理大整数运算" class="headerlink" title="13. 处理大整数运算"></a>13. <strong>处理大整数运算</strong></h4><p>在算法竞赛中，有时会遇到超出标准 <code>int</code> 范围的整数运算（如大数乘法、幂运算等）。C++ 可以使用标准库中的 <code>__int128</code>（在某些编译器下可用），但更常用的方式是处理模运算，确保大数计算不会溢出。</p>
<p><strong>快速幂运算（模幂运算）</strong>：</p>
<p>快速幂用于计算形如 <code>a^b mod c</code> 的大数运算，其时间复杂度为 O(log b)，比直接乘法更高效。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-title">modPow</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">base</span>, <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> exp, <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> mod</span>)</span> &#123;<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (exp &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (exp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果 exp 是奇数</span><br>            result = (result * <span class="hljs-keyword">base</span>) % mod;<br>        &#125;<br>        <span class="hljs-keyword">base</span> = (<span class="hljs-keyword">base</span> * <span class="hljs-keyword">base</span>) % mod;  <span class="hljs-comment">// 平方</span><br>        exp /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">base</span> = <span class="hljs-number">2</span>, exp = <span class="hljs-number">10</span>, mod = <span class="hljs-number">1000000007</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2^10 % 1000000007 = &quot;</span> &lt;&lt; modPow(<span class="hljs-keyword">base</span>, exp, mod) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：在处理大数的乘法或幂运算时，模运算可以防止数值溢出，并且是数论问题中的常用技巧。</p>
<hr>
<h4 id="14-双指针技巧"><a href="#14-双指针技巧" class="headerlink" title="14. 双指针技巧"></a>14. <strong>双指针技巧</strong></h4><p>双指针是一种高效的数组和链表处理技巧，常用于解决有序数组中的查找、区间问题等。例如，双指针可以在 O(n) 时间复杂度内完成两个有序数组的合并、判断子数组的和是否等于给定值等。</p>
<p>示例：求解有序数组中的两数之和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">twoSumSorted</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> sum = arr[left] + arr[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 找到和为 target 的两个数</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">twoSumSorted</span>(arr, target)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Found two numbers with sum &quot;</span> &lt;&lt; target &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No two numbers found&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：双指针在处理区间、滑动窗口、链表等场景中非常常用，是解决两数问题、三数问题等经典问题的有效方法。</p>
<hr>
<h4 id="15-滑动窗口技术"><a href="#15-滑动窗口技术" class="headerlink" title="15. 滑动窗口技术"></a>15. <strong>滑动窗口技术</strong></h4><p>滑动窗口是一种高效的处理子数组、子串问题的技巧，适合用在求解固定长度或动态长度的窗口内的最优值。通常，滑动窗口可以在 O(n) 时间复杂度内完成任务。</p>
<p>示例：滑动窗口求解最长不重复子串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">char</span> c = s[right];<br>        window[c]++;<br>        right++;<br><br>        <span class="hljs-comment">// 如果窗口中有重复的字符，收缩左边界</span><br>        <span class="hljs-keyword">while</span> (window[c] &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">char</span> d = s[left];<br>            window[d]--;<br>            left++;<br>        &#125;<br><br>        maxLength = <span class="hljs-built_in">max</span>(maxLength, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLength;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;abcabcbb&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Longest substring length: &quot;</span> &lt;&lt; <span class="hljs-built_in">lengthOfLongestSubstring</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：滑动窗口技术常用于解决子串或子数组问题，例如最长连续子串、最大子数组和等问题。</p>
<hr>
<h4 id="16-优先队列（堆）"><a href="#16-优先队列（堆）" class="headerlink" title="16. 优先队列（堆）"></a>16. <strong>优先队列（堆）</strong></h4><p>优先队列（堆）是一种高效的数据结构，常用于需要动态维护最大值或最小值的场景。C++ 提供了 <code>std::priority_queue</code>，用于实现最大堆和最小堆。</p>
<p>示例：使用优先队列求解滑动窗口中的最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq;  <span class="hljs-comment">// 双端队列，用于存储元素下标</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-comment">// 移除滑动窗口外的元素</span><br>        <span class="hljs-keyword">if</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() == i - k) dq.<span class="hljs-built_in">pop_front</span>();<br><br>        <span class="hljs-comment">// 移除队列中所有比当前元素小的元素</span><br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) dq.<span class="hljs-built_in">pop_back</span>();<br><br>        <span class="hljs-comment">// 将当前元素下标加入队列</span><br>        dq.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-comment">// 如果当前下标 i 达到窗口大小 k，记录当前最大值</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) result.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">3</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">maxSlidingWindow</span>(nums, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : result) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：优先队列常用于需要实时维护最大值或最小值的问题，如动态滑动窗口最大值、最小生成树（Prim、Kruskal）、Dijkstra 算法等。</p>
<hr>
<h4 id="17-使用动态规划模板"><a href="#17-使用动态规划模板" class="headerlink" title="17. 使用动态规划模板"></a>17. <strong>使用动态规划模板</strong></h4><p>在竞赛中，动态规划（DP）是非常常见的技巧。通过模板化的解法，可以快速解决很多 DP 问题，如背包问题、最长子序列问题、区间问题等。</p>
<p>示例：0-1 背包问题的动态规划解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> W, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; values)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = weights.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">1</span>; w &lt;= W; ++w) &#123;<br>            <span class="hljs-keyword">if</span> (weights[i - <span class="hljs-number">1</span>] &lt;= w) &#123;<br>                dp[i][w] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][w], dp[i - <span class="hljs-number">1</span>][w - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][w] = dp[i - <span class="hljs-number">1</span>][w];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][W];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weights = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; values = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> W = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum value: &quot;</span> &lt;&lt; <span class="hljs-built_in">knapsack</span>(W, weights, values) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：动态规划适用于很多优化问题，如背包问题、最长递增子序列、区间合并等。</p>
<h1 id="一-数组"><a href="#一-数组" class="headerlink" title="一.数组"></a>一.数组</h1><p>c++的操作</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;cstdio&gt;  // For printf</span><br><span class="hljs-comment">#include &lt;algorithm&gt;  // For sort and reverse</span><br><br><span class="hljs-keyword">int</span> main() &#123;<br>    <span class="hljs-regexp">//</span> 初始化数组<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;数组第一个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, arr[<span class="hljs-number">0</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">1</span><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;数组第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, arr[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">3</span><br><br>    // 修改数组元素<br>    arr[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;修改后的第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, arr[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">10</span><br><br>    // 使用<span class="hljs-keyword">for</span>循环遍历数组<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;数组元素: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-regexp">//</span> 使用C风格的数组模拟vector功能<br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">vec</span>[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">int</span> vec_size = <span class="hljs-number">5</span>;  <span class="hljs-regexp">//</span> 跟踪实际元素个数<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;vector第一个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, <span class="hljs-keyword">vec</span>[<span class="hljs-number">0</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">1</span><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;vector第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">3</span><br><br>    // 修改vector元素<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;修改后的第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">10</span><br><br>    // 向vector中添加元素（实际是模拟）<br>    <span class="hljs-keyword">if</span> (vec_size &lt; <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-keyword">vec</span>[vec_size] = <span class="hljs-number">6</span>;  <span class="hljs-regexp">//</span> 添加到末尾<br>        vec_size++;<br>    &#125;<br><br>    // 手动插入元素，模拟插入操作<br>    <span class="hljs-keyword">if</span> (vec_size &lt; <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = vec_size; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-keyword">vec</span>[i] = <span class="hljs-keyword">vec</span>[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">vec</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">7</span>;  <span class="hljs-regexp">//</span> 在索引<span class="hljs-number">1</span>处插入<br>        vec_size++;<br>    &#125;<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;添加元素后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-regexp">//</span> 从vector中删除元素（手动操作）<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vec_size - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">vec</span>[i] = <span class="hljs-keyword">vec</span>[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    vec_size--;  <span class="hljs-regexp">//</span> 删除末尾元素<br>    vec_size--;  <span class="hljs-regexp">//</span> 再删除一个<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;删除元素后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-regexp">//</span> 清空vector（模拟）<br>    vec_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;清空后的vector大小: <span class="hljs-variable">%d</span>\n&quot;</span>, vec_size);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">0</span><br><br>    // 重新填充vector<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;<br>    vec_size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-regexp">//</span> 排序和反转vector<br>    std::<span class="hljs-keyword">sort</span>(<span class="hljs-keyword">vec</span>, <span class="hljs-keyword">vec</span> + vec_size);  <span class="hljs-regexp">//</span> 使用标准算法排序<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;排序后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    std::<span class="hljs-keyword">reverse</span>(<span class="hljs-keyword">vec</span>, <span class="hljs-keyword">vec</span> + vec_size);  <span class="hljs-regexp">//</span> 使用标准算法反转<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;反转后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">java</span> &#123;<br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 初始化数组</span><br>        <span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-comment">// 访问元素</span><br>        System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">2</span>]);  <span class="hljs-comment">// 输出 3, 访问数组中索引为2的元素</span><br>        <span class="hljs-comment">// 修改元素</span><br>        arr[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 将数组中索引为2的元素修改为10</span><br>        <span class="hljs-comment">// 使用ArrayList来实现动态数组Arrays.asList是java.util.Arrays类中的一个静态方法，它接受一个可变参数（varargs）并返回一个包含这些元素的固定大小的List然后使用new ArrayList&lt;&gt;(...)构造一个新的ArrayList对象，初始内容为上述固定大小的List中的元素。这使得新创建的ArrayList具有这些初始元素，同时它是可变大小的，可以添加和删除元素。</span><br>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-number">6</span>);  <span class="hljs-comment">// 在数组末尾添加元素6</span><br>        <span class="hljs-comment">// 删除元素之前先检查是否存在</span><br>        <span class="hljs-keyword">if</span> (list.contains(<span class="hljs-number">3</span>)) &#123;  <span class="hljs-comment">// 检查元素3是否在数组中</span><br>            list.remove(Integer.valueOf(<span class="hljs-number">3</span>));  <span class="hljs-comment">// 删除数组中的元素3</span><br>        &#125;<br>        <span class="hljs-comment">// 打印修改后的数组</span><br>        System.<span class="hljs-keyword">out</span>.println(list);  <span class="hljs-comment">// 输出修改后的数组 [1, 2, 10, 4, 5, 6]</span><br><br><br>        <span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>Array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        String[] strArray = new String[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 初始化一个包含5个元素的数组，元素默认值为null</span><br>        <span class="hljs-built_in">int</span> firstElement = <span class="hljs-built_in">int</span>Array[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 访问第一个元素</span><br>        <span class="hljs-built_in">int</span>Array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 修改第三个元素的值为10</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>Array.length; i++) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">int</span>Array[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> value : <span class="hljs-built_in">int</span>Array) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(value);<br>        &#125;<br>        Arrays.sort(<span class="hljs-built_in">int</span>Array);  <span class="hljs-comment">// 对数组进行排序，要import java.util.Arrays;</span><br><br>        <span class="hljs-built_in">int</span>[] newArray = Arrays.copyOf(<span class="hljs-built_in">int</span>Array, <span class="hljs-built_in">int</span>Array.length);  <span class="hljs-comment">// 复制整个数组</span><br>        <span class="hljs-built_in">int</span>[] partialArray = Arrays.copyOf(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 复制数组的前3个元素</span><br>        <span class="hljs-built_in">int</span>[] destinationArray = new <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br>        System.<span class="hljs-built_in">array</span>copy(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">0</span>, destinationArray, <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>Array.length);  <span class="hljs-comment">// 复制数组到另一个数组</span><br><br>        String <span class="hljs-built_in">array</span>String = Arrays.toString(<span class="hljs-built_in">int</span>Array);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">array</span>String);  <span class="hljs-comment">// 输出数组的字符串表示</span><br>        List&lt;Integer&gt; <span class="hljs-built_in">array</span>List = new ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br><br>        Arrays.fill(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 将数组的所有元素设置为10</span><br>        Arrays.fill(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 将数组的部分元素设置为20（索引1到2）</span><br>        <span class="hljs-built_in">int</span>[] anotherArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-built_in">bool</span>ean <span class="hljs-built_in">array</span>sEqual = Arrays.equals(<span class="hljs-built_in">int</span>Array, anotherArray);  <span class="hljs-comment">// 检查两个数组是否相等</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Arrays are equal: &quot;</span> + <span class="hljs-built_in">array</span>sEqual);<br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 初始化列表</span><br><span class="hljs-attribute">arr</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">2</span>])  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span><br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5]</span><br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">arr</span>.append(<span class="hljs-number">6</span>)  # 在末尾添加<br><span class="hljs-attribute">arr</span>.insert(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)  # 在索引<span class="hljs-number">1</span>处插入<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 7, 2, 10, 4, 5, 6]</span><br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">arr</span>.remove(<span class="hljs-number">7</span>)  # 移除第一个值为<span class="hljs-number">7</span>的元素<br><span class="hljs-attribute">del</span> arr[<span class="hljs-number">2</span>]  # 删除索引<span class="hljs-number">2</span>处的元素<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5, 6]</span><br><br><span class="hljs-comment"># 切片</span><br><span class="hljs-attribute">sub_arr</span> = arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  # 从索引<span class="hljs-number">1</span>到索引<span class="hljs-number">3</span>的子数组<br><span class="hljs-attribute">print</span>(sub_arr)  # 输出<span class="hljs-meta"> [2, 10, 4]</span><br><br><span class="hljs-comment"># 遍历</span><br><span class="hljs-attribute">for</span> value in arr:<br>    <span class="hljs-attribute">print</span>(value, end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">print</span>()<br><br><span class="hljs-comment"># 使用索引遍历</span><br><span class="hljs-attribute">for</span> i in range(len(arr)):<br>    <span class="hljs-attribute">print</span>(arr[i], end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">print</span>()<br><br><span class="hljs-comment"># 检查元素是否在列表中</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">10</span> in arr)  # 输出 True<br><br><span class="hljs-comment"># 获取长度</span><br><span class="hljs-attribute">print</span>(len(arr))  # 输出 <span class="hljs-number">6</span><br><br><span class="hljs-comment"># 列表合并</span><br><span class="hljs-attribute">arr2</span> =<span class="hljs-meta"> [7, 8, 9]</span><br><span class="hljs-attribute">combined_arr</span> = arr + arr2<br><span class="hljs-attribute">print</span>(combined_arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5, 6, 7, 8, 9]</span><br><br><span class="hljs-comment"># 列表排序</span><br><span class="hljs-attribute">arr</span>.sort()<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 4, 5, 6, 10]</span><br><br><span class="hljs-comment"># 列表反转</span><br><span class="hljs-attribute">arr</span>.reverse()<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [10, 6, 5, 4, 2, 1]</span><br><br><br><span class="hljs-comment">#使用 NumPy 数组操作</span><br><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-comment"># 初始化数组</span><br><span class="hljs-attribute">arr</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">2</span>])  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span><br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [ 1  2 10  4  5]</span><br><br><span class="hljs-comment"># 切片</span><br><span class="hljs-attribute">sub_arr</span> = arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  # 从索引<span class="hljs-number">1</span>到索引<span class="hljs-number">3</span>的子数组<br><span class="hljs-attribute">print</span>(sub_arr)  # 输出<span class="hljs-meta"> [ 2 10  4]</span><br><br><span class="hljs-comment"># 遍历</span><br><span class="hljs-attribute">for</span> value in arr:<br>    <span class="hljs-attribute">print</span>(value, end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">print</span>()<br><span class="hljs-comment"># 数组元素的加法</span><br><span class="hljs-attribute">arr2</span> = np.array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])<br><span class="hljs-attribute">result</span> = arr + arr2<br><span class="hljs-attribute">print</span>(result)  # 输出<span class="hljs-meta"> [11 22 40 44 55]</span><br><br><span class="hljs-comment"># 数组元素的乘法</span><br><span class="hljs-attribute">result</span> = arr * <span class="hljs-number">2</span><br><span class="hljs-attribute">print</span>(result)  # 输出<span class="hljs-meta"> [ 2  4 20  8 10]</span><br><br><span class="hljs-comment"># 数组的矩阵运算</span><br><span class="hljs-attribute">matrix1</span> = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<span class="hljs-meta"> [3, 4]])</span><br><span class="hljs-meta">matrix2 = np.array([[5, 6], [7, 8]])</span><br><span class="hljs-meta">result = np.dot(matrix1, matrix2)</span><br><span class="hljs-meta">print(result)</span><br><span class="hljs-meta"># 输出</span><br><span class="hljs-meta"># [[19 22]</span><br><span class="hljs-comment">#  [43 50]]</span><br><span class="hljs-comment"># 创建特定形状的数组</span><br><span class="hljs-attribute">zeros</span> = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(zeros)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[0. 0. 0.]</span><br><span class="hljs-comment">#  [0. 0. 0.]</span><br><span class="hljs-comment">#  [0. 0. 0.]]</span><br><br><span class="hljs-attribute">ones</span> = np.ones((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))<br><span class="hljs-attribute">print</span>(ones)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[1. 1. 1. 1.]</span><br><span class="hljs-comment">#  [1. 1. 1. 1.]]</span><br><br><span class="hljs-comment"># 生成等差数组</span><br><span class="hljs-attribute">arr</span> = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [0 2 4 6 8]</span><br><br><span class="hljs-comment"># 数组重塑</span><br><span class="hljs-attribute">arr</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-attribute">reshaped</span> = arr.reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(reshaped)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[1 2 3]</span><br><span class="hljs-comment">#  [4 5 6]]</span><br><span class="hljs-comment"># 创建一个包含1到10的平方的列表</span><br><span class="hljs-attribute">squares</span> =<span class="hljs-meta"> [x**2 for x in range(1, 11)]</span><br><span class="hljs-attribute">print</span>(squares)  # 输出<span class="hljs-meta"> [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><br><span class="hljs-comment"># 过滤列表中的元素</span><br><span class="hljs-attribute">even_squares</span> =<span class="hljs-meta"> [x**2 for x in range(1, 11) if x % 2 == 0]</span><br><span class="hljs-attribute">print</span>(even_squares)  # 输出<span class="hljs-meta"> [4, 16, 36, 64, 100]</span><br></code></pre></td></tr></table></figure>

<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>针对去重这类操作的模版</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">num</span>.size;i++)&#123;<br>	<span class="hljs-keyword">if</span>(要什么)&#123;<br>		<span class="hljs-built_in">num</span>[n] = <span class="hljs-built_in">num</span>[i];<br>		n++;<br>	&#125;<br>&#125;<br>去重:i=<span class="hljs-number">0</span> || <span class="hljs-built_in">num</span>[i]!=<span class="hljs-built_in">num</span>[i<span class="hljs-number">-1</span>]<br>移动零: <span class="hljs-built_in">num</span>[i]!=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h1><p>c++的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">data</span>(data), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* head;<br><br>    <span class="hljs-built_in">LinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node* last = head;<br>        <span class="hljs-keyword">while</span> (last-&gt;next) &#123;<br>            last = last-&gt;next;<br>        &#125;<br>        last-&gt;next = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepend</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        newNode-&gt;next = head;<br>        head = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteWithValue</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (head-&gt;data == data) &#123;<br>            Node* temp = head;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;data != data) &#123;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current-&gt;next) &#123;<br>            Node* temp = current-&gt;next;<br>            current-&gt;next = current-&gt;next-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;None&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            Node* next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            current = next;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用链表类</span><br>    LinkedList myList;<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">1</span>);<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">2</span>);<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">3</span>);<br>    myList.<span class="hljs-built_in">prepend</span>(<span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list after additions: &quot;</span>;<br>    myList.<span class="hljs-built_in">printList</span>();  <span class="hljs-comment">// 输出: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; None</span><br><br>    myList.<span class="hljs-built_in">deleteWithValue</span>(<span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list after deleting 2: &quot;</span>;<br>    myList.<span class="hljs-built_in">printList</span>();  <span class="hljs-comment">// 输出: 0 -&gt; 1 -&gt; 3 -&gt; None</span><br><br>    <span class="hljs-comment">// 使用 std::list 示例</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Using std::list:&quot;</span> &lt;&lt; std::endl;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// 添加元素</span><br>    lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after additions: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First element: &quot;</span> &lt;&lt; lst.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Last element: &quot;</span> &lt;&lt; lst.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl;    <span class="hljs-comment">// 输出: 4</span><br><br>    <span class="hljs-comment">// 修改元素</span><br>    <span class="hljs-keyword">auto</span> it = lst.<span class="hljs-built_in">begin</span>();<br>    ++it;  <span class="hljs-comment">// 指向第二个元素</span><br>    *it = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after modifying second element: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    lst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">10</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after removing 10: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>链表类（LinkedList）:<br><br><span class="hljs-built_in">append</span>(<span class="hljs-type">int</span> data)：在链表末尾添加元素。<br><span class="hljs-built_in">prepend</span>(<span class="hljs-type">int</span> data)：在链表头部添加元素。<br><span class="hljs-built_in">deleteWithValue</span>(<span class="hljs-type">int</span> data)：删除值为 data 的节点。<br><span class="hljs-built_in">printList</span>()：打印链表中的所有元素。<br>析构函数 ~<span class="hljs-built_in">LinkedList</span>()：释放链表占用的内存。<br>std::list 示例:<br><br><span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)：在列表末尾添加元素。<br><span class="hljs-built_in">push_front</span>(<span class="hljs-type">int</span> value)：在列表头部添加元素。<br><span class="hljs-built_in">front</span>()：访问第一个元素。<br><span class="hljs-built_in">back</span>()：访问最后一个元素。<br>通过迭代器修改元素。<br><span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> value)：删除值为 value 的所有元素。<br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> java1 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 初始化链表</span><br>        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Initial list: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br><br>        <span class="hljs-comment">// 访问元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;First element: &quot;</span> + list.getFirst()); <span class="hljs-comment">// 输出 1</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Last element: &quot;</span> + list.getLast());   <span class="hljs-comment">// 输出 3</span><br><br>        <span class="hljs-comment">// 修改元素</span><br>        list.set(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 修改索引1处的元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after modification: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 20, 3]</span><br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除索引1处的元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after removal: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 3]</span><br><br>        <span class="hljs-comment">// 链表大小</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Size of the list: &quot;</span> + list.<span class="hljs-keyword">size</span>()); <span class="hljs-comment">// 输出 2</span><br><br>        <span class="hljs-comment">// 遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using for-each loop: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (Integer element : list) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(element + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用迭代器遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using iterator: &quot;</span>);<br>        Iterator&lt;Integer&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(iterator.<span class="hljs-keyword">next</span>() + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用索引遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using for loop: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-keyword">size</span>(); i++) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(list.get(i) + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用Deque操作</span><br>        list.addFirst(<span class="hljs-number">0</span>); <span class="hljs-comment">// 在头部添加元素</span><br>        list.addLast(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 在尾部添加元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after deque operations: &quot;</span> + list); <span class="hljs-comment">// 输出 [0, 1, 3, 4]</span><br><br>        <span class="hljs-comment">// 删除Deque操作</span><br>        list.removeFirst(); <span class="hljs-comment">// 删除头部元素</span><br>        list.removeLast();  <span class="hljs-comment">// 删除尾部元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after removing first and last: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 3]</span><br><br>        <span class="hljs-comment">// 检查元素是否存在</span><br>        <span class="hljs-keyword">boolean</span> contains = list.contains(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List contains 3: &quot;</span> + contains); <span class="hljs-comment">// 输出 true</span><br><br>        <span class="hljs-comment">// 清空链表</span><br>        list.clear();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after clear: &quot;</span> + list); <span class="hljs-comment">// 输出 []</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Size of the list after clear: &quot;</span> + list.<span class="hljs-keyword">size</span>()); <span class="hljs-comment">// 输出 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 使用 Python 内置的 list</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Using Python list:&quot;</span>)<br><br><span class="hljs-comment"># 初始化列表</span><br><span class="hljs-attribute">lst</span> =<span class="hljs-meta"> [1, 2, 3]</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Initial list:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 2, 3]</span><br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">lst</span>.append(<span class="hljs-number">4</span>)  # 在末尾添加元素<br><span class="hljs-attribute">lst</span>.insert(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>)  # 在索引<span class="hljs-number">1</span>处插入元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after additions:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 1.5, 2, 3, 4]</span><br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;First element:&quot;</span>, lst[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Last element:&quot;</span>, lst[-<span class="hljs-number">1</span>])  # 输出 <span class="hljs-number">4</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">lst</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after modification:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 1.8, 2, 3, 4]</span><br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">lst</span>.remove(<span class="hljs-number">1</span>.<span class="hljs-number">8</span>)  # 删除值为<span class="hljs-number">1</span>.<span class="hljs-number">8</span>的元素<br><span class="hljs-attribute">del</span> lst[<span class="hljs-number">0</span>]  # 删除索引<span class="hljs-number">0</span>处的元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after deletions:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [2, 3, 4]</span><br><br><span class="hljs-comment"># 列表长度</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Length of the list:&quot;</span>, len(lst))  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历列表</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Traversing the list:&quot;</span>)<br><span class="hljs-attribute">for</span> item in lst:<br>    <span class="hljs-attribute">print</span>(item, end=<span class="hljs-string">&quot; &quot;</span>)  # 输出 <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment">### 使用 `collections.deque`</span><br><br><br><span class="hljs-attribute">from</span> collections import deque<br><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Using collections.deque:&quot;</span>)<br><br><span class="hljs-comment"># 初始化deque</span><br><span class="hljs-attribute">d</span> = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Initial deque:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">d</span>.append(<span class="hljs-number">4</span>)  # 在尾部添加<br><span class="hljs-attribute">d</span>.appendleft(<span class="hljs-number">0</span>)  # 在头部添加<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after additions:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 访问元素（需要转换为列表）</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;First element:&quot;</span>, d[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">0</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Last element:&quot;</span>, d[-<span class="hljs-number">1</span>])  # 输出 <span class="hljs-number">4</span><br><br><span class="hljs-comment"># 修改元素（需要转换为列表）</span><br><span class="hljs-attribute">d_list</span> = list(d)<br><span class="hljs-attribute">d_list</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">d</span> = deque(d_list)<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after modification:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">d</span>.pop()  # 删除尾部元素<br><span class="hljs-attribute">d</span>.popleft()  # 删除头部元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after deletions:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">1</span>.<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># deque长度</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Length of the deque:&quot;</span>, len(d))  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历deque</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Traversing the deque:&quot;</span>)<br><span class="hljs-attribute">for</span> item in d:<br>    <span class="hljs-attribute">print</span>(item, end=<span class="hljs-string">&quot; &quot;</span>)  # 输出 <span class="hljs-number">1</span>.<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h2 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl">head  head 是一个指针，指向链表的第一个节点，因此它表示整个链表的起始<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;null(补充的<span class="hljs-keyword">last</span>)<br><br> struct ListNode &#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* <span class="hljs-keyword">next</span>;<br>    ListNode(<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>) : val(<span class="hljs-keyword">x</span>), <span class="hljs-keyword">next</span>(nullptr) &#123;&#125;<br>&#125;;<br><br>ListNode* reverseList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-keyword">last</span> = nullptr;<br>    <span class="hljs-keyword">while</span> (head != nullptr) &#123;<br>        ListNode* nextHead = head-&gt;<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span> 暂存下一个节点<br>        head-&gt;<span class="hljs-keyword">next</span> = <span class="hljs-keyword">last</span>;                <span class="hljs-regexp">//</span> 反转当前节点的指针<br>        <span class="hljs-keyword">last</span> = head;                      <span class="hljs-regexp">//</span> 更新<span class="hljs-keyword">last</span>为当前节点<br>        head = nextHead;                  <span class="hljs-regexp">//</span> 继续处理下一个节点<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">last</span>;                          <span class="hljs-regexp">//</span> 返回新头节点<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="三-单调栈"><a href="#三-单调栈" class="headerlink" title="三.单调栈"></a>三.单调栈</h1><h3 id="经验-2"><a href="#经验-2" class="headerlink" title="经验"></a>经验</h3><p>当新h小于之前的h,进行累加长度更新答案,pop上一个被推的栈,推累长加一的h栈</p>
<p>核心思想:单调栈考虑前面不影响后面<br>套路模版: </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//int一个答案要全局</span><br>heights.push_back(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果需要弹空就写</span><br><span class="hljs-keyword">for</span>()&#123;<br>	<span class="hljs-keyword">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(栈顶与新元素不满足单调栈)&#123;<br>	 	累加长度<br>	 	更新答案<br>	 	<span class="hljs-keyword">pop</span>弹栈<br>	 	....... <span class="hljs-comment">//期间可以思考增加限制</span><br>	&#125;<br>	s.<span class="hljs-keyword">push</span>(&#123;accmulatedWidth+<span class="hljs-number">1</span>,height&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino">heighs=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br><span class="hljs-keyword">private</span>:<br>	stuct UERT&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	stack &lt;UERT&gt; s;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    	heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 便于最后清空栈</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>    		<span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度小于栈顶柱子的高度，则计算面积</span><br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>().height &gt;= height) &#123;<br>                accmulatedWidth += s.<span class="hljs-built_in">top</span>().width;<br>                res = <span class="hljs-built_in">max</span>(ans,s.<span class="hljs-built_in">top</span>().width*accmulatedWidth);            <br>                s.<span class="hljs-built_in">pop</span>();            <br>        	&#125;<br>        	s.<span class="hljs-built_in">push</span>(&#123;accmulatedWidth<span class="hljs-number">+1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>   		&#125;<br>    	<span class="hljs-keyword">return</span> res;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UERT</span>&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	stack &lt;UERT&gt; s;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>            <span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度大于栈顶柱子，计算能存储的雨水</span><br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>().height &lt;= height) &#123;<br>                <span class="hljs-type">int</span> bottom = s.<span class="hljs-built_in">top</span>().height;<br>                accmulatedWidth += s.<span class="hljs-built_in">top</span>().width;<br>                s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果栈为空，跳过,水从左边溜走了</span><br>                <span class="hljs-type">int</span> up = <span class="hljs-built_in">min</span>(height,s.<span class="hljs-built_in">top</span>().height);<br>                ans += accmulatedWidth*(up-bottom);<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(&#123;accmulatedWidth<span class="hljs-number">+1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>        &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;	<br>	<br>前缀和思想<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = heights.<span class="hljs-built_in">size</span>();<br>    preMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    sufMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    <br>    <span class="hljs-comment">// 预处理preMax数组</span><br>    preMax[<span class="hljs-number">0</span>] = heights[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        preMax[i] = <span class="hljs-built_in">max</span>(preMax[i - <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 预处理sufMax数组</span><br>    sufMax[n - <span class="hljs-number">1</span>] = heights[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        sufMax[i] = <span class="hljs-built_in">max</span>(sufMax[i + <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> up = <span class="hljs-built_in">min</span>(preMax[i - <span class="hljs-number">1</span>], sufMax[i + <span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> bottom = heights[i];<br>        <span class="hljs-keyword">if</span> (up &gt; bottom) &#123;<br>            ans += up - bottom;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>preMax[]：记录当前位置左侧的最大高度。<br>sufMax[]：记录当前位置右侧的最大高度。<br></code></pre></td></tr></table></figure>



<h1 id="四-单调队列"><a href="#四-单调队列" class="headerlink" title="四.单调队列"></a>四.单调队列</h1><p>我们就希望去维护一个这样的候选,集合里边的元素，它们的值是递减的。所以当I它大于等于k-1时，我已经攒够了。q的值是递减的呀，可能成为一个答案的选项，那么此时就对头最好，我就取对头作为答案。这就是我们要干三件事情。</p>
<p>单调队列维护的是一个候选集合，前面的比较旧，后面的比较新(时间有单调性</p>
<p>候选项的某个属性也具有单调性</p>
<p>确定递增递减的方法–考虑任意两个候选顶j&lt;j2，写出j比优的条件</p>
<p>排除冗余的关键:若j比j差，j的生命周期还比了短，那了 就没卵用了</p>
<p>单调队列题目代码套路:<br>·for 每个元素<br>    (1)while(队头过期)队头出队<br>    (2)取队头为最佳选项，计算答案                                                                                                                                            	(3)while(队尾与新元素不满足单调性)队尾出队                                                                                                                                                                                                                                                        	(3)新元素入队</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="找到滑动窗口最大值"><a href="#找到滑动窗口最大值" class="headerlink" title="找到滑动窗口最大值"></a>找到滑动窗口最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans; <span class="hljs-comment">// 存储结果</span><br>        deque&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 用于维护滑动窗口的双端队列</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 删除过期元素：如果队首元素不在当前窗口范围内，则弹出队首</span><br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">front</span>() &lt;= i - k) &#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// 插入新元素：移除队列中所有小于当前元素的值，以保持递减顺序</span><br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[q.<span class="hljs-built_in">back</span>()] &lt;= nums[i]) &#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// 将当前元素的索引加入到队列中</span><br>            q.<span class="hljs-built_in">push_back</span>(i);<br><br>            <span class="hljs-comment">// 记录当前窗口的最大值：队首元素即为窗口内的最大值</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[q.<span class="hljs-built_in">front</span>()]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h1 id="五-集合和映射"><a href="#五-集合和映射" class="headerlink" title="五. 集合和映射"></a>五. 集合和映射</h1><h3 id="经验-3"><a href="#经验-3" class="headerlink" title="经验"></a>经验</h3><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="找到两数之和"><a href="#找到两数之和" class="headerlink" title="找到两数之和"></a>找到两数之和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; h;  <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 遍历数组 nums</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;                    <br>            <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">find</span>(target-num[i]) != h.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;h[target-num[i]], i&#125;;  <span class="hljs-comment">// 找到两数之和，返回其索引</span><br>            &#125;<br>            <span class="hljs-comment">// 如果不存在，将当前元素和索引存入哈希表</span><br>            h[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果未找到符合条件的数对，返回空数组</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="模拟行走机器人"><a href="#模拟行走机器人" class="headerlink" title="模拟行走机器人"></a>模拟行走机器人</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; commands, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dirs[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 四个方向: 北(0,1), 东(1,0), 南(0,-1), 西(-1,0)</span><br>        <span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">60010</span> + y; &#125;;  <span class="hljs-comment">// 将障碍物位置映射为唯一的值</span><br>        std::unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : obstacles) &#123;<br>            s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">f</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : commands) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-2</span>) &#123;<br>                k = (k + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向左转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-1</span>) &#123;<br>                k = (k + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向右转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (c-- &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> nx = x + dirs[k], ny = y + dirs[k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">f</span>(nx, ny))) &#123;<br>                        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 遇到障碍物</span><br>                    &#125;<br>                    x = nx;<br>                    y = ny;<br>                    ans = std::<span class="hljs-built_in">max</span>(ans, x * x + y * y);  <span class="hljs-comment">// 计算离原点的距离的平方</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(std::vector&lt;std::string&gt;&amp; strs) &#123;<br>        std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; h;  <span class="hljs-comment">// 哈希表，键是排序后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strs) &#123;<br>            std::string key = str;<br>            std::<span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 将字符串排序</span><br>            h[key].<span class="hljs-built_in">push_back</span>(str);  <span class="hljs-comment">// 将原始字符串加入哈希表</span><br>        &#125;<br>        <br>        std::vector&lt;std::vector&lt;std::string&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : h) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(p.second);  <span class="hljs-comment">// 收集结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h1 id="六-前缀和"><a href="#六-前缀和" class="headerlink" title="六.前缀和"></a>六.前缀和</h1><h3 id="前缀，后缀数组的书写："><a href="#前缀，后缀数组的书写：" class="headerlink" title="前缀，后缀数组的书写："></a><strong>前缀，后缀数组的书写</strong>：</h3><ul>
<li>定义：前缀和数组是用于快速计算数组任意区间和的辅助数组。<code>S[i]</code> 表示从数组开头到第 <code>i</code> 个元素的累加和。</li>
<li>公式：<ul>
<li>基本公式：<code>S[i] = S[i-1] + A[i]</code></li>
<li>区间和公式：要计算原数组 <code>A</code> 中 <code>[i, j]</code> 区间的和，可以使用前缀和数组：<code>sum(i, j) = S[j] - S[i-1]</code>  用x,y模拟s[x]-s[y]此时只需要遍历x的位置。</li>
</ul>
</li>
</ul>
<p>[3, 1, 4, 5, 2]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//维护前缀和的写法[3, 4, 8, 13, 15]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>; <br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>    s[i] = s[i<span class="hljs-number">-1</span>] + sums[i<span class="hljs-number">-1</span>]; <br>&#125;<br><br><br><span class="hljs-comment">//preMin写法，从左往右遍历，preMin[] = [3, 1, 1, 1, 1]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preMin</span><span class="hljs-params">(n)</span></span>;<br>preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>]; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    preMin[i] = <span class="hljs-built_in">min</span>(preMin[i<span class="hljs-number">-1</span>], s[i]);   <br>&#125;<br><br><br><span class="hljs-comment">//preMax写法，从左往右遍历，preMax[] = [3, 3, 4, 5, 5]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preMax</span><span class="hljs-params">(n)</span></span>;<br>preMax[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>];  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    preMax[i] = <span class="hljs-built_in">max</span>(preMax[i<span class="hljs-number">-1</span>], s[i]);  <br>&#125;<br><br><span class="hljs-comment">//sufMin 的写法，从右往左遍历，sufMin[] = [1, 1, 2, 2, 2]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sufMin</span><span class="hljs-params">(n)</span></span>;<br>sufMin[n<span class="hljs-number">-1</span>] = s[n<span class="hljs-number">-1</span>]; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    sufMin[i] = <span class="hljs-built_in">min</span>(sufMin[i + <span class="hljs-number">1</span>], s[i]);  <br>&#125;<br><br><span class="hljs-comment">//sufMax 的写法，从右往左遍历，sufMax[] = [5, 5, 5, 5, 2]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sufMax</span><span class="hljs-params">(n)</span></span>;<br>sufMax[n<span class="hljs-number">-1</span>] = s[n<span class="hljs-number">-1</span>];  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    sufMax[i] = <span class="hljs-built_in">max</span>(sufMax[i + <span class="hljs-number">1</span>], s[i]); <br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li><strong>思路</strong>：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。所以只需用一个计数数组或 hash map 维护S中每个值的个数，枚举右端点 i，看一下等于S[i]-k 的值有几个就行了</li>
</ul>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h4 id="优美子数组和问题："><a href="#优美子数组和问题：" class="headerlink" title="优美子数组和问题："></a><strong>优美子数组和问题</strong>：</h4><p>子数组中的奇数个数等于给定的整数 <code>k</code></p>
<ul>
<li><p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;vector&gt;<br>#include &lt;unordered_map&gt;<br><br>using namespace std;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>; <span class="hljs-comment">// 前缀和数组 s(0-n)，初始化为0</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; count; <span class="hljs-comment">// 用于记录前缀和出现的次数</span><br>    count[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始前缀和为0时，计数为1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算前缀和 s[i]，其中 nums[i-1] 是当前元素，nums[i-1] % 2 用于判断奇偶性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>; <span class="hljs-comment">// 前缀和的奇偶性计算</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] - k &gt;= <span class="hljs-number">0</span>) &#123;<br>            ans += count[s[i] - k]; <span class="hljs-comment">// 如果满足条件，累加出现的次数</span><br>        &#125;<br>        count[s[i]]++; <span class="hljs-comment">// 更新当前前缀和出现的次数</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>解析：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。所以只需用一个计数数组或 hash map 维护S中每个值的个数，枚举右端点 i，看一下等于S[i]-k 的值有几个就行了</p>
</li>
</ul>
<h4 id="最大子数组和问题（Max-Subarray-Sum-Problem）："><a href="#最大子数组和问题（Max-Subarray-Sum-Problem）：" class="headerlink" title="最大子数组和问题（Max Subarray Sum Problem）："></a><strong>最大子数组和问题（Max Subarray Sum Problem）</strong>：</h4><ul>
<li><p>问题描述：给定一个整数数组，要求找到其最大子数组的和。子数组的定义是数组中连续的一部分元素。</p>
</li>
<li><p><strong>思路</strong>：</p>
<ul>
<li>可以通过前缀和的方式来求解最大子数组和问题。</li>
<li>同时我们需要一个 <code>preMin</code> 数组来记录当前子数组的前缀和中的最小值，以便在当前区间进行减法操作时，获得可能的最大子数组和。</li>
</ul>
</li>
</ul>
<h4 id="实现代码（最大子数组和问题）："><a href="#实现代码（最大子数组和问题）：" class="headerlink" title="实现代码（最大子数组和问题）："></a><strong>实现代码（最大子数组和问题）</strong>：</h4><ul>
<li><strong>代码</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-type">int</span>[] preMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀最小值数组</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算前缀和</span><br>    &#125;<br>    preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>]; <span class="hljs-comment">//preMin书写模版</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        preMin[i] = Math.min(preMin[i-<span class="hljs-number">1</span>], s[i]); <span class="hljs-comment">// 维护前缀最小值</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>; <span class="hljs-comment">// 初始化答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = Math.max(ans, s[i] - preMin[i-<span class="hljs-number">1</span>]); <span class="hljs-comment">// 计算最大子数组和 从一开始</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>解析</strong>：<ul>
<li>前缀和数组 <code>s[i]</code> 存储的是从数组开头到第 <code>i</code> 个元素的累加和。</li>
<li><code>preMin[i]</code> 数组存储的是从开头到第 <code>i</code> 个元素的前缀和中的最小值。</li>
<li>每次在计算 <code>s[i]</code> 时，通过减去当前区间的最小前缀和 <code>preMin[i-1]</code>，就可以得到从某个区间到 <code>i</code> 的最大子数组和。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>额外注释和细节</strong>：</li>
</ol>
<ul>
<li>在 <strong>子数组和问题</strong> 中，哈希表 <code>count</code> 的作用非常关键，它可以快速定位前缀和的差值是否已经出现过，并通过查找差值来确定是否存在满足条件的子数组。</li>
<li><strong>前缀和法的核心</strong>：将原始问题中的区间和转换为前缀和的差值问题，进而简化计算，达到提高效率的目的。</li>
<li>在 <strong>最大子数组和问题</strong> 中，通过维护一个 <code>preMin</code> 数组来保存当前子数组的最小前缀和，从而可以通过差值来计算最大和。</li>
<li>代码中的 <code>Math.min</code> 和 <code>Math.max</code> 是用于动态更新当前最优的结果。</li>
<li>详细讲解了如何通过前缀和数组快速计算区间和。</li>
<li>针对不同问题，给出了具体的代码实现并且逐步进行了分析。</li>
<li>重点强调了利用 <code>HashMap</code>（哈希表） 来高效存储和查找前缀和，以及如何动态维护前缀和中的最小值。：</li>
</ul>
<h3 id="一维前缀和及其应用："><a href="#一维前缀和及其应用：" class="headerlink" title="一维前缀和及其应用："></a>一维前缀和及其应用：</h3><ul>
<li>在前面的笔记中，我们介绍了<strong>一维前缀和</strong>的概念以及如何利用前缀和来快速解决区间和问题，特别是对于子数组和等于某个目标值的计数问题，我们使用了前缀和和哈希表结合的方法进行高效解答。此外，<strong>最大子数组和问题</strong>通过前缀和与最小前缀和的差值计算得出答案。</li>
</ul>
<h3 id="二维前缀和（2D-Prefix-Sum）："><a href="#二维前缀和（2D-Prefix-Sum）：" class="headerlink" title="二维前缀和（2D Prefix Sum）："></a>二维前缀和（2D Prefix Sum）：</h3><ul>
<li><p>在本部分的笔记中，前缀和的概念被推广到了二维情况。二维前缀和 <code>S[i][j]</code> 表示的是从矩阵左上角 <code>(1, 1)</code> 到当前坐标 <code>(i, j)</code> 的所有元素的累加和，这一概念让我们能够快速计算任意矩形区域内的元素和。</p>
</li>
<li><p>类似于一维前缀和的区间和公式，二维前缀和的矩形区域和通过前缀和数组快速求解，避免了重复计算。计算区域 <code>(p, q)</code> 到 <code>(i, j)</code> 的矩形区域和的公式为：</p>
<ul>
<li><code>sum(p, q, i, j) = S[i][j] - S[i][q-1] - S[p-1][j] + S[p-1][q-1]</code></li>
</ul>
</li>
<li><p>这种方式不仅能快速处理问题，还能提升算法的时间复杂度，尤其适合处理较大规模的矩阵求和问题。</p>
</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs inform7">二维区域的和<br>public NumMatrix(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> matrix) &#123;<br>    int n = matrix.length;<br>    int m = matrix<span class="hljs-comment">[0]</span>.length;<br>    sum = new int<span class="hljs-comment">[n + 1]</span><span class="hljs-comment">[m + 1]</span>;<br><br>    for (int i = 1; i &lt;= n; i++) &#123;<br>        for (int j = 1; j &lt;= m; j++) &#123;<br>            sum<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = sum<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + sum<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span> - sum<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> + matrix<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>public int sumRegion(int row1, int col1, int row2, int col2) &#123;<br>    row1 += 1;<br>    col1 += 1;<br>    row2 += 1;<br>    col2 += 1;<br><br>    return sum<span class="hljs-comment">[row2]</span><span class="hljs-comment">[col2]</span> - sum<span class="hljs-comment">[row1 - 1]</span><span class="hljs-comment">[col2]</span> - sum<span class="hljs-comment">[row2]</span><span class="hljs-comment">[col1 - 1]</span> + sum<span class="hljs-comment">[row1 - 1]</span><span class="hljs-comment">[col1 - 1]</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="差分数组及其应用："><a href="#差分数组及其应用：" class="headerlink" title="差分数组及其应用："></a>差分数组及其应用：</h3><p>总结：把 A的第!个数到第r个数加 d，B 的变化为:B;加 d，B,+ 减d，它比较适用于我们想把一段儿-个子段都加一个值的时候。比如我们想把a的dl到底I个数啊啊|到r这个字段都加一个数d。</p>
<ul>
<li><p><strong>差分数组</strong>的引入则为高效区间更新提供了一种新的方法。在解决大规模区间更新问题时，如果直接对原数组进行操作，时间复杂度会比较高，而差分数组通过记录相邻元素之间的差值，在常数时间内更新区间，最后通过前缀和恢复原数组。</p>
</li>
<li><p>例如，在航班预定问题中，差分数组 <code>id</code> 被用来记录每个区间的变化量，最终通过前缀和恢复预定后的航班乘客数量。</p>
</li>
<li><p>差分数组的本质是通过对局部变化的记录和累积，使得区间更新可以在 O(1) 时间内完成，极大优化了需要频繁进行更新操作的场景。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">宇航票预定<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">book</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bookings, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; booking : bookings) &#123;<br>            <span class="hljs-type">int</span> a = booking[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> b = booking[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> c = booking[<span class="hljs-number">2</span>];<br>            id[a] += c;<br>            id[b + <span class="hljs-number">1</span>] -= c;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + id[i];<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            answer[i - <span class="hljs-number">1</span>] = sum[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="综合总结："><a href="#综合总结：" class="headerlink" title="综合总结："></a>综合总结：</h3><ol>
<li><strong>一维前缀和</strong>解决了基本的区间和问题，同时通过哈希表等技巧，可以处理子数组和计数等高级问题。</li>
<li><strong>二维前缀和</strong>将这一思想推广到矩阵，能够快速求解矩形区域和问题，极大提高了处理二维数据的效率。</li>
<li><strong>差分数组</strong>则提供了高效的区间更新方法，特别适合于需要多次区间操作的场景，在减少时间复杂度方面有显著优势。</li>
</ol>
<hr>
<h1 id="七-双指针"><a href="#七-双指针" class="headerlink" title="七.双指针"></a>七.双指针</h1><h3 id="双指针算法的核心思想："><a href="#双指针算法的核心思想：" class="headerlink" title="双指针算法的核心思想："></a><strong>双指针算法的核心思想</strong>：</h3><ul>
<li><p><strong>定义</strong>：双指针法是通过两个指针从不同方向（常见的是一头一尾）同时进行遍历，进而达到降低时间复杂度的目的。这种方法尤其适合在有序数组或特定问题中使用，通过一左一右或一前一后两个指针逼近来找到符合条件的解。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ol>
<li><strong>有序数组的查找问题</strong>：在一个排序好的数组中，利用双指针可以快速确定满足条件的两个或多个元素，典型的例子是“两数之和”。</li>
<li><strong>区间内查找问题</strong>：通过双指针从区间两端逐渐缩小范围，避免重复遍历。比如“盛水最多的容器问题”。</li>
<li><strong>多元素组合问题</strong>：像“三数之和”问题，通过固定一个数，再使用双指针寻找另外两个数的组合。</li>
</ol>
</li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><h4 id="两数之和问题："><a href="#两数之和问题：" class="headerlink" title="两数之和问题："></a><strong>两数之和问题</strong>：</h4><p><strong>题目描述</strong>：</p>
<p>给定一个有序数组，找到两个数，使得它们的和等于目标值 <code>target</code>。返回这两个数的下标，假定数组内没有重复解。</p>
<p><strong>思路分析</strong>：</p>
<ul>
<li>因为数组已经排序，直接使用双指针从头和尾同时进行遍历：<ul>
<li>如果左右两指针的元素之和 <code>numbers[i] + numbers[j]</code> 等于目标值，则返回结果。</li>
<li>如果和小于目标值，则左指针右移增加和；</li>
<li>如果和大于目标值，则右指针左移减小和。</li>
</ul>
</li>
<li>该方法的时间复杂度是 O(n)，相比于暴力枚举的 O(n²) 更加高效。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入有序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 两个指针从数组两端开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; numbers[i]+numbers[j]&gt;target)	j--;<br>        <span class="hljs-keyword">if</span> (i&lt;j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>            reture &#123;i<span class="hljs-number">+1</span>,j<span class="hljs-number">+1</span>&#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;<br><br>输入无序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; pairs;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        pairs.<span class="hljs-built_in">push</span>(&#123;num[i],i&#125;);  <br>    &#125;<br>    <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(),pairs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> j = pairs.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;pairs.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first&gt;target)	j--;<br>        <span class="hljs-keyword">if</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first==target)&#123;<br>            <span class="hljs-keyword">return</span> &#123;pairs[i],second , pairs[j].second&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;  <br></code></pre></td></tr></table></figure>

<p><strong>细节与优化</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：排序数组直接使用双指针只需遍历一次，时间复杂度为 O(n)，非常高效。</li>
<li><strong>边界条件</strong>：确保 <code>i &lt; j</code>，即两个指针不能重叠，避免重复或错误的索引访问。</li>
</ul>
<hr>
<h4 id="三数之和问题："><a href="#三数之和问题：" class="headerlink" title="三数之和问题："></a><strong>三数之和问题</strong>：</h4><p><strong>题目描述</strong>：</p>
<p>给定一个数组 <code>nums</code>，找出其中的三个数，使得它们的和为 0。可以假设数组中没有重复解。</p>
<p><strong>思路分析</strong>：</p>
<ul>
<li><p><strong>固定一个数，求剩下两数之和</strong>：</p>
<ol>
<li>先对数组进行排序，便于使用双指针法。</li>
<li>从第一个元素开始，依次固定一个数 <code>nums[i]</code>，接着利用双指针在剩下的数组部分中寻找两数之和为 <code>-nums[i]</code> 的数对。</li>
<li>为了避免重复解，固定的数和双指针处理时需要跳过相同的元素。</li>
</ol>
</li>
<li><p><strong>详细步骤</strong>：</p>
<ol>
<li>排序数组。</li>
<li>遍历数组中的每一个元素，固定 <code>nums[i]</code>。</li>
<li>在 <code>i</code> 之后的元素中用双指针寻找和为 <code>-nums[i]</code> 的数对。</li>
<li>如果找到满足条件的数对，记录下来，继续遍历时跳过重复元素。</li>
</ol>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; jks = <span class="hljs-built_in">twoSum</span>(nums, i + <span class="hljs-number">1</span>, -nums[i]);<br>            <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; jk : jks) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], jk[<span class="hljs-number">0</span>], jk[<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--;<br>            <span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;numbers[i], numbers[j]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>优化与细节</strong>：</p>
<ul>
<li><strong>去重处理</strong>：为了避免重复解，固定数和双指针都需要跳过重复的元素。例如，固定数 <code>nums[i]</code> 相同的情况不再处理，双指针的 <code>nums[j]</code> 和 <code>nums[k]</code> 也需要处理重复的情况。</li>
<li><strong>时间复杂度</strong>：排序时间复杂度为 O(nlogn)，之后遍历和双指针查找的时间复杂度是 O(n²)，总体复杂度为 O(n²)。</li>
</ul>
<hr>
<h4 id="盛水最多的容器问题："><a href="#盛水最多的容器问题：" class="headerlink" title="盛水最多的容器问题："></a><strong>盛水最多的容器问题</strong>：</h4><p><strong>题目描述</strong>：</p>
<p>给定一个数组 <code>height</code>，其中每个元素代表容器壁的高度，找到两个容器壁，使得它们与 X 轴构成的容器能盛最多的水。</p>
<p><strong>思路分析</strong>：</p>
<ul>
<li><strong>双指针法</strong>：<ol>
<li>通过两个指针分别指向数组的最左和最右位置。</li>
<li>每次计算两根柱子之间的容积：<code>min(height[i], height[j]) * (j - i)</code>。</li>
<li>为了使盛水的容量最大，移动较短的一端指针，试图找到更高的柱子，从而获得更大的面积。</li>
</ol>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>        <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) i++;<br>        <span class="hljs-keyword">else</span> j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>优化与细节</strong>：</p>
<ul>
<li><strong>双指针法的精髓</strong>：通过移动较短的一端，不断调整容器两壁的位置，试图找到盛水的最大面积。</li>
<li><strong>时间复杂度</strong>：由于只需遍历一次，时间复杂度为 O(n)，是一种高效的解法。</li>
</ul>
<p><strong>双指针的本质</strong>：</p>
<ul>
<li>双指针的核心思想是通过对称的方式从两端或从不同方向移动，能够在保持线性时间复杂度的同时解决较为复杂的问题，如查找和、最优解等。</li>
<li>无论是“两数之和”、“三数之和”还是“盛水最多的容器”，都通过双指针在适当的场景下提高效率，避免了暴力解法的高时间复杂度。</li>
</ul>
<p><strong>关键细节总结</strong>：</p>
<ul>
<li>在处理“两数之和”和“三数之和”问题时，注意通过排序和去重来简化问题，避免重复计算和解的重复。</li>
<li>对于“盛水最多的容器”问题，利用双指针的对称移动特性，可以在 O(n) 时间内获得最优解。</li>
</ul>
<hr>
<h3 id="比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况"><a href="#比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况" class="headerlink" title="比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况"></a>比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况</h3><ol>
<li>前缀和（Prefix Sum）<br>适用情况：<br>快速计算数组某个子区间的和：适用于需要多次计算数组某个区间和的场景。<br>区间查询和更新较少：适合静态数组或查询操作远多于更新操作的情况。</li>
<li>差分（Difference Array）<br>适用情况：<br>快速进行区间修改：适用于需要频繁对数组某个区间进行加减操作的场景。<br>需要高效进行批量更新：适合大规模区间更新操作。</li>
<li>双指针（Two Pointers）<br>适用情况：<br>处理有序数组：适用于需要在有序数组或链表中查找、遍历等操作。<br>解决滑动窗口问题：适合在数组或字符串上维护动态区间的问题。</li>
<li>滑动窗口（Sliding Window）<br>适用情况：<br>子数组问题：适用于需要找到数组中满足特定条件的子数组或子字符串的问题。<br>连续子区间：适合处理需要计算连续子区间的问题。</li>
<li>单调栈（Monotonic Stack）<br>适用情况：<br>找到数组中每个元素的下一个更大（或更小）元素：适用于需要在数组中找到特定方向上的极值问题。<br>维护区间单调性：适合处理需要保持区间单调性的问题。</li>
</ol>
<hr>
<h1 id="八-递归"><a href="#八-递归" class="headerlink" title="八.递归"></a>八.递归</h1><h3 id="回溯法的核心思想："><a href="#回溯法的核心思想：" class="headerlink" title="回溯法的核心思想："></a>回溯法的核心思想：</h3><ul>
<li><strong>定义</strong>：回溯0法是一种通过递归逐步生成解空间，遇到不满足条件时及时回溯到上一个状态的算法，通常用于解决排列组合、子集、路径等问题。</li>
</ul>
<p>f（x）{                                                                                                                                                                	int x;      &#x2F;&#x2F;这里是局部变量，还会再开一次int x。所以就是由每个f各自都有一	f(n-1) 		份儿  ，所以这些就是如果说非局部的变量。  你不能说某一次f把						它改了之后算别的f的时候诶, 它们需要注意保护跟还原这                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }</p>
<ul>
<li><strong>基本框架</strong>：<ul>
<li>注意语意,即这个函数解决的问题,这些代码在当前进程的操作,调用函数相当于开了一个新进程（树）,数学上就像数列f（x），每一个小块即fx都要做什么</li>
<li>定义递归的边界</li>
<li>保护还原现场</li>
</ul>
</li>
</ul>
<h3 id="三个模版"><a href="#三个模版" class="headerlink" title="三个模版"></a>三个模版</h3><h4 id="子集问题（Subsets）："><a href="#子集问题（Subsets）：" class="headerlink" title="子集问题（Subsets）："></a><strong>子集问题（Subsets）</strong>：</h4><p>给定一个数组 <code>nums</code>，要求生成所有的子集。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li><strong>递归生成子集</strong>：<ul>
<li>每次递归选择是否将当前元素加入子集。</li>
<li>遍历整个数组，生成所有可能的子集。</li>
</ul>
</li>
<li><strong>回溯的实现</strong>：<ul>
<li>使用一个 <code>chosen</code> 数组保存当前已经选择的元素，递归时选择是否添加当前元素，完成后回溯（撤销选择）。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">recur</span>(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == n) &#123; <span class="hljs-comment">// 递归终止条件</span><br>            ans.<span class="hljs-built_in">push_back</span>(chosen);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归不选当前元素</span><br>        <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归选择当前元素</span><br>        chosen.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择，还原现场，这里的chosen属于非局部变量</span><br>        chosen.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>回溯过程</strong>：递归的过程中不断选择是否包含当前元素，形成子集。每当一个选择完成后，回溯撤销上一步的选择，继续探索下一个可能的解。</li>
<li><strong>时间复杂度</strong>：O(2^n)，每个元素都有两种选择（选择或不选择）。</li>
</ul>
<hr>
<h4 id="组合问题（Combinations）："><a href="#组合问题（Combinations）：" class="headerlink" title="组合问题（Combinations）："></a>组合问题（Combinations）：</h4><p>给定整数 <code>n</code> 和 <code>k</code>，从 <code>[1, 2, ..., n]</code> 中选择 <code>k</code> 个数的所有组合。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li><strong>递归生成组合</strong>：<ul>
<li>遍历 <code>[1, n]</code> 中的每一个数，每次递归选择或不选择该数，直到选满 <code>k</code> 个数。</li>
<li>剪枝优化：当剩下的元素数量不足以填满 <code>k</code> 个数时可以提前结束递归。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n; <span class="hljs-comment">//将函数参数 n 的值赋给类的成员变量 n</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-built_in">recur</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-comment">// 剪枝条件</span><br>        <span class="hljs-keyword">if</span> (chosen.<span class="hljs-built_in">size</span>() + (n - i + <span class="hljs-number">1</span>) &lt; k) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (i == n + <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(chosen);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不选当前元素</span><br>        <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 选择当前元素</span><br>        chosen.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        chosen.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> n, k;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>递归选择与回溯</strong>：从 <code>1</code> 到 <code>n</code> 的数中逐个选择，直到选满 <code>k</code> 个数，每次选择完后回溯撤销选择。</li>
<li><strong>剪枝优化</strong>：当剩余数不足 <code>k - chosen.size()</code> 时，直接结束递归，避免无效操作。</li>
<li><strong>时间复杂度</strong>：O(C(n, k))，组合数的复杂度。</li>
</ul>
<hr>
<h4 id="全排列问题（Permutations）："><a href="#全排列问题（Permutations）：" class="headerlink" title="全排列问题（Permutations）："></a><strong>全排列问题（Permutations）</strong>：</h4><p>给定一个不包含重复数字的数组 <code>nums</code>，要求生成所有可能的全排列。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li><strong>递归生成全排列</strong>：<ul>
<li>每次递归选择一个尚未使用的数，直到所有数都被选过。</li>
<li>使用一个布尔数组 <code>used</code> 来标记哪些数已经被使用，防止重复使用。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    used = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; (n,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">recur</span>(nums,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">private</span>：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos == n) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(a);  <span class="hljs-comment">// 找到一个排列</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!used[i]) &#123;        <span class="hljs-comment">//过滤used用过的</span><br>            a.<span class="hljs-built_in">push_back</span>(num[i]);<br>            used[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为使用</span><br>            <span class="hljs-built_in">recur</span>(nums, pos + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 递归下一层</span><br>            used[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记为未使用</span><br>            a.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    <span class="hljs-type">int</span> n;<br>    vector &lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>回溯与排列</strong>：每次递归选择一个未使用的数，直到所有数都被选过，形成一个排列。回溯时撤销选择并将数标记为未使用。</li>
<li><strong>时间复杂度</strong>：O(n!)，全排列的复杂度，每次递归需要遍历未使用的元素。</li>
</ul>
<p>以上三个问题都是递归实现的“暴力搜索”(或者叫枚举、回溯等)可以总结为以下三种基本形式<br>递归形式<br>指数型	排列型	组合型<br>时间复杂度规模:kn	n!	n!&#x2F;m!(n-m)!<br>子集、大体积背包	全排列、旅行商、N 皇后找顺序的题目	组合选数</p>
<hr>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="反转二叉树（Invert-Binary-Tree）："><a href="#反转二叉树（Invert-Binary-Tree）：" class="headerlink" title="反转二叉树（Invert Binary Tree）："></a><strong>反转二叉树（Invert Binary Tree）</strong>：</h4><p>该问题要求对一个二叉树进行左右子树的交换。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li><strong>递归反转左右子树</strong>：<ul>
<li>对当前节点的左右子树递归交换。</li>
<li>递归终止条件是当前节点为空。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 空节点返回</span><br>    TreeNode* temp = root-&gt;left;  <span class="hljs-comment">// 交换左右子树</span><br>    root-&gt;left = root-&gt;right;<br>    root-&gt;right = temp;<br>    <span class="hljs-built_in">invertTree</span>(root-&gt;left);  <span class="hljs-comment">// 递归反转左子树</span><br>    <span class="hljs-built_in">invertTree</span>(root-&gt;right);  <span class="hljs-comment">// 递归反转右子树</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>递归反转过程</strong>：从根节点开始，对每个节点的左右子树进行交换，并递归处理子树。</li>
<li><strong>时间复杂度</strong>：O(n)，每个节点遍历一次。</li>
</ul>
<p><strong>6. 总结</strong>：</p>
<ul>
<li><strong>回溯法</strong>是一种经典的递归算法，适用于组合、排列、子集等问题。其核心思想是在递归过程中通过试探的方式逐步生成解，遇到不满足条件的解时回溯到上一步重新尝试。</li>
<li><strong>子集与组合</strong>：通过回溯生成所有可能的子集或组合，并在递归过程中进行剪枝优化。</li>
<li><strong>全排列</strong>：回溯法生成全排列时，需要通过标记已使用的元素来避免重复使用元素。</li>
<li><strong>二叉树的递归操作</strong>：类似反转二叉树等问题可以通过递归方式简化操作，每次递归处理左右子树即可。</li>
</ul>
<h4 id="翻转一棵二叉树"><a href="#翻转一棵二叉树" class="headerlink" title="翻转一棵二叉树"></a>翻转一棵二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义二叉树节点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br><br>    <span class="hljs-comment">// 构造函数：初始化节点</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 翻转二叉树的递归函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 基础条件：节点为空时直接返回</span><br><br>        <span class="hljs-comment">// 交换左右子树</span><br>        TreeNode* temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br><br>        <span class="hljs-comment">// 递归处理左右子树</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> root;  <span class="hljs-comment">// 返回翻转后的根节点</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 辅助函数：先序遍历输出二叉树的节点值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 构造测试用的二叉树</span><br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">4</span>);<br>    root-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">2</span>);<br>    root-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">7</span>);<br>    root-&gt;left-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">1</span>);<br>    root-&gt;left-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">3</span>);<br>    root-&gt;right-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">6</span>);<br>    root-&gt;right-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">9</span>);<br><br>    <span class="hljs-comment">// 输出翻转前的二叉树</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;翻转前的二叉树（先序遍历）：&quot;</span>;<br>    <span class="hljs-built_in">preOrder</span>(root);<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 翻转二叉树</span><br>    <span class="hljs-built_in">Solution</span>().<span class="hljs-built_in">invertTree</span>(root);<br><br>    <span class="hljs-comment">// 输出翻转后的二叉树</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;翻转后的二叉树（先序遍历）：&quot;</span>;<br>    <span class="hljs-built_in">preOrder</span>(root);<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义二叉树节点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 判断是否为有效二叉搜索树的递归函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root, <br>                     numeric_limits&lt;<span class="hljs-type">long</span>&gt;::<span class="hljs-built_in">min</span>(), <br>                     numeric_limits&lt;<span class="hljs-type">long</span>&gt;::<span class="hljs-built_in">max</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 辅助递归函数，判断节点值是否在合法范围内</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> rangeLeft, <span class="hljs-type">long</span> rangeRight)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 空节点返回true</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt;= rangeLeft || root-&gt;val &gt;= rangeRight) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 不满足范围条件返回false</span><br><br>        <span class="hljs-comment">// 递归检查左子树和右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root-&gt;left, rangeLeft, root-&gt;val) &amp;&amp;<br>               <span class="hljs-built_in">check</span>(root-&gt;right, root-&gt;val, rangeRight);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 构造测试用的二叉树</span><br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">2</span>);<br>    root-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">1</span>);<br>    root-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">3</span>);<br><br>    Solution solution;<br>    cout &lt;&lt; (solution.<span class="hljs-built_in">isValidBST</span>(root) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>) &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 构造错误的二叉树</span><br>    TreeNode* root2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">5</span>);<br>    root2-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">1</span>);<br>    root2-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">4</span>);<br>    root2-&gt;right-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">3</span>);<br>    root2-&gt;right-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">6</span>);<br><br>    cout &lt;&lt; (solution.<span class="hljs-built_in">isValidBST</span>(root2) ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>思路一 (自底向上统计信息，分治思想) 最大深度 &#x3D;max(左子树最大深度，右子树最大深度)+1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 递归计算二叉树的最大深度</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果节点为空，深度为0</span><br>        <span class="hljs-comment">// 递归计算左右子树的深度，并返回较大的深度加1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>思路二(自顶向下维护信息)<br>把“深度”作为一个全局变量–一个跟随结点移动而动态变化的信息递归一层，变量+1，在叶子处更新答案这种写法需要注意保护和还原现场</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() : <span class="hljs-built_in">depth</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">ans</span>(<span class="hljs-number">0</span>) &#123;&#125;  <span class="hljs-comment">// 构造函数初始化</span><br>    <span class="hljs-comment">// 计算二叉树最大深度的主函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">calc</span>(root);  <span class="hljs-comment">// 调用递归函数</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> depth;  <span class="hljs-comment">// 当前递归深度</span><br>    <span class="hljs-type">int</span> ans;    <span class="hljs-comment">// 存储最大深度</span><br><br>    <span class="hljs-comment">// 递归计算深度的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 空节点返回</span><br>        <span class="hljs-comment">// 更新最大深度</span><br>        ans = <span class="hljs-built_in">max</span>(ans, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 深度增加，递归遍历左子树和右子树</span><br>        depth++;<br>        <span class="hljs-built_in">calc</span>(root-&gt;left);<br>        <span class="hljs-built_in">calc</span>(root-&gt;right);<br>        <span class="hljs-comment">// 回溯时减少深度</span><br>        depth--;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>本层逻辑，我们把它明确好，至于左右怎么干,就是一个递归的问题了，就不用去想这么多。</p>
<hr>
<h1 id="九-分治"><a href="#九-分治" class="headerlink" title="九.分治"></a>九.分治</h1><h3 id="分治算法（Divide-and-Conquer）："><a href="#分治算法（Divide-and-Conquer）：" class="headerlink" title="分治算法（Divide and Conquer）："></a><strong>分治算法（Divide and Conquer）</strong>：</h3><ul>
<li><strong>定义</strong>：将原问题划分为若干个相同或相似的子问题，递归求解子问题，然后将各个子问题的解合并成原问题的解。</li>
<li><strong>应用场景</strong>：分治法常用于大规模问题的解决，比如快速排序、归并排序、矩阵乘法等。</li>
<li><strong>要点</strong>：<ul>
<li>将问题分成若干子问题；</li>
<li>合并子问题的解得到最终解。</li>
</ul>
</li>
<li>简单来说就是不重不漏，重复算过的,不要去给它再去运算一遍，我们可以记忆化，想记忆我们开一个map</li>
</ul>
<hr>
<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="递归实现-pow-x-n-问题："><a href="#递归实现-pow-x-n-问题：" class="headerlink" title="递归实现 pow(x, n) 问题："></a><strong>递归实现 <code>pow(x, n)</code> 问题</strong>：</h4><p>计算 <code>x</code> 的 <code>n</code> 次方。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li><strong>递归公式</strong>：<ul>
<li>如果 <code>n</code> 为偶数，<code>pow(x, n) = pow(x, n / 2) * pow(x, n / 2)</code>。</li>
<li>如果 <code>n</code> 为奇数，<code>pow(x, n) = pow(x, (n - 1) / 2) * pow(x, (n - 1) / 2) * x</code>。</li>
<li>如果 <code>n</code> 为负数，则 <code>pow(x, n) = 1 / pow(x, -n)</code>。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 任何数的 0 次方都等于 1</span><br>    <span class="hljs-keyword">if</span> (n == INT_MIN) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">myPow</span>(x, -(n<span class="hljs-number">+1</span>)) * x);  <span class="hljs-comment">// 处理 n 为最小负数的特殊情况</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-built_in">myPow</span>(x, -n);  <span class="hljs-comment">// 负数次幂</span><br>    <span class="hljs-type">double</span> temp = <span class="hljs-built_in">myPow</span>(x, n / <span class="hljs-number">2</span>);  <span class="hljs-comment">// 递归计算</span><br>    <span class="hljs-type">double</span> ans = temp * temp;  <span class="hljs-comment">// 平方</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ans *= x;  <span class="hljs-comment">// 处理奇数次幂</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(log n)，递归每次将 <code>n</code> 减半。</li>
<li><strong>空间复杂度</strong>：O(log n)，递归调用栈的深度。</li>
</ul>
<hr>
<h4 id="括号生成问题（Generate-Parentheses）："><a href="#括号生成问题（Generate-Parentheses）：" class="headerlink" title="括号生成问题（Generate Parentheses）："></a><strong>括号生成问题（Generate Parentheses）</strong>：</h4><p>给定整数 <code>n</code>，生成所有可能的包含 <code>n</code> 对括号的有效组合。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li>使用递归生成所有括号组合，依次生成 <code>k</code> 对括号与 <code>n-k</code> 对括号的组合，再将它们合并。</li>
<li><strong>递归优化</strong>：通过 <code>unordered_map</code> 缓存中间结果，避免重复计算（记忆化搜索）。</li>
<li>设生成的括号组合可以看作 <code>S = (A)B</code>其中 <code>A</code> 是在 <code>k-1</code> 对括号的基础上生成的组合，<code>B</code> 是在 <code>n-k</code> 对括号的基础上生成的组合。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;  <span class="hljs-comment">// 基本情况，n=0时返回空字符串</span><br>    <span class="hljs-keyword">if</span> (store.<span class="hljs-built_in">find</span>(n) != store.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> store[n];  <span class="hljs-comment">// 如果已经计算过，直接返回缓存的结果</span><br>    <br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;  <span class="hljs-comment">// 遍历所有可能的 k 值(A)B</span><br>        vector&lt;string&gt; A = <span class="hljs-built_in">generateParenthesis</span>(k - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 生成 k-1 对括号</span><br>        vector&lt;string&gt; B = <span class="hljs-built_in">generateParenthesis</span>(n - k);  <span class="hljs-comment">// 生成 n-k 对括号</span><br>        <span class="hljs-keyword">for</span> (string&amp; a : A) &#123;<br>            <span class="hljs-keyword">for</span> (string&amp; b : B) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;(&quot;</span> + a + <span class="hljs-string">&quot;)&quot;</span> + b);  <span class="hljs-comment">// 将两部分组合</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    store[n] = ans;  <span class="hljs-comment">// 缓存当前 n 对括号的所有组合</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;string&gt;&gt; store;  <span class="hljs-comment">// 用于记忆化搜索，避免重复计算</span><br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>记忆化搜索</strong>：通过 <code>unordered_map</code> 缓存递归中间结果，避免重复计算，提升效率。</li>
<li><strong>时间复杂度</strong>：理论上为 O(4^n &#x2F; sqrt(n))，因为每次递归生成所有可能的括号组合。</li>
</ul>
<hr>
<p><strong>4. 总结</strong>：</p>
<ul>
<li><strong>分治法</strong>是一种强大的算法思想，适用于将大问题分解为小问题的场景，通过递归求解小问题来解决大问题。</li>
<li><strong>递归优化</strong>：在实现递归算法时，可以通过<strong>记忆化搜索</strong>等方式来优化重复计算问题，大大提升算法的效率。</li>
<li><strong>递归框架</strong>：很多复杂问题都可以通过递归分解为子问题来解决，比如 <code>pow</code> 问题通过递归将指数减半、括号生成问题通过递归生成不同数量括号的组合等。</li>
</ul>
<hr>
<h1 id="十-二叉树"><a href="#十-二叉树" class="headerlink" title="十.二叉树"></a>十.二叉树</h1><h3 id="二叉树的定义和遍历方式："><a href="#二叉树的定义和遍历方式：" class="headerlink" title="二叉树的定义和遍历方式："></a>二叉树的定义和遍历方式：</h3><ul>
<li>二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。</li>
<li><strong>遍历方式</strong>：<ul>
<li><strong>前序遍历</strong>（Pre-order Traversal）：按根节点 -&gt; 左子树 -&gt; 右子树的顺序遍历。</li>
<li><strong>中序遍历</strong>（In-order Traversal）：按左子树 -&gt; 根节点 -&gt; 右子树的顺序遍历。</li>
<li><strong>后序遍历</strong>（Post-order Traversal）：按左子树 -&gt; 右子树 -&gt; 根节点的顺序遍历。</li>
<li><strong>层次遍历</strong>（Level-order Traversal）：按层从上到下、从左到右的顺序遍历树节点。</li>
</ul>
</li>
</ul>
<h4 id="遍历方式总结："><a href="#遍历方式总结：" class="headerlink" title="遍历方式总结："></a><strong>遍历方式总结</strong>：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 二叉树节点定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 前序遍历 (根-左-右)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preorder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 中序遍历 (左-根-右)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 后序遍历 (左-右-根)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postorder</span>(root-&gt;right);<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 层序遍历 (广度优先遍历)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h4 id="根据前序遍历和中序遍历重建二叉树："><a href="#根据前序遍历和中序遍历重建二叉树：" class="headerlink" title="根据前序遍历和中序遍历重建二叉树："></a><strong>根据前序遍历和中序遍历重建二叉树</strong>：</h4><p><strong>问题描述</strong>：</p>
<p>给定二叉树的前序遍历和中序遍历，重建这棵二叉树。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li>前序遍历的第一个节点是根节点。</li>
<li>在中序遍历中找到根节点的位置，根节点左边的部分是左子树，右边的部分是右子树。</li>
<li>递归构建左子树和右子树。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; preorder;<br>    vector&lt;<span class="hljs-type">int</span>&gt; inorder;<br><br>    <span class="hljs-comment">// 主函数：传入前序和中序遍历数组，开始构建二叉树</span><br>    TreeNode* buildTree(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder) &#123;<br>        <span class="hljs-built_in">this</span>-&gt;preorder = preorder;<br>        <span class="hljs-built_in">this</span>-&gt;inorder = inorder;<br>        <span class="hljs-keyword">return</span> build(<span class="hljs-number">0</span>, preorder.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 递归构建二叉树</span><br>    TreeNode* build(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2) &#123;<br>        <span class="hljs-keyword">if</span> (l1 &gt; r1) <span class="hljs-keyword">return</span> nullptr; <span class="hljs-comment">// 递归结束条件</span><br><br>        <span class="hljs-comment">// 构建当前子树的根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[l1]);<br><br>        <span class="hljs-comment">// 在中序遍历中找到根节点的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l2;<br>        <span class="hljs-keyword">while</span> (inorder[mid] != root-&gt;val) ++mid;<br><br>        <span class="hljs-comment">// 计算左子树的长度，并递归构建左右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftTreeSize</span> <span class="hljs-operator">=</span> mid - l2;<br>        root-&gt;left = build(l1 + <span class="hljs-number">1</span>, l1 + leftTreeSize, l2, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = build(l1 + leftTreeSize + <span class="hljs-number">1</span>, r1, mid + <span class="hljs-number">1</span>, r2);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>分析</strong>：<ul>
<li>前序遍历的第一个元素是当前子树的根节点。</li>
<li>在中序遍历中找到根节点，划分出左子树和右子树。</li>
<li>递归地对左右子树进行同样的处理。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h4 id="找到两个节点的最近公共祖先："><a href="#找到两个节点的最近公共祖先：" class="headerlink" title="找到两个节点的最近公共祖先："></a><strong>找到两个节点的最近公共祖先</strong>：</h4><p><strong>问题描述</strong>：                                                                                                                                                           </p>
<p> 先求出父结点，然后用向上标记法<br>p 向上一直到 root 标红色<br>q向上，第一次遇到红色时，就找到了LCA</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li>对每个节点递归判断：<ul>
<li>如果节点等于 p 或 q，则返回当前节点。</li>
<li>如果左右子树分别找到了 p 和 q，则当前节点为最近公共祖先。</li>
<li>如果只有一侧找到 p 或 q，则返回这一侧的结果。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;iostream&gt;<br>using namespace std;<br><br><span class="hljs-comment">// 树的节点结构</span><br>struct TreeNode &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-type">int</span> x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* p = nullptr;<br>    TreeNode* q = nullptr;<br>    TreeNode* ans = nullptr;<br><br>    <span class="hljs-comment">// 寻找二叉树中两个节点的最近公共祖先</span><br>    TreeNode* Ansestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-built_in">this</span>-&gt;p = p;<br>        <span class="hljs-built_in">this</span>-&gt;q = q;<br>        ans = nullptr;  <span class="hljs-comment">// 确保 ans 在每次调用时都为 nullptr</span><br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 深度优先搜索辅助函数，返回包含 p 和 q 的标记</span><br>    pair&lt;bool, bool&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;<br><br>        <span class="hljs-comment">// 递归查找左子树和右子树</span><br>        pair&lt;bool, bool&gt; leftResult = dfs(root-&gt;left);<br>        pair&lt;bool, bool&gt; rightResult = dfs(root-&gt;right);<br><br>        <span class="hljs-comment">// 当前节点是否包含 p 或 q 的状态</span><br>        pair&lt;bool, bool&gt; result;<br>        result.first = leftResult.first || rightResult.first || root == p;<br>        result.second = leftResult.second || rightResult.second || root == q;<br><br>        <span class="hljs-comment">// 若当前节点同时包含 p 和 q 且 ans 尚未被设置，则将当前节点设置为答案</span><br>        <span class="hljs-keyword">if</span> (result.first &amp;&amp; result.second &amp;&amp; ans == nullptr) &#123;<br>            ans = root;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 构建一棵简单的二叉树</span><br>    <span class="hljs-comment">//        1</span><br>    <span class="hljs-comment">//       / \</span><br>    <span class="hljs-comment">//      2   3</span><br>    <span class="hljs-comment">//     / \</span><br>    <span class="hljs-comment">//    4   5</span><br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>    root-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>    root-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>    root-&gt;left-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>    root-&gt;left-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 创建 Solution 对象</span><br>    Solution sol;<br><br>    <span class="hljs-comment">// 找到节点 4 和 5 的最近公共祖先</span><br>    TreeNode* ancestor = sol.Ansestor(root, root-&gt;left-&gt;left, root-&gt;left-&gt;right);<br>    <span class="hljs-keyword">if</span> (ancestor) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Ancestor of 4 and 5: &quot;</span> &lt;&lt; ancestor-&gt;val &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Ancestor not found.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 清理动态分配的内存</span><br>    delete root-&gt;left-&gt;left;<br>    delete root-&gt;left-&gt;right;<br>    delete root-&gt;left;<br>    delete root-&gt;right;<br>    delete root;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>分析</strong>：<ul>
<li>通过递归遍历整棵树，当一个节点的左右子树分别找到 p 和 q 时，该节点即为最近公共祖先。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="十一-图"><a href="#十一-图" class="headerlink" title="十一.图"></a>十一.图</h1><h3 id="图的存储方式："><a href="#图的存储方式：" class="headerlink" title="图的存储方式："></a><strong>图的存储方式</strong>：</h3><ul>
<li><p><strong>邻接矩阵</strong>：</p>
<ul>
<li>使用二维数组 <code>graph[MAX_N][MAX_N]</code>，其中 <code>graph[x][y] = 1</code> 表示节点 <code>x</code> 与节点 <code>y</code> 之间有一条边。</li>
<li>适用于稠密图，但在处理稀疏图时会占用大量空间，复杂度为 O(N^2)。</li>
</ul>
</li>
<li><p><strong>我只会出边数组</strong>：</p>
<ul>
<li>使用动态数组 <code>vector&lt;int&gt; graph[MAX_N]</code> 来存储邻接表，每个元素存储与该节点相邻的所有节点。</li>
<li>这种方式更适合稀疏图，复杂度为 O(M)，其中 M 是图中边的数量。</li>
</ul>
</li>
<li><p><strong>邻接表</strong>：</p>
<ul>
<li>使用结构体数组来存储边的信息，每个边包含两个属性：<code>from</code> 和 <code>to</code> 表示边的起点和终点，以及 <code>next</code> 指向下一条边。</li>
<li><code>head</code> 数组用于记录每个顶点的第一条边。适合空间较紧张的情况。</li>
</ul>
<p>邻接矩阵实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 节点数量</span><br><span class="hljs-type">int</span> graph[MAX_N][MAX_N];  <span class="hljs-comment">// 邻接矩阵</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    graph[x][y] = <span class="hljs-number">1</span>;<br>    graph[y][x] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 无向图，需要对称添加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printGraph</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;邻接矩阵:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; MAX_N; j++) &#123;<br>            cout &lt;&lt; graph[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-built_in">printGraph</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>出边数组实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 节点数量</span><br>vector&lt;<span class="hljs-type">int</span>&gt; graph[MAX_N];  <span class="hljs-comment">// 出边数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    graph[x].<span class="hljs-built_in">push_back</span>(y);<br>    graph[y].<span class="hljs-built_in">push_back</span>(x);  <span class="hljs-comment">// 无向图</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printGraph</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;出边数组:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_N; i++) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[i]) &#123;<br>            cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-built_in">printGraph</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>出边数组:<br><span class="hljs-number">0</span>: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <br><span class="hljs-number">1</span>: <span class="hljs-number">0</span> <span class="hljs-number">3</span> <br><span class="hljs-number">2</span>: <span class="hljs-number">0</span> <span class="hljs-number">3</span> <br><span class="hljs-number">3</span>: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure>

<p>邻接表实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    Node* next;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">4</span>;  <span class="hljs-comment">// 节点数量</span><br>Node* head[MAX_N];  <span class="hljs-comment">// 邻接表的表头数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    Node* node1 = <span class="hljs-keyword">new</span> Node&#123;y, head[x]&#125;;  <span class="hljs-comment">// 添加x-&gt;y的边</span><br>    head[x] = node1;<br><br>    Node* node2 = <span class="hljs-keyword">new</span> Node&#123;x, head[y]&#125;;  <span class="hljs-comment">// 添加y-&gt;x的边（无向图）</span><br>    head[y] = node2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printGraph</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;邻接表:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_N; i++) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        Node* curr = head[i];<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; curr-&gt;to &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            curr = curr-&gt;next;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-built_in">printGraph</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>邻接表:<br><span class="hljs-number">0</span>: <span class="hljs-number">2</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span>: <span class="hljs-number">3</span> <span class="hljs-number">0</span> <br><span class="hljs-number">2</span>: <span class="hljs-number">3</span> <span class="hljs-number">0</span> <br><span class="hljs-number">3</span>: <span class="hljs-number">2</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>DFS（深度优先搜索）的定义、实现及应用</strong>：</p>
<ul>
<li><p>DFS 是一种图或树的遍历算法，它沿着一条路径尽可能深入，然后回溯，继续探索其他路径。DFS 通常使用递归或显式栈来实现。</p>
</li>
<li><p>主要应用包括路径搜索、环检测、拓扑排序、图的连通性检测等。</p>
</li>
<li><p><strong>从起点开始</strong>：首先选择一个起点节点，将其标记为已访问。</p>
<p><strong>递归&#x2F;栈操作</strong>：从该节点开始，依次访问所有尚未访问过的邻接节点。对每个未访问的节点，递归执行相同的操作，直到该路径上的所有节点都被访问。</p>
<p><strong>回溯</strong>：如果当前节点的所有邻接节点都已访问过，则回退到前一个节点并继续搜索。</p>
<p><strong>结束条件</strong>：当所有节点都被访问过时，算法结束。</p>
</li>
<li><p>DFS 的两种实现方式：</p>
<p>1.递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-comment">// 标记当前节点已访问</span><br>    visited[node] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 遍历该节点的所有邻居</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>            <span class="hljs-built_in">dfs</span>(neighbor, graph, visited);  <span class="hljs-comment">// 递归访问未访问的邻居</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>2.使用栈的非递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">push</span>(start);  <span class="hljs-comment">// 将起点入栈</span><br><br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果当前节点还未访问，则访问它</span><br>        <span class="hljs-keyword">if</span> (!visited[node]) &#123;<br>            visited[node] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历节点的邻居，并将未访问的邻居入栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                s.<span class="hljs-built_in">push</span>(neighbor);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>BFS（广度优先搜索）的定义、实现及应用</strong>：</p>
<ul>
<li><p>BFS 是一种图的遍历算法，按层次逐步遍历节点，先访问距离起点最近的节点，再访问更远的节点。通常使用队列来实现。</p>
</li>
<li><p><strong>从起点开始</strong>：选择一个起点，将它标记为已访问，并将它加入队列。</p>
<p><strong>依次访问队列中的节点</strong>：从队列中取出一个节点，访问该节点的所有邻居，并将未访问过的邻居节点加入队列。</p>
<p><strong>继续遍历</strong>：重复上述步骤，直到队列为空，所有节点都被访问。</p>
<p><strong>结束条件</strong>：当队列为空时，表示所有与起点连通的节点都被访问过。</p>
</li>
<li><p>BFS 的应用包括寻找最短路径、层次遍历、连通性检测等。</p>
</li>
<li><p>BFS 的实现方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);  <span class="hljs-comment">// 将起点加入队列</span><br>    visited[start] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记起点已访问</span><br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 从队列中取出一个节点</span><br><br>        <span class="hljs-comment">// 访问该节点的所有邻居</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                q.<span class="hljs-built_in">push</span>(neighbor);  <span class="hljs-comment">// 将未访问的邻居加入队列</span><br>                visited[neighbor] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记该邻居已访问</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>无向图和有向图中 BFS 和 DFS 的区别</strong>：</p>
<ul>
<li><p>无向图中的边是双向的，可以从两端节点互相访问，因此从一个节点可以沿着边遍历到任何邻接节点，并可以返回原节点；有向图中的边是单向的，只能按边的方向遍历。</p>
</li>
<li><p>在无向图中，BFS用于    </p>
<p><strong>连通性检查</strong>：BFS 可以检查图是否是连通图。如果从一个起点出发，能够通过 BFS 遍历到所有节点，说明图是连通的，否则图是非连通的。</p>
<p><strong>最短路径查找</strong>：在无权无向图中，BFS 可以用于寻找从起点到任意节点的最短路径，因为 BFS 是按层次进行遍历，首次到达某个节点时的路径就是最短路径。</p>
<p><strong>图的分层</strong>：通过 BFS，可以给图中的每个节点分配一个层次，表示其距离起点的最短距离。 </p>
</li>
<li><p>在无向图中，DFS 用于</p>
</li>
</ul>
<p>  <strong>连通分量查找</strong>：DFS 可以找到图中的所有连通分量。如果从某个节点出发，不能遍历到所有节点，说明图有多个连通分量。可以从每个未访问的节点重新开始 DFS，找到所有连通分量。</p>
<p>  <strong>图的遍历</strong>：DFS 可以完整遍历图中的所有节点，并且可以沿着一条路径尽量深入。</p>
<p>  <strong>环检测</strong>：在无向图中，DFS 可以用于检测是否存在环。如果 DFS 遍历过程中访问到了已经访问过的节点，且该节点不是当前节点的父节点，则说明存在环。</p>
<ul>
<li><strong>有向图中的 BFS</strong></li>
</ul>
<p>  BFS 在有向图中的作用类似于无向图，但有一些不同点：</p>
<ul>
<li><p><strong>路径搜索</strong>：在有向图中，BFS 只能沿着边的方向进行遍历，因此从节点 <code>A</code> 出发到达某个节点 <code>B</code>，必须沿着边 <code>A → B</code> 或更多中间节点组成的路径。因此，BFS 可以用来寻找有向图中的最短路径，但只考虑有向路径。</p>
</li>
<li><p><strong>连通性检查</strong>：在有向图中，BFS 可以用来判断强连通性。如果从一个节点能够访问所有其他节点，且反过来也能从所有节点访问到该节点，则图是强连通的。单向 BFS 只能检查单向的连通性，双向 BFS 可以检查强连通性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    visited[start] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-comment">// 遍历有向图的邻居节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                q.<span class="hljs-built_in">push</span>(neighbor);<br>                visited[neighbor] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


</li>
<li><h4 id="有向图中的-DFS"><a href="#有向图中的-DFS" class="headerlink" title="有向图中的 DFS"></a><strong>有向图中的 DFS</strong></h4><p>在有向图中，DFS 可以用于以下一些应用场景：</p>
<ul>
<li><p><strong>拓扑排序</strong>：在有向无环图（DAG）中，DFS 可以生成拓扑排序。通过 DFS 后序遍历的逆序，获得一个合法的拓扑排序，确保在排序中，依赖的节点排在被依赖节点的前面。</p>
</li>
<li><p><strong>环检测</strong>：DFS 可以检测有向图中的环。如果在 DFS 过程中访问到一个正在访问中的节点（即当前递归路径中的节点），说明有向图中存在环。</p>
</li>
<li><p><strong>强连通分量</strong>：使用 Tarjan 算法或 Kosaraju 算法，结合 DFS，可以找到有向图中的所有强连通分量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    visited[node] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>            <span class="hljs-built_in">dfs</span>(neighbor, graph, visited);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>拓扑排序的定义和应用</strong>：</p>
<ul>
<li><p>拓扑排序是针对有向无环图（DAG）的一种排序算法，用于将图中的节点按照依赖关系排序。通常用于解决具有依赖顺序的任务，例如课程表问题、任务调度等。</p>
</li>
<li><p>它通过遍历节点，确保每个节点出现在它依赖的节点之后。</p>
</li>
<li><p>实现方式有两种：</p>
</li>
<li><p>使用入度表的 Kahn’s 算法（基于 BFS）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// Kahn&#x27;s Algorithm for Topological Sorting</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">kahnTopologicalSort</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(numCourses);  <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 每个节点的入度</span><br><br>    <span class="hljs-comment">// 构建图和计算每个节点的入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pre : prerequisites) &#123;<br>        <span class="hljs-type">int</span> course = pre[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> prereq = pre[<span class="hljs-number">1</span>];<br>        adj[prereq].<span class="hljs-built_in">push_back</span>(course);  <span class="hljs-comment">// prereq -&gt; course</span><br>        inDegree[course]++;  <span class="hljs-comment">// 课程的入度+1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 初始化队列，放入所有入度为 0 的节点</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; topoOrder;  <span class="hljs-comment">// 拓扑排序结果</span><br><br>    <span class="hljs-comment">// 执行拓扑排序</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        topoOrder.<span class="hljs-built_in">push_back</span>(node);<br><br>        <span class="hljs-comment">// 对于当前节点的所有邻居，减少其入度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : adj[node]) &#123;<br>            inDegree[neighbor]--;<br>            <span class="hljs-keyword">if</span> (inDegree[neighbor] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(neighbor);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果拓扑排序的结果包含了所有节点，说明图中无环</span><br>    <span class="hljs-keyword">if</span> (topoOrder.<span class="hljs-built_in">size</span>() == numCourses) &#123;<br>        <span class="hljs-keyword">return</span> topoOrder;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果无法完成所有课程，返回空</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> numCourses = <span class="hljs-number">4</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; prerequisites = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">kahnTopologicalSort</span>(numCourses, prerequisites);<br><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;图中存在环，无法进行拓扑排序。&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拓扑排序结果: &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> course : result) &#123;<br>            cout &lt;&lt; course &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设有一个有向图：</span><br><span class="hljs-comment">课程 0 必须先修课程 1，</span><br><span class="hljs-comment">课程 1 必须先修课程 2，</span><br><span class="hljs-comment">课程 3 没有前置课程。</span><br><span class="hljs-comment">这个依赖关系可以表示为有向图：</span><br><span class="hljs-comment">1 → 0</span><br><span class="hljs-comment">2 → 1</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">拓扑排序结果: 3 2 1 0  </span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">示例输入：</span><br><span class="hljs-comment">假设有 4 门课程，先修课程关系如下：</span><br><span class="hljs-comment">课程 0 必须先修课程 1 ([0, 1])。</span><br><span class="hljs-comment">课程 1 必须先修课程 2 ([1, 2])。</span><br><span class="hljs-comment">课程 3 没有先修课程 ([3, 2] 表示课程 3 也可以直接学习)。</span><br><span class="hljs-comment">邻接表和入度初始化：</span><br><span class="hljs-comment">根据 prerequisites 构建邻接表（存储每个节点的邻居节点）和入度表（存储每个节点的依赖数量）：</span><br><span class="hljs-comment">邻接表表示每个课程的后续课程：</span><br><span class="hljs-comment">adj[1] = [0]  (课程 1 的后续是课程 0)</span><br><span class="hljs-comment">adj[2] = [1, 3]  (课程 2 的后续是课程 1 和课程 3)</span><br><span class="hljs-comment">入度数组表示每个课程的先修依赖数：</span><br><span class="hljs-comment">inDegree = [1, 1, 0, 0]</span><br><span class="hljs-comment">解释：</span><br><span class="hljs-comment">课程 0 的入度为 1（依赖课程 1）。</span><br><span class="hljs-comment">课程 1 的入度为 1（依赖课程 2）。</span><br><span class="hljs-comment">课程 2 和课程 3 的入度为 0（没有依赖课程，可以直接学习）。</span><br><span class="hljs-comment">第一步：将入度为 0 的节点加入队列</span><br><span class="hljs-comment">将所有入度为 0 的课程加入队列，表示这些课程可以先学习：</span><br><span class="hljs-comment">入度为 0 的课程是 2 和 3，所以队列初始化为：</span><br><span class="hljs-comment">q = [2, 3]</span><br><span class="hljs-comment">第二步：BFS 遍历，开始拓扑排序</span><br><span class="hljs-comment">开始逐步从队列中取出节点并处理它们，按拓扑顺序依次添加到 topoOrder 列表。</span><br><span class="hljs-comment">1. 处理节点 2：</span><br><span class="hljs-comment">队列中第一个元素是课程 2，将它从队列中取出并加入 topoOrder：</span><br><span class="hljs-comment">topoOrder = [2]</span><br><span class="hljs-comment">遍历课程 2 的邻接节点（即它的后续课程 1 和 3）：</span><br><span class="hljs-comment">对于课程 1，减少它的入度（inDegree[1]--，入度变为 0）。因为课程 1 的入度变为 0，加入队列：</span><br><span class="hljs-comment">q = [3, 1]</span><br><span class="hljs-comment">对于课程 3，减少它的入度，但它的入度已经是 0，所以无需改变队列。</span><br><span class="hljs-comment">2. 处理节点 3：</span><br><span class="hljs-comment">队列中下一个元素是课程 3，将它从队列中取出并加入 topoOrder：</span><br><span class="hljs-comment">topoOrder = [2, 3]</span><br><span class="hljs-comment">课程 3 没有邻接节点（没有依赖课程），队列保持不变：</span><br><span class="hljs-comment">q = [1]</span><br><span class="hljs-comment">3. 处理节点 1：</span><br><span class="hljs-comment">队列中下一个元素是课程 1，将它从队列中取出并加入 topoOrder：</span><br><span class="hljs-comment">topoOrder = [2, 3, 1]</span><br><span class="hljs-comment">遍历课程 1 的邻接节点（即它的后续课程 0）：</span><br><span class="hljs-comment">对于课程 0，减少它的入度（inDegree[0]--，入度变为 0）。因为课程 0 的入度变为 0，加入队列：</span><br><span class="hljs-comment">q = [0]</span><br><span class="hljs-comment">4. 处理节点 0：</span><br><span class="hljs-comment">队列中最后一个元素是课程 0，将它从队列中取出并加入 topoOrder：</span><br><span class="hljs-comment">topoOrder = [2, 3, 1, 0]</span><br><span class="hljs-comment">课程 0 没有邻接节点，队列变为空：</span><br><span class="hljs-comment">q = []</span><br><span class="hljs-comment">第三步：判断结果</span><br><span class="hljs-comment">此时，队列已经为空，所有节点都被处理。因为 topoOrder 中包含了所有课程，说明图中没有环，可以完成所有课程，且 topoOrder 列表就是课程的拓扑排序顺序：</span><br><span class="hljs-comment">拓扑排序结果：2 → 3 → 1 → 0</span><br><span class="hljs-comment">结果解释：</span><br><span class="hljs-comment">我们可以先修课程 2（没有依赖），然后课程 3 和课程 1（课程 1 依赖于课程 2），最后修课程 0（课程 0 依赖于课程 1）。</span><br><span class="hljs-comment">因此，课程可以按照顺序 [2, 3, 1, 0] 依次完成。 </span><br><span class="hljs-comment">*/</span>    <br></code></pre></td></tr></table></figure>


</li>
<li><p>基于 DFS 的递归方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 辅助函数，用于执行 DFS</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, stack&lt;<span class="hljs-type">int</span>&gt;&amp; topoStack)</span> </span>&#123;<br>    visited[node] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点为已访问</span><br><br>    <span class="hljs-comment">// 递归访问当前节点的所有邻接节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>            <span class="hljs-built_in">dfs</span>(neighbor, graph, visited, topoStack);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 当邻接节点都访问完，将当前节点入栈</span><br>    topoStack.<span class="hljs-built_in">push</span>(node);<br>&#125;<br><br><span class="hljs-comment">// 主函数：基于 DFS 的拓扑排序</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfsTopologicalSort</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses);  <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numCourses, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 记录每个节点是否已访问</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; topoStack;  <span class="hljs-comment">// 用于存储拓扑排序的结果</span><br><br>    <span class="hljs-comment">// 构建图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pre : prerequisites) &#123;<br>        <span class="hljs-type">int</span> course = pre[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> prereq = pre[<span class="hljs-number">1</span>];<br>        graph[prereq].<span class="hljs-built_in">push_back</span>(course);  <span class="hljs-comment">// prereq → course</span><br>    &#125;<br><br>    <span class="hljs-comment">// 对每个节点执行 DFS</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>            <span class="hljs-built_in">dfs</span>(i, graph, visited, topoStack);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从栈中取出元素形成拓扑排序结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; topoOrder;<br>    <span class="hljs-keyword">while</span> (!topoStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        topoOrder.<span class="hljs-built_in">push_back</span>(topoStack.<span class="hljs-built_in">top</span>());<br>        topoStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> topoOrder;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> numCourses = <span class="hljs-number">4</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; prerequisites = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">dfsTopologicalSort</span>(numCourses, prerequisites);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;拓扑排序结果: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> course : result) &#123;<br>        cout &lt;&lt; course &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">DFS 拓扑排序步骤：</span><br><span class="hljs-comment">从未访问的节点出发，递归遍历其所有邻接节点。</span><br><span class="hljs-comment">在回溯的过程中，将节点压入栈中。这意味着节点的所有依赖（邻接节点）都已被处理。</span><br><span class="hljs-comment">最终，栈中的顺序就是拓扑排序，因为递归回溯的顺序保证了先处理依赖节点。</span><br><span class="hljs-comment">邻接表 graph：存储图的依赖关系，graph[prereq] 中存储所有依赖 prereq 的课程。</span><br><span class="hljs-comment">DFS 函数：</span><br><span class="hljs-comment">递归访问每个节点的邻接节点，当所有邻接节点都访问完时，将当前节点压入栈 topoStack 中。</span><br><span class="hljs-comment">这个栈用于存储拓扑排序的顺序。</span><br><span class="hljs-comment">主函数 dfsTopologicalSort：</span><br><span class="hljs-comment">对所有未访问的节点执行 DFS，处理图中所有的节点。</span><br><span class="hljs-comment">最终从栈中依次取出元素，形成拓扑排序的顺序。</span><br><span class="hljs-comment">执行过程模拟：</span><br><span class="hljs-comment">构建图和初始化：</span><br><span class="hljs-comment">邻接表表示为：</span><br><span class="hljs-comment">graph[1] = [0]</span><br><span class="hljs-comment">graph[2] = [1, 3]</span><br><span class="hljs-comment">初始 visited 数组为 [false, false, false, false]，topoStack 为空。</span><br><span class="hljs-comment">DFS 开始：</span><br><span class="hljs-comment">从节点 0 开始，DFS 遍历其依赖的节点。因为节点 0 依赖节点 1，所以递归进入节点 1。节点 1 又依赖节点 2，递归进入节点 2。</span><br><span class="hljs-comment">当到达节点 2 后，没有更多依赖，节点 2 入栈，回溯到节点 1，节点 1 入栈，回溯到节点 0，节点 0 入栈。</span><br><span class="hljs-comment">处理节点 3：</span><br><span class="hljs-comment">节点 3 没有任何依赖节点，直接入栈。</span><br><span class="hljs-comment">生成拓扑排序：</span><br><span class="hljs-comment">栈中的元素依次为 [3, 2, 1, 0]。因此，拓扑排序结果为：</span><br><span class="hljs-comment">拓扑排序结果：3 2 1 0</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">拓扑排序结果: 3 2 1 0</span><br><span class="hljs-comment">结果解释：</span><br><span class="hljs-comment">我们可以先修课程 2（没有依赖），然后修课程 1（依赖于课程 2），接着修课程 0（依赖于课程 1）。课程 3 没有依赖，可以在任何时候修。</span><br><span class="hljs-comment">因此，课程可以按照顺序 [3, 2, 1, 0] 依次完成。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><h4 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h4><p>edges &#x3D; [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5]]</p>
<p>算法实现</p>
<ol>
<li><strong>出边数组的构建</strong>：使用邻接表（出边数组）表示树的结构，方便遍历。</li>
<li>两次 BFS<ul>
<li>第一次 BFS 从任意节点出发（这里从节点 <code>0</code> 出发），找到距离最远的节点 <code>p</code>。</li>
<li>第二次 BFS 从 <code>p</code> 出发，找到距离最远的另一个节点，并返回此距离作为树的直径。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to; <span class="hljs-comment">// 出边数组</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeDiameter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>            n = <span class="hljs-built_in">max</span>(n, <span class="hljs-built_in">max</span>(x, y)); <span class="hljs-comment">// 计算最大节点编号</span><br>        &#125;<br>        n++; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++)	to.<span class="hljs-built_in">push_back</span>(&#123;&#125;); <span class="hljs-comment">//初始化</span><br>        <span class="hljs-comment">// 构建出边数组</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>            to[x].<span class="hljs-built_in">push_back</span>(y);<br>            to[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br><br>        <span class="hljs-comment">// 从任意节点 0 开始，找到最远的节点</span><br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">findFarthest</span>(<span class="hljs-number">0</span>).first;<br>        <span class="hljs-comment">// 从找到的最远节点 p 再次执行 BFS，求出树的直径</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFarthest</span>(p).second;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// &lt;点，距离&gt;</span><br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">findFarthest</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 记录每个节点的深度，初始为 -1</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        depth[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起始节点的深度为 0</span><br>        <span class="hljs-comment">// BFS</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                <span class="hljs-keyword">if</span> (depth[y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过已访问节点</span><br>                depth[y] = depth[x] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新深度</span><br>                q.<span class="hljs-built_in">push</span>(y); <span class="hljs-comment">// 将该节点加入队列</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到距离最远的节点</span><br>        <span class="hljs-type">int</span> ans = start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (depth[i] &gt; depth[ans]) ans = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;ans, depth[ans]&#125;;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><p>输入: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]<br>输出: false<br>解释: 课程 1 依赖于课程 0，课程 0 也依赖于课程 1，形成循环，无法完成所有课程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化邻接表和入度表</span><br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        inDeg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 构建图</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre : prerequisites) &#123;<br>            <span class="hljs-type">int</span> ai = pre[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> bi = pre[<span class="hljs-number">1</span>];<br>            to[bi].<span class="hljs-built_in">push_back</span>(ai);<br>            inDeg[ai]++;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>       <span class="hljs-comment">//拓扑排序第一步:从零入度点出发</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; lessons;  <span class="hljs-comment">// 保存完成的课程</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            lessons.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-comment">// 第二步:扩展一个点，周围的点入度减一</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                inDeg[y]--;<br>                <span class="hljs-keyword">if</span> (inDeg[y] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);  <span class="hljs-comment">// 第三步:入度减为0，表示可以入队了</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果所有课程都能完成，返回true</span><br>        <span class="hljs-keyword">return</span> lessons.<span class="hljs-built_in">size</span>() == numCourses;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;   <span class="hljs-comment">// 邻接表</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; inDeg;        <span class="hljs-comment">// 入度表</span><br>&#125;;<br><span class="hljs-comment">//这个bfs就不用判重了。因为你有了indeg这个东西啊减为零才会入队。如果说有环，是不是根本就减不到零,他们就不会去访问啊，不会有重复，所以说这里我就不用判重</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设输入：</span><br><span class="hljs-comment">numCourses = 2</span><br><span class="hljs-comment">prerequisites = [[1, 0]]</span><br><span class="hljs-comment">这表示有 2 门课程，编号为 0 和 1。要完成课程 1，你必须先完成课程 0。</span><br><span class="hljs-comment">步骤 1：构建图和入度表</span><br><span class="hljs-comment">邻接表 to：这是一个二维向量，其中 to[bi] 保存了所有依赖于 bi 的课程，即 bi 的后续课程。在该例中：</span><br><span class="hljs-comment">to[0] 保存了课程 1，因为课程 1 依赖于课程 0。因此，to[0] = [1]，表示从课程 0 可以走到课程 1。</span><br><span class="hljs-comment">to[1] 没有后续课程，因此 to[1] 为空。</span><br><span class="hljs-comment">入度表 inDeg：这是一个一维向量，用来存储每个课程的入度，即需要先修多少门课程。在该例中：</span><br><span class="hljs-comment">课程 0 没有任何依赖，所以 inDeg[0] = 0。</span><br><span class="hljs-comment">课程 1 需要先修课程 0，所以 inDeg[1] = 1。</span><br><span class="hljs-comment">此时，邻接表和入度表如下：</span><br><span class="hljs-comment">to = [[1], []]</span><br><span class="hljs-comment">inDeg = [0, 1]</span><br><span class="hljs-comment">步骤 2：拓扑排序准备</span><br><span class="hljs-comment">我们需要找到所有入度为 0 的课程，也就是不需要先修课程就可以直接学习的课程。在该例中，课程 0 的入度为 0，因此我们将课程 0 加入队列 q。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = [0]</span><br><span class="hljs-comment">步骤 3：广度优先搜索（BFS）拓扑排序</span><br><span class="hljs-comment">处理课程 0：</span><br><span class="hljs-comment">从队列中取出课程 0 并将其标记为已完成（加入 lessons 列表）。</span><br><span class="hljs-comment">查看课程 0 的所有后续课程（在邻接表 to[0] 中查找），可以看到课程 1 依赖于课程 0。</span><br><span class="hljs-comment">减少课程 1 的入度（inDeg[1]--），此时课程 1 的入度变为 0，表示可以学习课程 1，将其加入队列。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = [1]</span><br><span class="hljs-comment">lessons = [0]</span><br><span class="hljs-comment">inDeg = [0, 0]</span><br><span class="hljs-comment">处理课程 1：</span><br><span class="hljs-comment">从队列中取出课程 1，并将其标记为已完成（加入 lessons 列表）。</span><br><span class="hljs-comment">课程 1 没有后续课程，因此队列处理完毕。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = []</span><br><span class="hljs-comment">lessons = [0, 1]</span><br><span class="hljs-comment">步骤 4：判断结果 拓扑排序完成后，lessons 列表中包含了所有课程 [0, 1]，说明可以完成所有课程。 因此，最终返回 true。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总结： 这段代码使用的是拓扑排序算法，利用 BFS 来检测图中是否存在环： 如果所有课程都能在拓扑排序中被处理（即 lessons.size() == numCourses），说明没有循环依赖，可以完成所有课程。 如果存在环，则会有一些课程无法被处理，队列会提前结束，此时返回 false。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<h4 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化节点数</span><br>        <span class="hljs-comment">// 计算实际的最大节点编号（n）</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取当前边的两个节点</span><br>            n = <span class="hljs-built_in">max</span>(n, <span class="hljs-built_in">max</span>(x, y));  <span class="hljs-comment">// 更新最大节点编号</span><br>        &#125;<br><br>        <span class="hljs-comment">// 初始化邻接表和访问标记数组</span><br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">// 遍历所有边，构建图并检查环</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取当前边的两个节点</span><br>            <br>            <span class="hljs-comment">// 添加边到邻接表中，构建无向图，邻接表的构建</span><br>            to[x].<span class="hljs-built_in">push_back</span>(y);<br>            to[y].<span class="hljs-built_in">push_back</span>(x);<br>            hasCycle = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 重置环标记</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 从节点1开始DFS，父节点设为0（不存在）</span><br><br>            <span class="hljs-comment">// 如果检测到环，返回当前边</span><br>            <span class="hljs-keyword">if</span> (hasCycle) <span class="hljs-keyword">return</span> edge;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果没有发现冗余边，返回空数组</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 深度优先搜索 (DFS) 用于检测是否形成环,dfs模版</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>        visited[x] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点已访问</span><br>        <span class="hljs-comment">// 遍历当前节点 x 的所有邻居节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>            <span class="hljs-keyword">if</span> (y == fa) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果是父节点，则跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[y]) &#123;<br>                <span class="hljs-comment">// 如果未访问，继续递归DFS</span><br>                <span class="hljs-built_in">dfs</span>(y, x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果已经访问过，说明存在环</span><br>                hasCycle = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;  <span class="hljs-comment">// 节点总数</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;  <span class="hljs-comment">// 邻接表，存储每个节点的邻居</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited;  <span class="hljs-comment">// 标记节点是否访问过</span><br>    <span class="hljs-type">bool</span> hasCycle;  <span class="hljs-comment">// 是否存在环的标记</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">遍历边 &#123;1, 2&#125;，图中没有环，继续。</span><br><span class="hljs-comment">遍历边 &#123;1, 3&#125;，图中没有环，继续。</span><br><span class="hljs-comment">遍历边 &#123;2, 3&#125;，此时检测到环，返回 &#123;2, 3&#125;。</span><br><span class="hljs-comment">假设输入：</span><br><span class="hljs-comment">edges = &#123;&#123;1, 2&#125;, &#123;1, 3&#125;, &#123;2, 3&#125;&#125;</span><br><span class="hljs-comment">这表示有 3 条边和 3 个节点，图的结构如下：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">复制代码</span><br><span class="hljs-comment">1 - 2</span><br><span class="hljs-comment">|   |</span><br><span class="hljs-comment">3 - -</span><br><span class="hljs-comment">我们需要找到一条冗余的边，这条边的加入会导致形成环。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">模拟执行过程：</span><br><span class="hljs-comment">第一步：初始化</span><br><span class="hljs-comment">初始化 n = 0，用于存储节点的最大编号。</span><br><span class="hljs-comment">遍历 edges，更新 n 为最大节点编号，最终得到 n = 3。</span><br><span class="hljs-comment">初始化邻接表 to 和访问标记数组 visited：</span><br><span class="hljs-comment">to = [[], [], [], []]  // 邻接表初始化，4 个空列表（因为节点编号从 1 开始）</span><br><span class="hljs-comment">visited = [false, false, false, false]  // 节点访问标记，全部为 false</span><br><span class="hljs-comment">第二步：开始遍历每一条边</span><br><span class="hljs-comment">我们依次处理每一条边，将其加入邻接表，并进行 DFS 检测是否有环。</span><br><span class="hljs-comment">处理边 &#123;1, 2&#125;：</span><br><span class="hljs-comment">将边 &#123;1, 2&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2], [1], []]  // 节点 1 和 2 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, false, false]</span><br><span class="hljs-comment">遍历节点 1 的邻居节点，发现节点 2 尚未访问，因此进入节点 2 的 DFS。</span><br><span class="hljs-comment">访问节点 2，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, false]</span><br><span class="hljs-comment">节点 2 的邻居是节点 1（父节点），跳过。</span><br><span class="hljs-comment">结束 DFS，没有发现环。</span><br><span class="hljs-comment">处理边 &#123;1, 3&#125;：</span><br><span class="hljs-comment">将边 &#123;1, 3&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2, 3], [1], [1]]  // 节点 1 和 3 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, false]</span><br><span class="hljs-comment">遍历节点 1 的邻居，发现节点 2 已访问过，跳过。</span><br><span class="hljs-comment">发现节点 3 尚未访问，进入节点 3 的 DFS。</span><br><span class="hljs-comment">访问节点 3，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, true]</span><br><span class="hljs-comment">节点 3 的邻居是节点 1（父节点），跳过。</span><br><span class="hljs-comment">结束 DFS，没有发现环。</span><br><span class="hljs-comment">处理边 &#123;2, 3&#125;：</span><br><span class="hljs-comment">将边 &#123;2, 3&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2, 3], [1, 3], [1, 2]]  // 节点 2 和 3 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, true]</span><br><span class="hljs-comment">遍历节点 1 的邻居，发现节点 2 已访问过，跳过。</span><br><span class="hljs-comment">发现节点 3 已访问过，跳过。</span><br><span class="hljs-comment">然后，节点 2 继续进行 DFS，发现节点 3 已访问过，但节点 3 不是父节点，说明形成环。</span><br><span class="hljs-comment">标记 hasCycle = true。</span><br><span class="hljs-comment">结束 DFS，发现环，冗余边是 &#123;2, 3&#125;。</span><br><span class="hljs-comment">第三步：返回结果</span><br><span class="hljs-comment">因为在处理边 &#123;2, 3&#125; 时发现了环，因此该边就是冗余边，返回：</span><br><span class="hljs-comment">&#123;2, 3&#125;</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">冗余边是 &#123;2, 3&#125;，这条边导致了环的出现。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">解释：</span><br><span class="hljs-comment">边 &#123;1, 2&#125; 和 &#123;1, 3&#125; 构建了图的主体结构，但在加入 &#123;2, 3&#125; 后，形成了一个环 1 → 2 → 3 → 1，因此 &#123;2, 3&#125; 是冗余边。</span><br><span class="hljs-comment">代码通过 DFS 递归检测邻居节点，如果发现某个已访问的节点不是当前节点的父节点，则说明有环出现。    </span><br><span class="hljs-comment">*/</span><br>    <br></code></pre></td></tr></table></figure>

<h4 id="环检测"><a href="#环检测" class="headerlink" title="环检测"></a><strong>环检测</strong></h4><p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; onPath)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点为已访问</span><br>    onPath[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点位于递归路径上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, to, visited, onPath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (onPath[v]) &#123;<br>            hasCycle = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 检测到环</span><br>        &#125;<br>    &#125;<br>    onPath[u] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 递归结束后，移除路径上的节点</span><br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h1 id="十二-搜索"><a href="#十二-搜索" class="headerlink" title="十二.搜索"></a>十二.搜索</h1><h3 id="状态与状态空间搜索"><a href="#状态与状态空间搜索" class="headerlink" title="状态与状态空间搜索"></a><strong>状态与状态空间搜索</strong></h3><ul>
<li><p><strong>状态</strong>：</p>
<p>什么是状态?题面中涉及的所有数学信息，你在纸上人力计算时，关注的所有数据，一个函数访问的所有变量，例如最简单的计票问题，给n个名字，统计每个名字出现了多少次，你在纸上画“正”字统计的时候，关注了哪些数据?名字(n个字符串)，统计到哪个名字了(第1≤i≤n个名字)，画的“正”字(一个用于计数的数据结构，例如 Hash Map，就是程序维护的所有动态数据构成的集合，我们关注动态变化的变量</p>
</li>
<li><p><strong>状态空间</strong></p>
<p>所有可能状态构成的集合就是一个问题的状态空间，把状态作为点，如果从一个状态可以到达另一个状态，就连一条边这样就把整，状态空间抽象为了一张有向图，对问题的求解，就是对这张图的遍历，计票问题的状态空间由n个状态组成，可以看作一张n个点，n-1条边的有向图，整张图是一条链，自然就可以用一维循环解决了</p>
</li>
<li><p><strong>搜索算法</strong>：</p>
<ul>
<li><strong>深度优先搜索（DFS）</strong>：优先探索当前路径，深入到不能继续为止，再进行回溯。适用于需要遍历整棵搜索树或图的场景。</li>
<li><strong>广度优先搜索（BFS）</strong>：按照层次逐步扩展所有状态，适用于最短路径等需要找到最早解的场景。</li>
<li>一般来说，每个状态只遍历一次所以当状态空间是“图”而不是“树”时，要判重(记忆化)</li>
</ul>
</li>
</ul>
<h3 id="状态搜索的步骤"><a href="#状态搜索的步骤" class="headerlink" title="状态搜索的步骤"></a><strong>状态搜索的步骤</strong></h3><p>搜索题的解题步骤<br>1.纸上模拟，提取信息<br>2.定义状态<br>3.确定遍历顺序(DFS、BFS)<br>4.定义搜索框架<br>    如果是DFS，状态作为参数，确定递归边界，注意还原现场<br>    如果是BFS，状态用队列保存<br>    考虑是否需要判重<br>5.程序实现</p>
<p><strong>DFS 和 BFS 的比较</strong>：</p>
<ul>
<li><strong>DFS</strong>：在找到目标解之前，会不断深入搜索某条路径。适用于找到所有解，或不关心最优解的场景。</li>
<li><strong>BFS</strong>：逐层扩展搜索，通常用于寻找最优解或最短路径。</li>
</ul>
<hr>
<h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><h4 id="电话号码的字母组合问题："><a href="#电话号码的字母组合问题：" class="headerlink" title="电话号码的字母组合问题："></a>电话号码的字母组合问题：</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话按键一致。</p>
<p>例如：</p>
<ul>
<li>输入：”23”</li>
<li>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li>
</ul>
<p><strong>思路</strong>：</p>
<ul>
<li><strong>递归（DFS）实现</strong>：该问题可以被看作是一个递归问题，每个数字对应多个字母，每个数字的字母组合都与前一个数字的字母组合进行全排列。</li>
<li><strong>状态转移</strong>：每个状态表示当前递归到第几个数字，每次递归时选择对应数字所映射的字母，生成所有可能的字母组合。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">L</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;digits = digits;<br>        alphabet[<span class="hljs-string">&#x27;2&#x27;</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;3&#x27;</span>] = <span class="hljs-string">&quot;def&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;4&#x27;</span>] = <span class="hljs-string">&quot;ghi&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;5&#x27;</span>] = <span class="hljs-string">&quot;jkl&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;6&#x27;</span>] = <span class="hljs-string">&quot;mno&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;7&#x27;</span>] = <span class="hljs-string">&quot;pqrs&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;8&#x27;</span>] = <span class="hljs-string">&quot;tuv&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;9&#x27;</span>] = <span class="hljs-string">&quot;wxyz&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">length</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : alphabet[digits[index]]) &#123;<br>            <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, str + ch);<br>        &#125;<br>    &#125;<br><br>    string digits;<br>    vector&lt;string&gt; ans;<br>    unordered_map&lt;<span class="hljs-type">char</span>, string&gt; alphabet;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>详细分析</strong>：</p>
<ul>
<li><strong>递归过程</strong>：每次递归处理一个数字的所有字母组合，并将结果传递到下一层递归中。直到处理完所有数字后，结果将累积到 <code>ans</code> 中。</li>
<li><strong>时间复杂度</strong>：O(3^n * 4^m)，其中 n 是映射到 3 个字母的数字的数量，m 是映射到 4 个字母的数字的数量。</li>
</ul>
<hr>
<p> 状态的存储与计算优化：</p>
<p>通过<strong>哈希表（unordered_map）</strong>来存储和检索状态，以提高搜索效率。对于类似电话号码字母组合的问题，哈希表用于存储数字与字母的对应关系，方便快速查询。</p>
<p><strong>哈希表应用</strong>：</p>
<ul>
<li><strong>存储映射关系</strong>：数字到字母的映射使用 <code>unordered_map</code>，在搜索过程中可以快速查找某个数字对应的字母。</li>
<li><strong>状态去重</strong>：在某些状态搜索问题中，如果某个状态已经被访问过，可以使用哈希表来存储已访问状态，避免重复搜索，提升效率。</li>
</ul>
<p> 其他优化策略：</p>
<p><strong>剪枝</strong>：</p>
<p>在状态空间搜索中，剪枝是指提前终止那些不可能产生有效解的状态，减少搜索空间。常见的剪枝条件包括：</p>
<ul>
<li>状态不满足约束条件时，直接返回。</li>
<li>通过某些启发式方法判断该路径无法产生最优解，从而终止进一步搜索。</li>
</ul>
<h4 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n 皇后问题"></a>n 皇后问题</h4><p>给你一个整数 n，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>输入：n &#x3D; 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”], [“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        used = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        vector&lt;vector&lt;string&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; p : ans) &#123;<br>            <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">pattern</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; n; row++)<br>                pattern[row][p[row]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            result.<span class="hljs-built_in">push_back</span>(pattern);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(p);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-keyword">if</span> (!used[col] &amp;&amp; !usedPlus[row + col] &amp;&amp; !usedMinus[row - col]) &#123;<br>                p.<span class="hljs-built_in">push_back</span>(col);<br>                used[col] = <span class="hljs-literal">true</span>;<br>                usedPlus[row + col] = <span class="hljs-literal">true</span>;<br>                usedMinus[row - col] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>);<br>                usedMinus[row - col] = <span class="hljs-literal">false</span>;<br>                usedPlus[row + col] = <span class="hljs-literal">false</span>;<br>                used[col] = <span class="hljs-literal">false</span>;<br>                p.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; p;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; usedPlus;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; usedMinus;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;grid = grid;<br>        m = grid.<span class="hljs-built_in">length</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>();<br>        visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !visited[i][j]) &#123;<br>                    ans++;<br>                    <span class="hljs-built_in">bfs</span>(i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span> </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>        q.<span class="hljs-built_in">push</span>(&#123;sx, sy&#125;);<br>        visited[sx][sy] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;<br>            <span class="hljs-type">int</span> y = q.<span class="hljs-built_in">front</span>().second;<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-type">int</span> nx = x + dx[i];<br>                <span class="hljs-type">int</span> ny = y + dy[i];<br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= m || ny &lt; <span class="hljs-number">0</span> || ny &gt;= n) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (grid[nx][ny] != <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (visited[nx][ny]) <span class="hljs-keyword">continue</span>;<br>                q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>                visited[nx][ny] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited;<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h4 id="基因突变问题："><a href="#基因突变问题：" class="headerlink" title="基因突变问题："></a>基因突变问题：</h4><p><strong>问题描述</strong>：</p>
<ul>
<li>给定一个初始基因序列 <code>start</code> 和目标基因序列 <code>end</code>，每个基因序列由长度为 8 的字符（A、C、G、T）组成。</li>
<li>通过一次基因突变，可以将一个基因序列中的某个位置的字符变为另一个字符。</li>
<li>还给定了一个基因库 <code>bank</code>，该基因库中的基因序列为合法的突变序列。</li>
<li>问题要求找到从 <code>start</code> 变为 <code>end</code> 的最少突变次数，如果无法完成转换则返回 <code>-1</code>。</li>
</ul>
<p><strong>解法思路</strong>：</p>
<ul>
<li><strong>广度优先搜索（BFS）</strong>：每次将当前基因序列的合法突变加入队列，按层次遍历，直到找到目标基因序列为止。</li>
<li><strong>状态表示</strong>：每个基因序列是一个状态。</li>
<li><strong>状态转移</strong>：一次合法突变即为从当前基因序列变为另一个基因序列。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        depth[start] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (string seq : bank) hasBank.<span class="hljs-built_in">insert</span>(seq);<br>        <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(end) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        queue&lt;string&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> gene[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            string s = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (s[i] != gene[j]) &#123;<br>                        string ns = s;<br>                        ns[i] = gene[j];<br>                        <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(ns) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span> (depth.<span class="hljs-built_in">find</span>(ns) != depth.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br><br>                        depth[ns] = depth[s] + <span class="hljs-number">1</span>;<br>                        q.<span class="hljs-built_in">push</span>(ns);<br>                        <span class="hljs-keyword">if</span> (ns == end)<br>                            <span class="hljs-keyword">return</span> depth[ns];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;string&gt; hasBank;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; depth;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a><strong>矩阵中的最长递增路径</strong></h4><p>matrix &#x3D; [<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]</p>
<p><strong>图的建模</strong>：将矩阵中的每个元素看作图中的一个节点，如果某个元素的值小于其邻居元素的值，则从该节点向邻居建立一条有向边。</p>
<p><strong>拓扑排序</strong>：通过拓扑排序，按照递增的顺序处理节点，动态更新每个节点的最长递增路径。入度为 0 的节点首先处理，然后更新其邻居节点的入度，当邻居节点入度减为 0 时，将其加入队列。</p>
<p><strong>最长路径计算</strong>：通过 BFS 遍历所有节点，记录每个节点的最长递增路径长度，最终获取最大值作为结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        m = matrix.<span class="hljs-built_in">size</span>();<br>        n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m * n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                    <span class="hljs-type">int</span> ni = i + dx[k];<br>                    <span class="hljs-type">int</span> nj = j + dy[k];<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(ni, nj) &amp;&amp; matrix[ni][nj] &gt; matrix[i][j]) &#123;<br>                        <span class="hljs-built_in">addEdge</span>(<span class="hljs-built_in">num</span>(i, j), <span class="hljs-built_in">num</span>(ni, nj));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(i);<br>                dist[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                deg[y]--;<br>                dist[y] = <span class="hljs-built_in">max</span>(dist[y], dist[x] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (deg[y] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, dist[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m, n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;<br>    vector&lt;<span class="hljs-type">int</span>&gt; deg;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dist;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>], dy[<span class="hljs-number">4</span>];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        deg[v]++;<br>        to[u].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i * n + j;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<p>我们就知道了，在一张有效无环图上，不管是球最长啊。统计什么别的信息，只要这个信息需要对所有的哎入编做统计，比如取max，下求和等等，我们就可以使用。图排序来进行这样一个信息统计。</p>
<p>另一种方法：dfs记忆化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;matrix = matrix;<br>        m = matrix.<span class="hljs-built_in">size</span>();<br>        n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        dist = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// default value: 0 表示还没计算过</span><br><br>        dx = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        dy = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(i, j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dist[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dist[x][y]; <span class="hljs-comment">// 如果已经计算过，则返回</span><br>        dist[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化当前路径长度</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>            <span class="hljs-type">int</span> nx = x + dx[k];<br>            <span class="hljs-type">int</span> ny = y + dy[k];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(nx, ny) &amp;&amp; matrix[nx][ny] &gt; matrix[x][y]) &#123;<br>                dist[x][y] = <span class="hljs-built_in">max</span>(dist[x][y], <span class="hljs-built_in">dfs</span>(nx, ny) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist[x][y];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix;<br>    <span class="hljs-type">int</span> m, n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dx, dy;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dist;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>记忆化的工作原理</p>
<ol>
<li><strong>缓存结果</strong>：<code>dist[x][y]</code> 数组用来记录从位置 <code>(x, y)</code> 开始的最长递增路径长度。当位置 <code>(x, y)</code> 的路径长度已经计算过时，直接返回 <code>dist[x][y]</code> 的值，而不再重复计算。</li>
<li><strong>递归计算并更新缓存</strong>：<ul>
<li>当 <code>dist[x][y]</code> 为 <code>0</code> 时，说明 <code>(x, y)</code> 的路径长度还未计算。</li>
<li>通过 DFS 遍历 <code>(x, y)</code> 的四个相邻位置 <code>(nx, ny)</code>，若 <code>matrix[nx][ny] &gt; matrix[x][y]</code>，则继续递归计算从 <code>(nx, ny)</code> 开始的最长路径，并更新 <code>dist[x][y]</code> 为 <code>max(dist[x][y], dfs(nx, ny) + 1)</code>。</li>
</ul>
</li>
<li><strong>避免重复计算</strong>：每个位置 <code>(x, y)</code> 只会被计算一次，结果存储在 <code>dist[x][y]</code> 中，后续若需要从 <code>(x, y)</code> 开始的路径长度，直接使用缓存值，从而减少了不必要的递归调用。</li>
</ol>
<hr>
<p><strong>DFS 和 BFS 的对比</strong>：</p>
<p><strong>DFS（深度优先搜索）</strong>：</p>
<ul>
<li><strong>适用场景</strong>：<ul>
<li>适用于树形或图形结构的状态空间搜索，尤其是需要遍历所有可能解的场景。</li>
<li>更适合递归实现，适合处理树或图结构。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>深度优先</strong>：优先探索当前路径，深入到不能继续时才回溯。</li>
<li><strong>需要回溯</strong>：由于优先走到最深处，可能会走很多不必要的路径，因此需要回溯。</li>
<li><strong>应用场景</strong>：如全排列、子集等需要遍历所有可能状态的问题。</li>
</ul>
</li>
</ul>
<p><strong>BFS（广度优先搜索）</strong>：</p>
<ul>
<li><strong>适用场景</strong>：<ul>
<li>适用于寻找最短路径类问题，尤其在状态空间搜索中找到从起点到目标的最短步骤。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>广度优先</strong>：按层次遍历，优先处理当前层的节点，逐步扩展到下一层。</li>
<li><strong>最短路径</strong>：BFS 能够确保找到的解是步数最少的解，适合寻找最短路径、最小步数的场景。</li>
<li><strong>应用场景</strong>：如最短路径、最小步数、无权图的最短路径等问题。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>基因突变问题</strong>通过 BFS 解决，是一个经典的层次遍历问题。BFS 可以保证找到的路径是最短的，适合解决此类寻找最小步数的问题。</li>
<li><strong>DFS 和 BFS 的适用场景不同</strong>，DFS 更适合于需要遍历所有解的场景，而 BFS 则适合用于最短路径类问题。这两种搜索方法在不同的应用场景下各有优势。</li>
</ul>
<hr>
<h1 id="十三-二分"><a href="#十三-二分" class="headerlink" title="十三.二分"></a>十三.二分</h1><h3 id="二分查找的基本实现："><a href="#二分查找的基本实现：" class="headerlink" title="二分查找的基本实现："></a><strong>二分查找的基本实现</strong>：</h3><p>二分查找用于在有序数组中查找目标值 <code>target</code>，其时间复杂度为 O(log n)。</p>
<ul>
<li>将数组的搜索范围缩小为左边界 <code>left</code> 和右边界 <code>right</code>，每次取中间位置 <code>mid</code> 的值进行比较：<ul>
<li>如果 <code>array[mid] == target</code>，则找到了目标值，返回 <code>mid</code>。</li>
<li>如果 <code>array[mid] &lt; target</code>，则将左边界 <code>left</code> 移动到 <code>mid + 1</code>，缩小搜索范围。</li>
<li>如果 <code>array[mid] &gt; target</code>，则将右边界 <code>right</code> 移动到 <code>mid - 1</code>，缩小搜索范围。</li>
</ul>
</li>
</ul>
<p><strong>C++&#x2F;Java 实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] == target)<br>        <span class="hljs-keyword">break</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">return</span> mid;<br><br>    <span class="hljs-keyword">if</span> (array[mid] &lt; target)<br>        left = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>Python 实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(array) - <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> left &lt;= right:<br>    mid = (left + right) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> array[mid] == target:<br>        <span class="hljs-keyword">break</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">return</span> mid<br>    <span class="hljs-keyword">elif</span> array[mid] &lt; target:<br>        left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        right = mid - <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure>

<hr>
<p>适用更广的前驱型——找最后一个 &lt;&#x3D; <code>target</code> 的元素的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>, right = n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//向上取整</span><br>    <span class="hljs-keyword">if</span> (array[mid] &lt;= target)  <span class="hljs-comment">// 查找 upper_bound 即 array[mid] &gt; target</span><br>        left = mid;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 不安全返回n</span><br></code></pre></td></tr></table></figure>

<p>适用更广的后继型———找第一个 &gt;&#x3D; target 的数不存在返回n</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] &gt;= target)  <span class="hljs-comment">// 查找 upper_bound 即 array[mid] &gt; target</span><br>        right = mid;<br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 不安全返回n</span><br><br></code></pre></td></tr></table></figure>



<hr>
<ul>
<li><p><strong>二分查找的适用条件</strong>：</p>
<ul>
<li>二分查找适用于“条件单调”的情况，即在数组满足某种条件的情况下，可以通过二分来缩小查找范围。</li>
<li>图中举了例子：寻找旋转排序数组的最小值，或在排序数组中查找某个满足条件的位置。</li>
</ul>
<p><strong>二分查找的“三步走”</strong>：</p>
<ul>
<li><strong>步骤 1</strong>：写出二分的条件，通常是一个“不等式”条件。例如，对于 <code>upper_bound</code> 查找，可以用“<code>val</code> 的数中最小的”这种不等式条件。</li>
<li><strong>步骤 2</strong>：将条件放到 <code>if</code> 中，并确定满足条件时需要缩小哪一半（<code>right = mid</code> 还是 <code>left = mid</code>）。</li>
<li><strong>步骤 3</strong>：另一半条件放在 <code>else</code> 中。通常可以是 <code>left = mid + 1</code> 或 <code>right = mid - 1</code>。对于向上取整或其他情况可以调整 <code>mid</code> 计算方式。</li>
</ul>
<p><strong>边界处理</strong>：</p>
<ul>
<li>如果题目存在无解情况，可以在返回值上调整，比如上界增加 1 或下界减少 1，以表示没有找到符合条件的值。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><h4 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[right])<br>            right = mid;<br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[right];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= target)  <span class="hljs-comment">// 查找位置第一个 &gt;= target 的数</span><br>        right = mid;<br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(right);<br><br>left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)  <span class="hljs-comment">// 查找位置最后一个 &lt;= target 的数</span><br>        left = mid;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(right);<br><br><span class="hljs-keyword">if</span> (ans[<span class="hljs-number">0</span>] == ans[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>

<h4 id="平方根计算"><a href="#平方根计算" class="headerlink" title="平方根计算"></a>平方根计算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> left = <span class="hljs-number">1</span>, right = x;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (mid * mid &lt;= x) &#123;<br>        left = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br></code></pre></td></tr></table></figure>

<h4 id="实数平方根"><a href="#实数平方根" class="headerlink" title="实数平方根"></a>实数平方根</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myRealSqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-type">double</span> left = <span class="hljs-number">0</span>, right = x;<br>    <span class="hljs-keyword">while</span> (right - left &gt; <span class="hljs-number">1e-7</span>) &#123;<br>        <span class="hljs-type">double</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt;= x) &#123;<br>            left = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>三分查找的适用场景</strong>：</p>
<ul>
<li><strong>函数单峰性问题</strong>：三分查找常用于寻找某个函数的极值点，适用于函数在某区间内具有单峰性（即该函数在区间内只有一个极大值或极小值），且能够保证递增或递减的规律。</li>
<li><strong>核心思想</strong>：与二分查找类似，不同之处在于每次将区间分成三份，分别计算中间两点 <code>lmid</code> 和 <code>rmid</code>，通过比较 <code>f(lmid)</code> 和 <code>f(rmid)</code> 的大小，缩小搜索范围。</li>
</ul>
<p><strong>算法步骤</strong>：</p>
<ul>
<li><strong>比较两点</strong> <code>lmid</code> 和 <code>rmid</code> 的函数值：<ul>
<li>如果 <code>f(lmid) &lt; f(rmid)</code>，则极值位于 <code>lmid</code> 的右边（排除 <code>lmid</code> 左侧区间），所以更新左边界 <code>left = lmid + 1</code>。</li>
<li>否则，极值位于 <code>rmid</code> 的左边（排除 <code>rmid</code> 右侧区间），更新右边界 <code>right = rmid - 1</code>。</li>
</ul>
</li>
<li>不断重复上述过程，直到区间收缩到极值点。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> lmid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> rmid = (lmid + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[lmid] &lt;= nums[rmid]) <br>        left = lmid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>        right = rmid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br><br></code></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>该算法通过三分查找，逐渐缩小区间直到找到数组的峰值位置。</li>
<li>在单峰函数中，这种方法能有效找到极值点。</li>
</ul>
<hr>
<p>二分答案</p>
<p>二分答案的本质啊，就是去通过题目给的限制条件。建立一个单调分段，建立一个单调分段，零一函数啊，这个函数的。定义域是解空间，就答案值域是零或者一就是数，那么这个函数本身其实是。对这个限制的一个验证啊，一个判定。那么，通过这个函数，我们就可以在整个解上，对吧？这个。空间里边去二分查找这个分线点在什么地方，这就是我们要的答案。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><h4 id="分割数组问题："><a href="#分割数组问题：" class="headerlink" title="分割数组问题："></a>分割数组问题：</h4><p>将数组 <code>nums</code> 分成 <code>m</code> 个连续的子数组，使得这些子数组中的<strong>最大和</strong>最小，并保证划分是合理的（即尽量均匀）。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li>通过二分查找来求解最大和的最小值。</li>
<li><strong>初始范围</strong>：最小值为数组中的最大元素，最大值为数组所有元素的和。</li>
<li><strong>判定条件</strong>：给定一个划分值 <code>T</code>，判断能否将数组划分成不超过 <code>m</code> 个子数组，使得每个子数组的和都不大于 <code>T</code>。</li>
</ul>
<p><strong>判定函数</strong>：</p>
<ul>
<li>遍历数组，累加当前子数组的和 <code>sum</code>，一旦 <code>sum</code> 超过了 <code>T</code>，就开始划分新的一组，并重置 <code>sum</code>。</li>
<li>如果划分的组数超过了 <code>m</code>，则说明 <code>T</code> 不足够大，需要增大 <code>T</code>；否则，说明 <code>T</code> 是一个可行的值，尝试减小 <code>T</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数组中的最大值</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 数组所有元素的和</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canSplit</span>(nums, mid, m))<br>            right = mid;  <span class="hljs-comment">// 尝试减小最大值</span><br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 增大最大值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canSplit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> maxSum, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        <span class="hljs-keyword">if</span> (sum &gt; maxSum) &#123;  <span class="hljs-comment">// 如果当前子数组的和超过了允许的最大值</span><br>            sum = num;<br>            count++;  <span class="hljs-comment">// 划分出新的子数组</span><br>            <span class="hljs-keyword">if</span> (count &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="十四-排序"><a href="#十四-排序" class="headerlink" title="十四.排序"></a>十四.排序</h1><p>在 C++ 语言中，常见的排序算法可以分为基于比较的和非比较的两类。总结这些算法时，可以从算法的时间复杂度、空间复杂度以及适用场景的角度来进行编写。以下是每种排序算法的简要说明、代码实现和一些技巧：</p>
<h3 id="排序算法九宫格"><a href="#排序算法九宫格" class="headerlink" title="排序算法九宫格"></a>排序算法九宫格</h3><table>
<thead>
<tr>
<th><strong>时间复杂度</strong></th>
<th><strong>稳定</strong></th>
<th><strong>中立</strong></th>
<th><strong>不稳定</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>O(n²)</strong></td>
<td><strong>插入排序</strong>   有序规划水   一个个来嘛…</td>
<td><strong>冒泡排序</strong>   中立划水   交换一下…</td>
<td><strong>选择排序</strong>   混乱划水   随便找个最小的…</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td><strong>计数排序 &#x2F; 基数排序</strong>   不比较？那从数值范围入手吧   守序中立</td>
<td><strong>桶排序</strong>   绝对中立   我分个组，排序你们决定</td>
<td><strong>希尔排序</strong>   混乱中立   插入慢？增量分组插入吧</td>
</tr>
<tr>
<td><strong>O(n log n)</strong></td>
<td><strong>归并排序</strong>   守序内卷   nlogn 稳定可靠，合并有序   值得拥有</td>
<td><strong>堆排序</strong>   中立内卷   优化的基础算法…</td>
<td><strong>快速排序</strong>   混乱内卷   swap是门艺术，不服来快排</td>
</tr>
</tbody></table>
<h3 id="一、基于比较的排序"><a href="#一、基于比较的排序" class="headerlink" title="一、基于比较的排序"></a>一、基于比较的排序</h3><h4 id="1-交换类排序"><a href="#1-交换类排序" class="headerlink" title="1. 交换类排序"></a>1. 交换类排序</h4><p><strong>(1) 冒泡排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每一轮遍历可以把最大（或最小）的元素放在数组的末尾。</p>
<p><strong>(2) 快速排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(log n)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(arr, l, r);  <span class="hljs-comment">// 分区操作，得到分区点</span><br>        <span class="hljs-built_in">quickSort</span>(arr, l, pivot);  <span class="hljs-comment">// 递归排序左半部分</span><br>        <span class="hljs-built_in">quickSort</span>(arr, pivot + <span class="hljs-number">1</span>, r);  <span class="hljs-comment">// 递归排序右半部分</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = l + <span class="hljs-built_in">rand</span>() % (r - l + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 随机选择枢轴</span><br>        <span class="hljs-type">int</span> pivotVal = a[pivot];  <span class="hljs-comment">// 枢轴的值</span><br><br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">while</span> (a[l] &lt; pivotVal) l++;  <span class="hljs-comment">// 找到左边大于等于枢轴值的元素</span><br>            <span class="hljs-keyword">while</span> (a[r] &gt; pivotVal) r--;  <span class="hljs-comment">// 找到右边小于等于枢轴值的元素</span><br>            <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 左右指针相遇时停止</span><br>            <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>                <span class="hljs-comment">// 交换 a[l] 和 a[r]</span><br>                <span class="hljs-type">int</span> temp = a[l];<br>                a[l] = a[r];<br>                a[r] = temp;<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> r;  <span class="hljs-comment">// 返回分区位置</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过分治法将数组划分为较小的子数组，递归排序。</p>
<h4 id="2-插入类排序"><a href="#2-插入类排序" class="headerlink" title="2. 插入类排序"></a>2. 插入类排序</h4><p><strong>(1) 直接插入排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> key = arr[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合小规模数据集，具有局部性特点的数据性能较好。</p>
<p><strong>(2) 希尔排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> key = arr[i];<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;<br>                arr[j] = arr[j - gap];<br>                j -= gap;<br>            &#125;<br>            arr[j] = key;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过缩小增量逐步优化插入排序。</p>
<h4 id="3-选择类排序"><a href="#3-选择类排序" class="headerlink" title="3. 选择类排序"></a>3. 选择类排序</h4><p><strong>(1) 选择排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> minIdx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;<br>                minIdx = j;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每轮找到最小（或最大）值并交换到对应位置。</p>
<p><strong>(2) 堆排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// 将所有元素压入堆中，形成一个最大堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        q.<span class="hljs-built_in">push</span>(-a[i]);  <span class="hljs-comment">// 使用负值来模拟最小堆</span><br>    &#125;<br>    <span class="hljs-comment">// 将堆中的元素依次弹出，得到有序序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        a[i] = -q.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 取出最小值并存入数组</span><br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：利用堆结构维护最大或最小堆。</p>
<h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h4><ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建临时数组来存放合并后的结果</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 合并两个有序数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; temp.<span class="hljs-built_in">size</span>(); k++) &#123;<br>        <span class="hljs-keyword">if</span> (j &gt; right || (i &lt;= mid &amp;&amp; arr[i] &lt;= arr[j])) &#123;<br>            temp[k] = arr[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp[k] = arr[j++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将合并后的数组拷贝回原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; temp.<span class="hljs-built_in">size</span>(); k++) &#123;<br>        arr[left + k] = temp[k];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 计算中间位置</span><br>    <span class="hljs-built_in">mergeSort</span>(arr, left, mid);  <span class="hljs-comment">// 排序左半部分</span><br>    <span class="hljs-built_in">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, right);  <span class="hljs-comment">// 排序右半部分</span><br>    <span class="hljs-built_in">merge</span>(arr, left, mid, right);  <span class="hljs-comment">// 合并已排序的两部分</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：递归分割数组，合并时排序。</p>
<h3 id="二、非比较类排序"><a href="#二、非比较类排序" class="headerlink" title="二、非比较类排序"></a>二、非比较类排序</h3><h4 id="1-计数排序"><a href="#1-计数排序" class="headerlink" title="1. 计数排序"></a>1. 计数排序</h4><ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(k)</li>
<li>稳定性：稳定</li>
<li>适用于已知范围的整数排序，将每个数据作为键（key）存储在额外的数组中。通过统计每个数出现的次数，可以按序填充回原数组，从而完成排序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> max)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count[max + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> output[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[arr[i]]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[arr[i]] - <span class="hljs-number">1</span>] = arr[i];<br>        count[arr[i]]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合范围较小的整数排序。</p>
<h4 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2. 桶排序"></a>2. 桶排序</h4><ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
<li>将数据分布到有限数量的桶（bucket）中，每个桶内的数据再分别进行排序（可以用其他排序算法）。最后将各桶中的数据按顺序合并。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-type">float</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">float</span>&gt; buckets[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> idx = n * arr[i];<br>        buckets[idx].<span class="hljs-built_in">push_back</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::<span class="hljs-built_in">sort</span>(buckets[i].<span class="hljs-built_in">begin</span>(), buckets[i].<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;val : buckets[i]) &#123;<br>            arr[idx++] = val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合分布均匀的实数排序。</p>
<h4 id="3-基数排序"><a href="#3-基数排序" class="headerlink" title="3. 基数排序"></a>3. 基数排序</h4><ul>
<li>时间复杂度：O(nk)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
<li>将数据切割成一位一位的数字（通常为十进制位，0-9），从低位到高位依次对每一位进行计数排序（或从高位到低位）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSortForRadix</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> exp)</span> </span>&#123;<br>    <span class="hljs-type">int</span> output[n], count[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[(arr[i] / exp) % <span class="hljs-number">10</span>]++;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[(arr[i] / exp) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = arr[i];<br>        count[(arr[i] / exp) % <span class="hljs-number">10</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = <span class="hljs-built_in">getMax</span>(arr, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> exp = <span class="hljs-number">1</span>; max / exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) <span class="hljs-built_in">countingSortForRadix</span>(arr, n, exp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：按位排序，从低位到高位逐一处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>算法选择</strong>：根据数据的规模、分布特点选择合适的算法。快速排序在多数情况下表现良好，但对于极端情况可能退化；归并排序的稳定性和性能较优但占用额外空间；堆排序在处理大规模数据时表现优异。</li>
<li><strong>非比较排序</strong>：如计数排序、桶排序和基数排序，适合特定场景，通常用于整型或有范围限制的数据。</li>
</ul>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><h4 id="查找第-k-大元素"><a href="#查找第-k-大元素" class="headerlink" title="查找第 k 大元素"></a>查找第 <code>k</code> 大元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// quickSort 函数：用于查找在排序后位置为 index 的元素的值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> arr[l];<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(arr, l, r);<br>        <span class="hljs-keyword">if</span> (index == pivot) <span class="hljs-keyword">return</span> arr[pivot];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; pivot) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(arr, l, pivot - <span class="hljs-number">1</span>, index);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(arr, pivot + <span class="hljs-number">1</span>, r, index);<br>    &#125;<br><br>    <span class="hljs-comment">// partition 函数：分区操作，返回分区位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = l + <span class="hljs-built_in">rand</span>() % (r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> pivotVal = a[pivot];<br><br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">while</span> (a[l] &lt; pivotVal) l++;<br>            <span class="hljs-keyword">while</span> (a[r] &gt; pivotVal) r--;<br>            <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> temp = a[l];<br>                a[l] = a[r];<br>                a[r] = temp;<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="翻转对"><a href="#翻转对" class="headerlink" title="翻转对"></a>翻转对</h4><p>题目要求在一个数组中找到满足条件 <code>nums[i] &gt; 2 * nums[j]</code> 的所有下标对 <code>(i, j)</code>，其中 <code>i &lt; j</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ans;  <span class="hljs-comment">// 全局变量，记录翻转对数量</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr, l, mid);<br>        <span class="hljs-built_in">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">calculate</span>(arr, l, mid, r);<br>        <span class="hljs-built_in">merge</span>(arr, l, mid, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= mid; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt;= right &amp;&amp; arr[i] &gt; <span class="hljs-number">2LL</span> * arr[j]) j++;<br>            ans += j - (mid + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 累加符合条件的对数</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) temp[k++] = arr[i++];<br>            <span class="hljs-keyword">else</span> temp[k++] = arr[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temp.<span class="hljs-built_in">size</span>(); i++) arr[left + i] = temp[i];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h1 id="十五-贪心"><a href="#十五-贪心" class="headerlink" title="十五. 贪心"></a>十五. 贪心</h1><p><strong>贪心算法成立的条件</strong>：</p>
<ul>
<li>题目属于“零钱兑换”类型问题，当纸币面值互相构成倍数关系时，贪心算法有效。</li>
</ul>
<p><strong>面值分析</strong>：</p>
<ul>
<li>在本题中，面值为 5、10、20。</li>
<li>如果可以使用 1 张 10 元纸币找零，那么就一定可以用 2 张 5 元纸币找零。这种情况下选择使用 10 元纸币可以保留 5 元纸币，为后续找零提供更大的灵活性。</li>
</ul>
<p><strong>决策包容性</strong>：</p>
<ul>
<li>选择用 10 元纸币找零的决策，未来的可能性包含了“用 2 个 5 元找零”的选项，从而提高后续的找零可能性。这种决策能够包容更多的情况，确保找零的成功率。</li>
</ul>
<p><strong>贪心策略</strong>：</p>
<ul>
<li>本题的贪心策略是<strong>优先使用面值较大的纸币找零</strong>，从而为后续的找零预留更多的可能性。</li>
</ul>
<p>贪心算法的优缺点</p>
<ul>
<li><strong>优点</strong>：贪心算法通常比动态规划等复杂算法更简单，执行速度快，适合解决可以一步步逼近最优解的问题。</li>
<li><strong>缺点</strong>：贪心算法并不总是能够得到最优解，尤其在问题需要考虑全局情况时，贪心可能会因为只关注局部而错过最佳解。</li>
</ul>
<h3 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h3><h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>; <br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对孩子的胃口值排序</span><br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对饼干的大小排序</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 饼干索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> child : g) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] &lt; child) j++; <span class="hljs-comment">// 找到满足当前孩子胃口的饼干</span><br>            <span class="hljs-keyword">if</span> (j &lt; s.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 如果找到满足条件的饼干</span><br>                ans++; <span class="hljs-comment">// 满足一个孩子</span><br>                j++; <span class="hljs-comment">// 使用一块饼干</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h4 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h4><p>假设你是一位很慷慨的家长，想要给孩子们一些小饼干。但是，每个孩子最多只能得到一块饼干。</p>
<ul>
<li>每个孩子都有一个胃口值 <code>g[i]</code>，代表满足这个孩子所需的饼干大小。</li>
<li>每块饼干的大小用 <code>s[j]</code> 表示。</li>
<li>只有当饼干的大小 <code>s[j] &gt;= g[i]</code> 时，这块饼干才能满足孩子的胃口。</li>
</ul>
<p>你的目标是尽可能满足最多数量的孩子，并输出这个最大数值。</p>
<p>示例</p>
<ul>
<li><strong>示例 1</strong>：<ul>
<li><strong>输入</strong>：<code>g = [1, 2, 3]</code>, <code>s = [1, 1]</code></li>
<li><strong>输出</strong>：<code>1</code></li>
<li><strong>解释</strong>：你有 3 个孩子，胃口值分别是 1、2、3，有 2 块饼干，大小都是 1。只能满足胃口值为 1 的孩子，所以输出 1。</li>
</ul>
</li>
<li><strong>示例 2</strong>：<ul>
<li><strong>输入</strong>：<code>g = [1, 2]</code>, <code>s = [1, 2, 3]</code></li>
<li><strong>输出</strong>：<code>2</code></li>
<li><strong>解释</strong>：你有 2 个孩子，胃口值分别是 1、2，有 3 块饼干，大小分别是 1、2、3。可以满足所有孩子的需求，所以输出 2。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>; <br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对孩子的胃口值排序</span><br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对饼干的大小排序</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 饼干索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> child : g) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] &lt; child) j++; <span class="hljs-comment">// 找到满足当前孩子胃口的饼干</span><br>            <span class="hljs-keyword">if</span> (j &lt; s.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 如果找到满足条件的饼干</span><br>                ans++; <span class="hljs-comment">// 满足一个孩子</span><br>                j++; <span class="hljs-comment">// 使用一块饼干</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*贪心算法成立的条件：</span><br><span class="hljs-comment">问题类型：本题属于资源分配问题，与零钱找零问题类似，目标是尽可能满足需求。贪心算法在这种情况下有效，因为我们希望通过合理分配资源来满足尽可能多的孩子。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">条件满足：在本题中，每个孩子只能得到一块饼干，并且不同饼干大小是可以互相满足的（一个大饼干既可以满足小胃口的孩子，也可以满足大胃口的孩子）。因此，通过贪心算法优先满足小胃口的孩子，就能将剩余的大饼干留给更需要的大胃口孩子，提升满足总人数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">面值分析（在本题中的对应）：</span><br><span class="hljs-comment">胃口大小与饼干大小分析：</span><br><span class="hljs-comment">孩子的胃口值数组 g 和饼干大小数组 s 都按从小到大的顺序排序。</span><br><span class="hljs-comment">如果能够用一个较小的饼干满足小胃口的孩子，那么这块饼干必然也能满足所有比该孩子胃口更小的孩子。因此，优先使用小饼干满足小胃口的孩子可以最大化满足需求，并留出更多大的饼干给大胃口的孩子。</span><br><span class="hljs-comment">决策包容性：</span><br><span class="hljs-comment">包容性分析：</span><br><span class="hljs-comment">在选择分配饼干时，优先选择满足小胃口的孩子，确保我们把最小的饼干分配给最适合的孩子。这样即使后续需求更大，我们仍然保有较大饼干以满足较高的需求。</span><br><span class="hljs-comment">这种选择包含了未来的可能性（即更大胃口的孩子仍能得到较大的饼干），确保资源利用最大化，增加整体满足的可能性。</span><br><span class="hljs-comment">贪心策略：</span><br><span class="hljs-comment">贪心策略：在分配时，优先分配小饼干给小胃口的孩子，尽可能满足最小需求，从而将较大的资源保留给更高需求的情况。这样可以提高整体满足率，实现题目目标。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h4><p>给定一个数组 <code>prices</code>，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格。 你可以尽可能多次买卖股票（多次买入和卖出）。但在再次买入之前，必须先卖出股票。</p>
<p>目标是设计一个算法来计算能够获得的最大利润。</p>
<p>示例</p>
<ul>
<li><p><strong>示例 1</strong>：</p>
<ul>
<li><p><strong>输入</strong>：<code>prices = [7, 1, 5, 3, 6, 4]</code></p>
</li>
<li><p><strong>输出</strong>：<code>7</code></p>
</li>
<li><p>解释</p>
<p>：</p>
<ul>
<li>第 2 天买入（价格 &#x3D; 1），第 3 天卖出（价格 &#x3D; 5），利润 &#x3D; 5 - 1 &#x3D; 4。</li>
<li>第 4 天买入（价格 &#x3D; 3），第 5 天卖出（价格 &#x3D; 6），利润 &#x3D; 6 - 3 &#x3D; 3。</li>
<li>总利润 &#x3D; 4 + 3 &#x3D; 7。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.size(); i++)<br>            ans += max(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果今天价格比前一天高，累加差价</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*贪心算法成立的条件：</span><br><span class="hljs-comment">问题类型：这道题属于“买卖股票获取最大利润”的问题，贪心算法在此有效，因为我们可以通过逐步累加上涨带来的收益来达到全局最优解。</span><br><span class="hljs-comment">条件满足：本题中的股票价格每天都有波动，而我们只需要在上涨的天数间进行买卖操作，每次交易可以获得正收益。因此，只要每天的价格有增长，我们都可以进行交易，这样能实现局部最优，从而累加得到全局最优。</span><br><span class="hljs-comment">面值分析（在本题中的对应）：</span><br><span class="hljs-comment">股票价格的分析：</span><br><span class="hljs-comment">在本题中，股票价格每天都有一个涨跌，我们关心的是价格差价，即 prices[i] - prices[i - 1]。</span><br><span class="hljs-comment">如果某一天的价格比前一天高，我们将这一天的差价计入总利润。这相当于“把每次的盈利都加入总收益中”，类似于零钱找零问题中保留小面额的选择，这样可以实现更多的收益。</span><br><span class="hljs-comment">决策包容性：</span><br><span class="hljs-comment">包容性分析：</span><br><span class="hljs-comment">通过只在价格上涨的日子进行买卖，我们将每个上涨的收益都加入总利润，这样可以确保不会错过任何一个盈利的机会。也就是说，“今天上涨带来的收益”包含了未来可能持续上涨的机会，确保我们不会因为今天不买卖而错失收益。</span><br><span class="hljs-comment">这种决策能够确保每次交易都有效益，从而在所有可能的上涨日中获得最大总收益。</span><br><span class="hljs-comment">贪心策略：</span><br><span class="hljs-comment">贪心策略：本题的贪心策略是在每次有上涨时就立即买卖以获取收益，这样可以在每个上涨的日子里获利，确保收益最大化。</span><br><span class="hljs-comment">通过这种贪心策略，我们不需要等待或预测价格的更大变化，而是逐步累加每次上涨的差价，从而获得最大的总利润。</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure>

<h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h4><p>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个位置。数组中的每个元素表示你在该位置可以跳跃的最大长度。目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例</p>
<ul>
<li><strong>示例 1</strong>：<ul>
<li><strong>输入</strong>：<code>nums = [2,3,1,1,4]</code></li>
<li><strong>输出</strong>：<code>2</code></li>
<li><strong>解释</strong>：跳到最后一个位置的最小跳跃数是 2。可以先从索引 0 跳到索引 1，再从索引 1 跳到最后一个位置。</li>
</ul>
</li>
<li><strong>示例 2</strong>：<ul>
<li><strong>输入</strong>：<code>nums = [2,3,0,1,4]</code></li>
<li><strong>输出</strong>：<code>2</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span> (now &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> right = now + nums[now]; <span class="hljs-comment">// 当前能跳到的最远范围</span><br>            <span class="hljs-keyword">if</span> (right &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果可以直接跳到最后，返回答案+1</span><br>            <br>            <span class="hljs-type">int</span> nextRight = right;<br>            <span class="hljs-type">int</span> next = now;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123; <span class="hljs-comment">// 在当前能跳到的范围内选择最优的下一跳位置</span><br>                <span class="hljs-keyword">if</span> (i + nums[i] &gt; nextRight) &#123; <span class="hljs-comment">// 更新最远跳跃位置</span><br>                    nextRight = i + nums[i];<br>                    next = i;<br>                &#125;<br>            &#125;<br>            now = next; <span class="hljs-comment">// 更新当前位置</span><br>            ans++; <span class="hljs-comment">// 增加跳跃次数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*贪心策略：</span><br><span class="hljs-comment">在每一步跳跃中，选择当前可以跳到的范围内的最远位置，从而确保每次跳跃后可以达到更大的范围。</span><br><span class="hljs-comment">假设位置 a 可以跳到 b1、b2、b3，而这些位置 b1、b2、b3 各自的最远跳跃位置为 c1、c2、c3。此时应该从 a 跳到能够达到最远位置的那个 b，这样可以保证未来的跳跃范围最大。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">决策包容性：</span><br><span class="hljs-comment">选择从 a 跳到“能跳得更远”的 b，因为这个选择确保未来的可达集合包含了其他跳跃选择的可达位置。这种策略即使不考虑未来的所有可能情况，也能保证当前选择的合理性。</span><br><span class="hljs-comment">简单来说，这种局部最优的决策能够带来全局最优的结果。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">贪心策略</span><br><span class="hljs-comment">贪心策略：本题的贪心策略是在每一步中选择能够跳到最远的范围。通过这种逐步扩展跳跃范围的方式，每一步都接近终点，从而减少总的跳跃次数，实现最小步数。</span><br></code></pre></td></tr></table></figure>

<p>我们来看第三种证明方法，就是邻向交换法。用于求一个顺序的题目，这个题目本身是让你求一种顺序，按这个顺序去完成一些任务，就是我在任意局面下啊。我向着违反这个顺序的方向就是逆序去给它局部连向交换一下，那我证明无论什么情况下，只要沿着逆袭方向走，就会答案变差就可以证明，那么是不是永远是不管在什么地方我都应该向着有序的方向去给它行走?那么大家其实可以想在数学上，其实任何事物那么你在任意的函数点上任何事情都是一个函数是不是也是一个这个评估也是一个函数?你给它向着无序的方向走一下，那是不是你应该向有序的方向觉?这样最终会潜落在哎一个函数，这样最终会潜落在哎一个函数，我去向无序的方向去交换，那么是不是我不断的去把把逆序变有序?既然我们就是任何时候交换局部的逆序变有序会变好，是不是那么最终一定会是有序的</p>
<h1 id="十六-动态规划"><a href="#十六-动态规划" class="headerlink" title="十六.动态规划"></a>十六.动态规划</h1><p><strong>动态规划定义</strong>：</p>
<ul>
<li>动态规划是一种对问题的状态空间进行分阶段的、按顺序、无重复的遍历的决策性遍历算法。蛮力搜索 —(同类子问题)—&gt;分治 —(最优子结构)—&gt;动态规划，这才是一条自然的解题</li>
</ul>
<p><strong>动态规划的三大关键性质</strong>：</p>
<ul>
<li><strong>重叠子问题</strong>：与递归和分治相似，动态规划要解决的子问题是重复出现的，适合用状态表示和记录。</li>
<li><strong>最优子结构</strong>：状态应对应一个最优化目标，并且各个子目标之间存在推导关系，使得整体目标可以通过各子目标的最优解得出。</li>
<li><strong>无后效性</strong>：问题的状态空间是一个无向无环图，可以按一定的顺序遍历解决。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li>动态规划一般采用递推方式实现，也可以通过递归或记忆化搜索的方式进行。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">opt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化：兑换金额为0时，不需要任何硬币</span><br><br><span class="hljs-comment">// 阶段（线性增长）：从1逐步增加到目标金额amount</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>    opt[i] = INF; <span class="hljs-comment">// 设置当前金额i的最少硬币数量为一个极大值（用INF表示），方便后续比较取最小值</span><br><br>    <span class="hljs-comment">// 决策（找到子问题）：遍历每个硬币面值，找到凑成当前金额的最优方案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<br>        <span class="hljs-keyword">if</span> (i - coins[j] &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 判断是否可以用当前硬币凑成当前金额</span><br>            <span class="hljs-comment">// 状态（具有最优子结构）：选择最小的硬币数量，确保当前金额的最优解</span><br>            opt[i] = Math.<span class="hljs-built_in">min</span>(opt[i], opt[i - coins[j]] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*无论是递推实现还是记忆化搜索(递归实现)这种定义状态+最优子结构+推导关系的解题方法其实就是 动态规划 算法</span><br><span class="hljs-comment">1.问题定义：</span><br><span class="hljs-comment">设 opt[i] 表示凑成金额 i 所需的最少硬币数量。确定“状态”的原则:寻找变化信息</span><br><span class="hljs-comment">2.状态转移方程：</span><br><span class="hljs-comment">对于每个金额 i，我们可以通过以下公式计算 opt[i]：opt[i] = min&#123;opt[i - coin] + 1&#125; 确定“最优子结构”的原则:寻找代表</span><br><span class="hljs-comment">3.边界：opt[0]=0,opt[i]=+∞(i&gt;0)</span><br><span class="hljs-comment">4.目标：opt[amount]</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>人力模拟 &#x2F; 暴力搜索</strong>：</p>
<ul>
<li>目的是通过手动模拟问题解决过程，理解如何遍历所有可能的状态和情况。</li>
<li>关注点：<strong>轮廓变化</strong>，分析状态如何从一个转移到另一个。我们是不是考虑在列表时候就是一个行一个列，它们往后推移,因此ij作为一个状态。lcs呢?选哪个数刚选的这个末尾是不是一个位置把这个轮廓描述一下表示字符串 <code>text1</code> 的每个字符位置，列表示字符串 <code>text2</code> 的每个字符位置。每个格子 <code>(i, j)</code> 的值代表 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的LCS长度。我们从左上角 <code>(0, 0)</code> 开始计算，逐步填充整个矩阵，一直到右下角的 <code>(n, m)</code>，最终结果即 <code>f[n][m]</code>，作为一个状态之后，把决策写好，这个题目就做完了。它整体的一个变化情况就可以得到我们这个题目的转移方程了。</li>
</ul>
<p><strong>定义状态</strong>：递增循环每一维啊,</p>
<ul>
<li>确定用什么变量或数组来表示问题中的不同状态。</li>
<li>关注点：<strong>代表</strong>（如代表某个位置、子问题的解等），以及状态之间的推导关系。</li>
</ul>
<p><strong>确定最优子结构</strong>：</p>
<ul>
<li>通过找到小问题的最优解来组成大问题的最优解。</li>
<li>关注点：手动模拟时做出的决策，观察这些决策如何影响最终解。</li>
</ul>
<p><strong>写出状态转移方程</strong>：</p>
<ul>
<li>根据之前定义的状态，写出如何从一个状态转移到另一个状态，形成递推关系。</li>
</ul>
<p><strong>确定边界、目标和实现</strong>：</p>
<ul>
<li>确定边界条件（如起点和结束点）和不合法的状态。</li>
<li>目标是找到最终要求的解，并根据状态转移方程使用循环或递归来实现求解。</li>
</ul>
<p>例外</p>
<p>动态规划打印方案的原则</p>
<ol>
<li><strong>记录转移路径</strong>：在动态规划的计算过程中，我们不仅要记录每个状态的最优值，还需要记录每个状态的转移来源</li>
<li><strong>递归输出</strong>：在填完整个动态规划表格后，从终点（如 <code>f[n][m]</code>）开始，沿着记录的路径递归地输出最优方案</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// f[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// pre[i] 用于记录最长子序列中 nums[i] 的前一个元素的索引</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; f[i] &lt; f[j] + <span class="hljs-number">1</span>) &#123;<br>                    f[i] = f[j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新 f[i] 为以 nums[i] 结尾的最长子序列的长度</span><br>                    pre[i] = j; <span class="hljs-comment">// 记录转移路径，将 nums[i] 的前驱设置为 nums[j]</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, end = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (f[i] &gt; ans) &#123;<br>                ans = f[i];<br>                end = i; <span class="hljs-comment">// 记录最长子序列的最后一个元素的索引</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">print</span>(nums, pre, end); <span class="hljs-comment">// 输出最长递增子序列</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 基本情况：如果没有前驱，直接返回</span><br>        <span class="hljs-built_in">print</span>(nums, pre, pre[i]); <span class="hljs-comment">// 递归回溯，输出子序列</span><br>        std::cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出当前元素</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>空间的优化<br>仔细观察状态转移方程，fi?,?,?]总是从f[i-1)?,?,?]转移过来，与更早的i-2,i-3,…. 没有关系如果把每个 fi]看作一行，那么转移只在相邻两行之间发生这种情况下可以使用滚动数组优化,实现中，先不优化，写完以后在每个f的第一维加个&amp;1(and1，即 mod 2)注意初始化复用的空间</p>
<p>零钱兑换”的最优子结构</p>
<p><strong>目标</strong>：找到兑换某个金额所需的最少硬币数量，形成最优的硬币兑换方案。</p>
<p><strong>状态定义</strong>：</p>
<ul>
<li>记录当前的“剩余金额”和“已用硬币枚数”。</li>
<li>新状态目标为“剩余金额”以及在硬币数量最少的前提下达到目标。</li>
</ul>
<p><strong>推导关系</strong>：</p>
<ul>
<li>递推公式为：opt(n) &#x3D; min(opt(n - 1), opt(n - 9), opt(n - 10)) + 1。</li>
<li>其中，<code>opt(n)</code>表示兑换金额为n元时所需的最少硬币数，<code>opt(n - 1)</code>, <code>opt(n - 9)</code>, <code>opt(n - 10)</code>分别代表使用1元、9元和10元硬币时的剩余情况。</li>
</ul>
<p><strong>最优子结构</strong>：</p>
<ul>
<li>通过递推关系，可以在状态、最优化目标、最优解之间建立递归关系，实现零钱兑换的最优解。就是因为我们提炼搜索结构，不要去盲目的根据所有方案。而是我们去只遍历，只要那一个最有解的哎，</li>
</ul>
<h4 id="“最长公共子序列”（LCS）"><a href="#“最长公共子序列”（LCS）" class="headerlink" title="“最长公共子序列”（LCS）"></a>“最长公共子序列”（LCS）</h4><p><strong>定义</strong>：</p>
<ul>
<li>f[i,j]f[i, j]f[i,j] 表示 <code>text1</code> 的前 iii 个字符和 <code>text2</code> 的前 jjj 个字符能组成的最长公共子序列（LCS）的长度。</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li>当 <code>text1[i]</code> 等于 <code>text2[j]</code> 时：f[i,j]&#x3D;f[i−1,j−1]+1f[i, j] &#x3D; f[i-1, j-1] + 1f[i,j]&#x3D;f[i−1,j−1]+1。</li>
<li>当 <code>text1[i]</code> 不等于 <code>text2[j]</code> 时：f[i,j]&#x3D;max⁡(f[i−1,j],f[i,j−1])f[i, j] &#x3D; \max(f[i-1, j], f[i, j-1])f[i,j]&#x3D;max(f[i−1,j],f[i,j−1])。</li>
</ul>
<p><strong>边界处理技巧</strong>：</p>
<ul>
<li>方法一：将 f[0,0]&#x3D;0f[0, 0] &#x3D; 0f[0,0]&#x3D;0 作为初始条件，然后在递推过程中用 <code>if</code> 语句进行判断。</li>
<li>方法二：假设字符串下标从 1 开始，设置 f[i,0]&#x3D;0f[i, 0] &#x3D; 0f[i,0]&#x3D;0 和 f[0,j]&#x3D;0f[0, j] &#x3D; 0f[0,j]&#x3D;0 作为边界条件。</li>
</ul>
<p><strong>目标</strong>：</p>
<ul>
<li>计算 f[n,m]f[n, m]f[n,m]，即 <code>text1</code> 和 <code>text2</code> 的最长公共子序列的长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(std::string text1, std::string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text<span class="hljs-number">1.l</span>ength();<br>        <span class="hljs-type">int</span> n = text<span class="hljs-number">2.l</span>ength();<br>        std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="最长上升子序列（LIS）"><a href="#最长上升子序列（LIS）" class="headerlink" title="最长上升子序列（LIS）"></a>最长上升子序列（LIS）</h4><p><strong>问题定义</strong>：</p>
<ul>
<li>设 <code>f[i]</code> 表示前 <code>i</code> 个数构成的、以 <code>a[i]</code> 为结尾的最长上升子序列的长度。</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li>对于每个位置 <code>i</code>，我们遍历之前的所有位置 <code>j</code>（<code>j &lt; i</code>），如果 <code>a[j] &lt; a[i]</code>，则可以将 <code>a[i]</code> 接在以 <code>a[j]</code> 结尾的上升子序列后面，公式如下： f[i]&#x3D;max⁡(f[i],f[j]+1)f[i] &#x3D; \max(f[i], f[j] + 1)f[i]&#x3D;max(f[i],f[j]+1)</li>
<li>其中，<code>f[i]</code> 是以 <code>a[i]</code> 结尾的最长上升子序列长度。</li>
</ul>
<p><strong>边界</strong>：</p>
<ul>
<li>初始情况下，每个位置的最长上升子序列长度至少为1，即 <code>f[i] = 1</code>。(0 ≤i&lt;n)</li>
</ul>
<p><strong>目标</strong>：</p>
<ul>
<li>找到所有 <code>f[i]</code> 中的最大值，即： max⁡0≤i&lt;nf[i]\max_{0 \leq i &lt; n} f[i]0≤i&lt;nmaxf[i]</li>
<li>这个最大值即为整个序列的最长上升子序列长度。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 初始化每个位置的最长上升子序列长度为1</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>; <span class="hljs-comment">// 最长上升子序列的最终结果</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>                    f[i] = std::<span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新f[i]为以nums[i]为结尾的最长上升子序列长度</span><br>                &#125;<br>            &#125;<br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[i]); <span class="hljs-comment">// 更新全局最长长度</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h4 id="路径计数"><a href="#路径计数" class="headerlink" title="路径计数"></a>路径计数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> &#123;<br>    <span class="hljs-type">int</span> n = grid.size();            <span class="hljs-comment">// 行数</span><br>    <span class="hljs-type">int</span> m = grid[<span class="hljs-number">0</span>].size();          <span class="hljs-comment">// 列数</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; f(n, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 创建二维数组f并初始化为0</span><br><br>    <span class="hljs-comment">// 遍历每个网格位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 如果当前格子有障碍物，路径数为0</span><br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                f[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// 起点 (0, 0) 路径数为1（前提是没有障碍物）</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 第一行时，只能从左边到达</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 第一列时，只能从上面到达</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>            <span class="hljs-comment">// 其他情况，路径数等于从上方和左侧位置到达的路径数之和</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回到达终点 (n-1, m-1) 的路径数</span><br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>状态定义</p>
<ul>
<li>设 <code>f[i]</code> 表示<strong>以 <code>i</code> 为结尾</strong>的最大子序和。</li>
</ul>
<p>状态转移方程</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span> + nums<span class="hljs-selector-attr">[i]</span>, nums<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<p>其中，<code>f[i - 1] + nums[i]</code> 表示将 <code>nums[i]</code> 加入到前面的子序列中，继续延续子序和；<code>nums[i]</code> 表示以当前元素 <code>nums[i]</code> 开始一个新的子序列。</p>
<p>边界条件</p>
<p><code>f[0] = nums[0]</code>，因为以第一个元素结尾的最大子序和就是第一个元素的值。</p>
<p>目标</p>
<p>计算 max(f[i])</p>
<p>关于“包含结尾”的原因</p>
<ul>
<li>在这个问题中，状态 <code>f[i]</code> 是以 <code>i</code> 为结尾的子序列的最大和，这样可以确保子序列是连续的。</li>
<li>通过 <code>f[i - 1]</code> 决定是否延续之前的序列，从而达到最大和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// f[i] 表示以 nums[i] 结尾的最大子序和</span><br>        f[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 边界条件：以第一个元素结尾的最大子序和就是它自身</span><br>        <span class="hljs-type">int</span> ans = f[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最大子序和为第一个元素</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            f[i] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>) + nums[i]; <span class="hljs-comment">// 状态转移方程</span><br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[i]); <span class="hljs-comment">// 更新全局最大子序和</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><p>问题定义</p>
<ul>
<li>给定一个数组，找到一个具有最大乘积的连续子数组，返回该最大乘积。</li>
</ul>
<p>状态定义</p>
<ul>
<li><p>设 <code>fmax[i]</code> 表示以 <code>i</code> 为结尾的子数组的<strong>乘积最大值</strong>。</p>
</li>
<li><p>设 <code>fmin[i]</code> 表示以 <code>i</code> 为结尾的子数组的<strong>乘积最小值</strong>。</p>
<p>使用 <code>fmax</code> 和 <code>fmin</code> 一起作为代表，以保证每一步都能满足最优子结构。原因是，当当前数 <code>nums[i]</code> 为负数时，乘以之前的最小值可能会变成最大值，所以需要同时维护最大和最小值。</p>
</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><code>fmax[i] = max(fmax[i - 1] * nums[i], fmin[i - 1] * nums[i], nums[i])</code></li>
<li><code>fmin[i] = min(fmax[i - 1] * nums[i], fmin[i - 1] * nums[i], nums[i])</code><ul>
<li><code>fmax[i]</code> 是当前最大乘积，取决于前一个最大乘积乘以当前数、前一个最小乘积乘以当前数，或者当前数本身。</li>
<li><code>fmin[i]</code> 是当前最小乘积，原因是负数可能会将最小值转化为最大值，因此也需要考虑。</li>
</ul>
</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>fmax[0] = nums[0]</code></li>
<li><code>fmin[0] = nums[0]</code></li>
</ul>
<p>目标</p>
<ul>
<li>求 <code>max(fmax[i])</code>，其中 <code>0 &lt;= i &lt; n</code>，即最大乘积。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fmax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">fmin</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// fmax[i] 和 fmin[i] 分别表示以 nums[i] 结尾的最大和最小乘积</span><br>        fmax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        fmin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最大乘积为第一个元素</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            fmax[i] = std::<span class="hljs-built_in">max</span>(&#123;fmax[i - <span class="hljs-number">1</span>] * nums[i], fmin[i - <span class="hljs-number">1</span>] * nums[i], nums[i]&#125;);<br>            fmin[i] = std::<span class="hljs-built_in">min</span>(&#123;fmax[i - <span class="hljs-number">1</span>] * nums[i], fmin[i - <span class="hljs-number">1</span>] * nums[i], nums[i]&#125;);<br>            ans = std::<span class="hljs-built_in">max</span>(ans, fmax[i]); <span class="hljs-comment">// 更新全局最大乘积</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h4><p>状态定义</p>
<p>设 f[i][j][k]表示在第 i 天结束时，持有 j 股股票（j为 0 或 1），已经完成了 k次交易的最大收益。</p>
<ul>
<li><code>i</code>：第几天。</li>
<li><code>j</code>：是否持有股票（0 表示不持有，1 表示持有）。</li>
<li><code>k</code>：已经完成的交易次数。</li>
</ul>
<p>决策转移</p>
<ul>
<li><p>买入</p>
<p>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span>, f<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k-1]</span> - prices<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>如果在第 <code>i</code> 天选择买入股票，那么前一天的状态应该是不持有股票且已完成 <code>k-1</code> 次交易，并减去当天的价格 <code>prices[i]</code>。</li>
</ul>
</li>
<li><p>卖出</p>
<p>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k]</span>, f<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span> + prices<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>如果在第 <code>i</code> 天选择卖出股票，那么前一天的状态应该是持有股票且已完成 <code>k</code> 次交易，卖出后增加当天的价格 <code>prices[i]</code>。</li>
</ul>
</li>
<li><p>保持</p>
<p>：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[k]</span> = f<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[k]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>不进行买卖操作，保持前一天的状态。</li>
</ul>
</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>f[0][0][0] = 0</code> 表示在第 0 天，没有进行任何交易且不持有股票的情况下，利润为 0。</li>
<li>其余的边界值都初始化为负无穷，表示在开始时这些状态不合法或不可达。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> c, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 移动索引到1开始</span><br>        prices.<span class="hljs-built_in">insert</span>(prices.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 定义 f 数组并初始化为负无穷</span><br>        <span class="hljs-comment">// f[i][j][k] 表示第 i 天，持有 j (0 或 1) 股股票，已经交易了 k 次的最大收益</span><br>        std::vector&lt;std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">2</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c + <span class="hljs-number">1</span>, <span class="hljs-number">-1e9</span>)));<br>        <br>        <span class="hljs-comment">// 边界条件</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历所有状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= c; k++) &#123;<br>                    <span class="hljs-comment">// 决策：不操作</span><br>                    f[i][j][k] = std::<span class="hljs-built_in">max</span>(f[i][j][k], f[i - <span class="hljs-number">1</span>][j][k]);<br>                    <br>                    <span class="hljs-comment">// 决策：买入</span><br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                        f[i][<span class="hljs-number">1</span>][k] = std::<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">1</span>][k], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k - <span class="hljs-number">1</span>] - prices[i]);<br>                    &#125;<br>                    <br>                    <span class="hljs-comment">// 决策：卖出</span><br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                        f[i][<span class="hljs-number">0</span>][k] = std::<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>][k], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k] + prices[i]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到最大的收益</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= c; k++) &#123;<br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[n][<span class="hljs-number">0</span>][k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><p>问题描述</p>
<ul>
<li>给定一排房子，每个房子都有一定的现金。如果两个相邻的房子都被盗，就会触发报警系统。求在不触发报警的情况下能够盗取的最大金额。</li>
</ul>
<p>状态定义</p>
<ul>
<li>设 f[i][j] 表示在第 i个房子时的最大收益：<ul>
<li><code>j = 0</code> 表示未盗窃第 <code>i</code> 个房子。</li>
<li><code>j = 1</code> 表示盗窃第 <code>i</code> 个房子。</li>
</ul>
</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><code>f[i][0] = max(f[i - 1][0], f[i - 1][1])</code>：如果第 <code>i</code> 个房子没有被盗窃，那么最大收益就是前一个房子的状态（不管前一个房子是否被盗）。</li>
<li><code>f[i][1] = f[i - 1][0] + nums[i]</code>：如果第 <code>i</code> 个房子被盗窃，那么前一个房子一定没有被盗窃。</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>f[0][0] = 0</code>：第一个房子不偷的收益为 0。</li>
<li><code>f[0][1] = nums[0]</code>：第一个房子偷的收益为 <code>nums[0]</code>。</li>
</ul>
<p>目标</p>
<ul>
<li>计算 <code>max(f[n][0], f[n][1])</code>，其中 <code>n</code> 是房子的数量，这样可以得到在最后一个房子时的最大收益。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 为方便使用1基索引，我们在开头插入0</span><br>        nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 定义f数组，并初始化为负无穷大（表示不可达状态）</span><br>        std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1e9</span>));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界条件，第0天不偷的收益为0</span><br><br>        <span class="hljs-comment">// 动态规划填表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 不偷第i个房子</span><br>            f[i][<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// 偷第i个房子</span><br>            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最后一天不偷或偷的最大收益</span><br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(f[n][<span class="hljs-number">0</span>], f[n][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，计算将 <code>word1</code> 转换成 <code>word2</code> 所使用的最小操作数。可以对字符串执行以下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p>状态定义</p>
<p>设 <code>f[i][j]</code> 表示 <code>word1</code> 前 <code>i</code> 个字符和 <code>word2</code> 前 <code>j</code> 个字符之间的编辑距离（最小操作数）。</p>
<p>状态转移方程</p>
<ul>
<li><strong>插入操作</strong>：<code>f[i][j] = f[i][j - 1] + 1</code><ul>
<li>相当于在 <code>word1</code> 中第 <code>i</code> 个位置插入 <code>word2[j]</code>，所以 <code>j</code> 减 1 后计算剩余的编辑距离，再加上插入操作的1。</li>
</ul>
</li>
<li><strong>删除操作</strong>：<code>f[i][j] = f[i - 1][j] + 1</code><ul>
<li>相当于删除 <code>word1[i]</code>，因此 <code>i</code> 减 1 后计算剩余的编辑距离，再加上删除操作的1。</li>
</ul>
</li>
<li><strong>替换操作</strong>（或不变）：<code>f[i][j] = f[i - 1][j - 1] + eq</code>，其中 <code>eq = 0</code> 或 <code>1</code><ul>
<li>如果 <code>word1[i]</code> 与 <code>word2[j]</code> 相等，<code>eq = 0</code>；否则，<code>eq = 1</code>，因为需要一次替换操作。</li>
</ul>
</li>
</ul>
<p>初始条件</p>
<ul>
<li><code>f[i][0] = i</code>：将 <code>word1</code> 的前 <code>i</code> 个字符转化为一个空字符串需要 <code>i</code> 次删除操作。</li>
<li><code>f[0][j] = j</code>：将空字符串转化为 <code>word2</code> 的前 <code>j</code> 个字符需要 <code>j</code> 次插入操作。</li>
</ul>
<p>目标</p>
<p>最终目标是计算 <code>f[n][m]</code>，其中 <code>n</code> 和 <code>m</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word2)</span> &#123;<br>        <span class="hljs-type">int</span> n = word1.length();<br>        <span class="hljs-type">int</span> m = word2.length();<br>        <br>        <span class="hljs-comment">// 定义 f[i][j] 并初始化边界</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; f(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) f[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) f[<span class="hljs-number">0</span>][j] = j;<br><br>        <span class="hljs-comment">// 计算编辑距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-type">int</span> eq = (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>                f[i][j] = <span class="hljs-built_in">std</span>::min(&#123;f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 插入</span><br>                                    f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 删除</span><br>                                    f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + eq&#125;);  <span class="hljs-comment">// 替换或不变</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最终的编辑距离</span><br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0&#x2F;1 背包"></a>0&#x2F;1 背包</h3><p>给定 <code>N</code> 个物品，每个物品有一定的体积 <code>V[i]</code> 和价值 <code>W[i]</code>。还有一个容量为 <code>M</code> 的背包，要求在背包容量不超过 <code>M</code> 的前提下，选择一些物品放入背包，使物品的总价值最大。</p>
<p>模版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; V, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; W)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = V.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(M + <span class="hljs-number">1</span>, <span class="hljs-number">-1e9</span>)</span></span>; <span class="hljs-comment">// 初始化为负无穷</span><br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 没有物品且容量为0的初始状态</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 遍历每个物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = M; j &gt;= V[i]; --j) &#123; <span class="hljs-comment">// 倒序遍历容量，确保每个物品仅选择一次</span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - V[i]] + W[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 寻找容量为 M 时的最大价值</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= M; ++j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, f[j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><p>问题描述是：给定一个只包含正整数的非空数组，判断是否可以将数组分割成两个子集，使得两个子集的和相等。</p>
<p>这是一个典型的 0&#x2F;1 背包问题，问题可以转化为：是否可以从数组中选择一些数，使其和等于总和的一半。因为背包其实就是你看每个物品选不选?子集在一个核的限制下。选数的问题就跟背包一样，正好是选出来总体积为三-2这样的物品。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) sum += num;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= num; --j) &#123;<br>                f[j] = f[j] || f[j - num];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[target];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>给定 NNN 种物品，其中第 iii 种物品的体积为 ViV_iVi，价值为 WiW_iWi，并且每种物品有无限个。现在有一个容量为 MMM 的背包，要求选择若干个物品放入背包中，使得物品的总体积不超过 MMM，并且物品的价值总和最大。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f(m + <span class="hljs-number">1</span>, <span class="hljs-number">-1000000000</span>); <span class="hljs-comment">// 初始化，容量为 m 的背包</span><br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;      <span class="hljs-comment">// 遍历每一种物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v[i]; j &lt;= m; j++) &#123; <span class="hljs-comment">// j 从 v[i] 到 m 顺序遍历</span><br>        f[j] = <span class="hljs-keyword">max</span>(f[j], f[j - v[i]] + w[i]); <span class="hljs-comment">// 更新当前容量 j 的最大值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>    ans = <span class="hljs-keyword">max</span>(ans, f[j]);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="零钱兑换-Ii"><a href="#零钱兑换-Ii" class="headerlink" title="零钱兑换 Ii"></a>零钱兑换 Ii</h4><p>给定一个整数数组 <code>coins</code> 表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p>
<p>编写一个函数来计算可以凑成总金额的硬币组合数，假设每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<ul>
<li>输入：<code>amount = 5, coins = [1, 2, 5]</code></li>
<li>输出：<code>4</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[amount + <span class="hljs-number">1</span>];<br>    Arrays.<span class="hljs-built_in">fill</span>(f, <span class="hljs-number">0</span>);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.length; i++) &#123; <span class="hljs-comment">// 遍历每种硬币</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历从 coins[i] 到 amount 的金额</span><br>            f[j] += f[j - coins[i]]; <span class="hljs-comment">// 更新方法数量</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[amount];<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h1 id="十七-字典树-并查集"><a href="#十七-字典树-并查集" class="headerlink" title="十七.字典树,并查集"></a>十七.字典树,并查集</h1><h1 id="十八-图论"><a href="#十八-图论" class="headerlink" title="十八.图论"></a>十八.图论</h1><h1 id="十九-字符串处理"><a href="#十九-字符串处理" class="headerlink" title="十九.字符串处理"></a>十九.字符串处理</h1><h1 id="二十-高级搜索"><a href="#二十-高级搜索" class="headerlink" title="二十.高级搜索"></a>二十.高级搜索</h1><h1 id="二十一-平衡二叉树"><a href="#二十一-平衡二叉树" class="headerlink" title="二十一.平衡二叉树"></a>二十一.平衡二叉树</h1><h1 id="二十二-跳跃表"><a href="#二十二-跳跃表" class="headerlink" title="二十二.跳跃表"></a>二十二.跳跃表</h1><h1 id="二十三-线段树"><a href="#二十三-线段树" class="headerlink" title="二十三.线段树"></a>二十三.线段树</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法笔记</div>
      <div>https://theganlove.github.io/2024/09/09/算法笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>uert</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/" title="服务器部署">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">服务器部署</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/08/%E9%9A%90%E5%86%99/" title="隐写">
                        <span class="hidden-mobile">隐写</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
