

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="uert">
  <meta name="keywords" content="">
  
    <meta name="description" content="一.数组c++的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &amp;lt">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://theganlove.github.io/2024/09/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一.数组c++的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &amp;lt">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-09T11:20:21.000Z">
<meta property="article:modified_time" content="2024-09-13T04:25:55.797Z">
<meta property="article:author" content="uert">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算法笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"theganlove.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>主题</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-09 19:20" pubdate>
          2024年9月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          175 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一-数组"><a href="#一-数组" class="headerlink" title="一.数组"></a>一.数组</h1><p>c++的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// For sort and reverse</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化数组</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组第一个元素: &quot;</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组第三个元素: &quot;</span> &lt;&lt; arr[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 3</span><br><br>    <span class="hljs-comment">// 修改数组元素</span><br>    arr[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;修改后的第三个元素: &quot;</span> &lt;&lt; arr[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 10</span><br><br>    <span class="hljs-comment">// 使用范围for循环遍历数组 (C++11及以上)</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组元素: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 初始化vector</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;vector第一个元素: &quot;</span> &lt;&lt; vec[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;vector第三个元素: &quot;</span> &lt;&lt; vec[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 3</span><br><br>    <span class="hljs-comment">// 修改vector元素</span><br>    vec[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;修改后的第三个元素: &quot;</span> &lt;&lt; vec[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 10</span><br><br>    <span class="hljs-comment">// 使用at()方法访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;使用at()访问第三个元素: &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 10</span><br><br>    <span class="hljs-comment">// 向vector中添加元素</span><br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">6</span>);  <span class="hljs-comment">// 添加到末尾</span><br>    vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">7</span>);  <span class="hljs-comment">// 在索引1处插入</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;添加元素后的vector: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : vec) &#123;<br>        std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 从vector中删除元素</span><br>    vec.<span class="hljs-built_in">erase</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 删除索引1处的元素</span><br>    vec.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 删除末尾元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除元素后的vector: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : vec) &#123;<br>        std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 清空vector</span><br>    vec.<span class="hljs-built_in">clear</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;清空后的vector大小: &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 0</span><br><br>    <span class="hljs-comment">// 重新填充vector</span><br>    vec = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    <br>    <span class="hljs-comment">// 排序和反转vector</span><br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;排序后的vector: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : vec) &#123;<br>        std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    std::<span class="hljs-built_in">reverse</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;反转后的vector: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : vec) &#123;<br>        std::cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用迭代器遍历vector</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;使用迭代器遍历vector: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>std::cout 的组成部分<br>  std：这是标准命名空间（<span class="hljs-keyword">namespace</span>）的缩写。在C++标准库中的所有功能都包含在命名空间 std 中。使用 std:: 作为前缀是为了避免命名冲突。<br>  cout：这是标准输出流对象，表示 <span class="hljs-string">&quot;character output stream&quot;</span>。cout 是 std 命名空间中的一个对象，用于将数据输出到标准输出设备（通常是控制台）。<br> std::endl 的详细解释<br>  作用<br>  插入换行符：在输出流中插入一个换行符（即 \n）。<br>  刷新缓冲区：强制刷新输出缓冲区，确保所有缓冲的输出内容都被实际写入到输出设备（如控制台）上。<br> 何时使用std::endl？<br> 需要立即显示输出：当你希望输出立即显示，而不是等待缓冲区满或者程序结束时，可以使用 std::endl。<br> 调试输出：在调试时使用 std::endl 可以确保所有调试信息都立即显示，帮助更快地定位问题。<br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">java</span> &#123;<br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 初始化数组</span><br>        <span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-comment">// 访问元素</span><br>        System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">2</span>]);  <span class="hljs-comment">// 输出 3, 访问数组中索引为2的元素</span><br>        <span class="hljs-comment">// 修改元素</span><br>        arr[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 将数组中索引为2的元素修改为10</span><br>        <span class="hljs-comment">// 使用ArrayList来实现动态数组Arrays.asList是java.util.Arrays类中的一个静态方法，它接受一个可变参数（varargs）并返回一个包含这些元素的固定大小的List然后使用new ArrayList&lt;&gt;(...)构造一个新的ArrayList对象，初始内容为上述固定大小的List中的元素。这使得新创建的ArrayList具有这些初始元素，同时它是可变大小的，可以添加和删除元素。</span><br>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-number">6</span>);  <span class="hljs-comment">// 在数组末尾添加元素6</span><br>        <span class="hljs-comment">// 删除元素之前先检查是否存在</span><br>        <span class="hljs-keyword">if</span> (list.contains(<span class="hljs-number">3</span>)) &#123;  <span class="hljs-comment">// 检查元素3是否在数组中</span><br>            list.remove(Integer.valueOf(<span class="hljs-number">3</span>));  <span class="hljs-comment">// 删除数组中的元素3</span><br>        &#125;<br>        <span class="hljs-comment">// 打印修改后的数组</span><br>        System.<span class="hljs-keyword">out</span>.println(list);  <span class="hljs-comment">// 输出修改后的数组 [1, 2, 10, 4, 5, 6]</span><br><br><br>        <span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>Array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        String[] strArray = new String[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 初始化一个包含5个元素的数组，元素默认值为null</span><br>        <span class="hljs-built_in">int</span> firstElement = <span class="hljs-built_in">int</span>Array[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 访问第一个元素</span><br>        <span class="hljs-built_in">int</span>Array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 修改第三个元素的值为10</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>Array.length; i++) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">int</span>Array[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> value : <span class="hljs-built_in">int</span>Array) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(value);<br>        &#125;<br>        Arrays.sort(<span class="hljs-built_in">int</span>Array);  <span class="hljs-comment">// 对数组进行排序，要import java.util.Arrays;</span><br><br>        <span class="hljs-built_in">int</span>[] newArray = Arrays.copyOf(<span class="hljs-built_in">int</span>Array, <span class="hljs-built_in">int</span>Array.length);  <span class="hljs-comment">// 复制整个数组</span><br>        <span class="hljs-built_in">int</span>[] partialArray = Arrays.copyOf(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 复制数组的前3个元素</span><br>        <span class="hljs-built_in">int</span>[] destinationArray = new <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br>        System.<span class="hljs-built_in">array</span>copy(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">0</span>, destinationArray, <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>Array.length);  <span class="hljs-comment">// 复制数组到另一个数组</span><br><br>        String <span class="hljs-built_in">array</span>String = Arrays.toString(<span class="hljs-built_in">int</span>Array);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">array</span>String);  <span class="hljs-comment">// 输出数组的字符串表示</span><br>        List&lt;Integer&gt; <span class="hljs-built_in">array</span>List = new ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br><br>        Arrays.fill(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 将数组的所有元素设置为10</span><br>        Arrays.fill(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 将数组的部分元素设置为20（索引1到2）</span><br>        <span class="hljs-built_in">int</span>[] anotherArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-built_in">bool</span>ean <span class="hljs-built_in">array</span>sEqual = Arrays.equals(<span class="hljs-built_in">int</span>Array, anotherArray);  <span class="hljs-comment">// 检查两个数组是否相等</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Arrays are equal: &quot;</span> + <span class="hljs-built_in">array</span>sEqual);<br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 初始化列表</span><br><span class="hljs-attribute">arr</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">2</span>])  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span><br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5]</span><br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">arr</span>.append(<span class="hljs-number">6</span>)  # 在末尾添加<br><span class="hljs-attribute">arr</span>.insert(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)  # 在索引<span class="hljs-number">1</span>处插入<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 7, 2, 10, 4, 5, 6]</span><br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">arr</span>.remove(<span class="hljs-number">7</span>)  # 移除第一个值为<span class="hljs-number">7</span>的元素<br><span class="hljs-attribute">del</span> arr[<span class="hljs-number">2</span>]  # 删除索引<span class="hljs-number">2</span>处的元素<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5, 6]</span><br><br><span class="hljs-comment"># 切片</span><br><span class="hljs-attribute">sub_arr</span> = arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  # 从索引<span class="hljs-number">1</span>到索引<span class="hljs-number">3</span>的子数组<br><span class="hljs-attribute">print</span>(sub_arr)  # 输出<span class="hljs-meta"> [2, 10, 4]</span><br><br><span class="hljs-comment"># 遍历</span><br><span class="hljs-attribute">for</span> value in arr:<br>    <span class="hljs-attribute">print</span>(value, end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">print</span>()<br><br><span class="hljs-comment"># 使用索引遍历</span><br><span class="hljs-attribute">for</span> i in range(len(arr)):<br>    <span class="hljs-attribute">print</span>(arr[i], end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">print</span>()<br><br><span class="hljs-comment"># 检查元素是否在列表中</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">10</span> in arr)  # 输出 True<br><br><span class="hljs-comment"># 获取长度</span><br><span class="hljs-attribute">print</span>(len(arr))  # 输出 <span class="hljs-number">6</span><br><br><span class="hljs-comment"># 列表合并</span><br><span class="hljs-attribute">arr2</span> =<span class="hljs-meta"> [7, 8, 9]</span><br><span class="hljs-attribute">combined_arr</span> = arr + arr2<br><span class="hljs-attribute">print</span>(combined_arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5, 6, 7, 8, 9]</span><br><br><span class="hljs-comment"># 列表排序</span><br><span class="hljs-attribute">arr</span>.sort()<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 4, 5, 6, 10]</span><br><br><span class="hljs-comment"># 列表反转</span><br><span class="hljs-attribute">arr</span>.reverse()<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [10, 6, 5, 4, 2, 1]</span><br><br><br><span class="hljs-comment">#使用 NumPy 数组操作</span><br><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-comment"># 初始化数组</span><br><span class="hljs-attribute">arr</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">2</span>])  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span><br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [ 1  2 10  4  5]</span><br><br><span class="hljs-comment"># 切片</span><br><span class="hljs-attribute">sub_arr</span> = arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  # 从索引<span class="hljs-number">1</span>到索引<span class="hljs-number">3</span>的子数组<br><span class="hljs-attribute">print</span>(sub_arr)  # 输出<span class="hljs-meta"> [ 2 10  4]</span><br><br><span class="hljs-comment"># 遍历</span><br><span class="hljs-attribute">for</span> value in arr:<br>    <span class="hljs-attribute">print</span>(value, end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">print</span>()<br><span class="hljs-comment"># 数组元素的加法</span><br><span class="hljs-attribute">arr2</span> = np.array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])<br><span class="hljs-attribute">result</span> = arr + arr2<br><span class="hljs-attribute">print</span>(result)  # 输出<span class="hljs-meta"> [11 22 40 44 55]</span><br><br><span class="hljs-comment"># 数组元素的乘法</span><br><span class="hljs-attribute">result</span> = arr * <span class="hljs-number">2</span><br><span class="hljs-attribute">print</span>(result)  # 输出<span class="hljs-meta"> [ 2  4 20  8 10]</span><br><br><span class="hljs-comment"># 数组的矩阵运算</span><br><span class="hljs-attribute">matrix1</span> = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<span class="hljs-meta"> [3, 4]])</span><br><span class="hljs-meta">matrix2 = np.array([[5, 6], [7, 8]])</span><br><span class="hljs-meta">result = np.dot(matrix1, matrix2)</span><br><span class="hljs-meta">print(result)</span><br><span class="hljs-meta"># 输出</span><br><span class="hljs-meta"># [[19 22]</span><br><span class="hljs-comment">#  [43 50]]</span><br><span class="hljs-comment"># 创建特定形状的数组</span><br><span class="hljs-attribute">zeros</span> = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(zeros)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[0. 0. 0.]</span><br><span class="hljs-comment">#  [0. 0. 0.]</span><br><span class="hljs-comment">#  [0. 0. 0.]]</span><br><br><span class="hljs-attribute">ones</span> = np.ones((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))<br><span class="hljs-attribute">print</span>(ones)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[1. 1. 1. 1.]</span><br><span class="hljs-comment">#  [1. 1. 1. 1.]]</span><br><br><span class="hljs-comment"># 生成等差数组</span><br><span class="hljs-attribute">arr</span> = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [0 2 4 6 8]</span><br><br><span class="hljs-comment"># 数组重塑</span><br><span class="hljs-attribute">arr</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-attribute">reshaped</span> = arr.reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(reshaped)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[1 2 3]</span><br><span class="hljs-comment">#  [4 5 6]]</span><br><span class="hljs-comment"># 创建一个包含1到10的平方的列表</span><br><span class="hljs-attribute">squares</span> =<span class="hljs-meta"> [x**2 for x in range(1, 11)]</span><br><span class="hljs-attribute">print</span>(squares)  # 输出<span class="hljs-meta"> [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><br><span class="hljs-comment"># 过滤列表中的元素</span><br><span class="hljs-attribute">even_squares</span> =<span class="hljs-meta"> [x**2 for x in range(1, 11) if x % 2 == 0]</span><br><span class="hljs-attribute">print</span>(even_squares)  # 输出<span class="hljs-meta"> [4, 16, 36, 64, 100]</span><br></code></pre></td></tr></table></figure>

<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>针对去重这类操作的模版</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">num</span>.size;i++)&#123;<br>	<span class="hljs-keyword">if</span>(要什么)&#123;<br>		<span class="hljs-built_in">num</span>[n] = <span class="hljs-built_in">num</span>[i];<br>		n++;<br>	&#125;<br>&#125;<br>去重:i=<span class="hljs-number">0</span> || <span class="hljs-built_in">num</span>[i]!=<span class="hljs-built_in">num</span>[i<span class="hljs-number">-1</span>]<br>移动零: <span class="hljs-built_in">num</span>[i]!=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h1><p>c++的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">data</span>(data), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* head;<br><br>    <span class="hljs-built_in">LinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node* last = head;<br>        <span class="hljs-keyword">while</span> (last-&gt;next) &#123;<br>            last = last-&gt;next;<br>        &#125;<br>        last-&gt;next = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepend</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        newNode-&gt;next = head;<br>        head = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteWithValue</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (head-&gt;data == data) &#123;<br>            Node* temp = head;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;data != data) &#123;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current-&gt;next) &#123;<br>            Node* temp = current-&gt;next;<br>            current-&gt;next = current-&gt;next-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;None&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            Node* next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            current = next;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用链表类</span><br>    LinkedList myList;<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">1</span>);<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">2</span>);<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">3</span>);<br>    myList.<span class="hljs-built_in">prepend</span>(<span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list after additions: &quot;</span>;<br>    myList.<span class="hljs-built_in">printList</span>();  <span class="hljs-comment">// 输出: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; None</span><br><br>    myList.<span class="hljs-built_in">deleteWithValue</span>(<span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list after deleting 2: &quot;</span>;<br>    myList.<span class="hljs-built_in">printList</span>();  <span class="hljs-comment">// 输出: 0 -&gt; 1 -&gt; 3 -&gt; None</span><br><br>    <span class="hljs-comment">// 使用 std::list 示例</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Using std::list:&quot;</span> &lt;&lt; std::endl;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// 添加元素</span><br>    lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after additions: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First element: &quot;</span> &lt;&lt; lst.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Last element: &quot;</span> &lt;&lt; lst.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl;    <span class="hljs-comment">// 输出: 4</span><br><br>    <span class="hljs-comment">// 修改元素</span><br>    <span class="hljs-keyword">auto</span> it = lst.<span class="hljs-built_in">begin</span>();<br>    ++it;  <span class="hljs-comment">// 指向第二个元素</span><br>    *it = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after modifying second element: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    lst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">10</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after removing 10: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>链表类（LinkedList）:<br><br><span class="hljs-built_in">append</span>(<span class="hljs-type">int</span> data)：在链表末尾添加元素。<br><span class="hljs-built_in">prepend</span>(<span class="hljs-type">int</span> data)：在链表头部添加元素。<br><span class="hljs-built_in">deleteWithValue</span>(<span class="hljs-type">int</span> data)：删除值为 data 的节点。<br><span class="hljs-built_in">printList</span>()：打印链表中的所有元素。<br>析构函数 ~<span class="hljs-built_in">LinkedList</span>()：释放链表占用的内存。<br>std::list 示例:<br><br><span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)：在列表末尾添加元素。<br><span class="hljs-built_in">push_front</span>(<span class="hljs-type">int</span> value)：在列表头部添加元素。<br><span class="hljs-built_in">front</span>()：访问第一个元素。<br><span class="hljs-built_in">back</span>()：访问最后一个元素。<br>通过迭代器修改元素。<br><span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> value)：删除值为 value 的所有元素。<br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> java1 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 初始化链表</span><br>        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Initial list: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br><br>        <span class="hljs-comment">// 访问元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;First element: &quot;</span> + list.getFirst()); <span class="hljs-comment">// 输出 1</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Last element: &quot;</span> + list.getLast());   <span class="hljs-comment">// 输出 3</span><br><br>        <span class="hljs-comment">// 修改元素</span><br>        list.set(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 修改索引1处的元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after modification: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 20, 3]</span><br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除索引1处的元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after removal: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 3]</span><br><br>        <span class="hljs-comment">// 链表大小</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Size of the list: &quot;</span> + list.<span class="hljs-keyword">size</span>()); <span class="hljs-comment">// 输出 2</span><br><br>        <span class="hljs-comment">// 遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using for-each loop: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (Integer element : list) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(element + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用迭代器遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using iterator: &quot;</span>);<br>        Iterator&lt;Integer&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(iterator.<span class="hljs-keyword">next</span>() + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用索引遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using for loop: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-keyword">size</span>(); i++) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(list.get(i) + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用Deque操作</span><br>        list.addFirst(<span class="hljs-number">0</span>); <span class="hljs-comment">// 在头部添加元素</span><br>        list.addLast(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 在尾部添加元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after deque operations: &quot;</span> + list); <span class="hljs-comment">// 输出 [0, 1, 3, 4]</span><br><br>        <span class="hljs-comment">// 删除Deque操作</span><br>        list.removeFirst(); <span class="hljs-comment">// 删除头部元素</span><br>        list.removeLast();  <span class="hljs-comment">// 删除尾部元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after removing first and last: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 3]</span><br><br>        <span class="hljs-comment">// 检查元素是否存在</span><br>        <span class="hljs-keyword">boolean</span> contains = list.contains(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List contains 3: &quot;</span> + contains); <span class="hljs-comment">// 输出 true</span><br><br>        <span class="hljs-comment">// 清空链表</span><br>        list.clear();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after clear: &quot;</span> + list); <span class="hljs-comment">// 输出 []</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Size of the list after clear: &quot;</span> + list.<span class="hljs-keyword">size</span>()); <span class="hljs-comment">// 输出 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 使用 Python 内置的 list</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Using Python list:&quot;</span>)<br><br><span class="hljs-comment"># 初始化列表</span><br><span class="hljs-attribute">lst</span> =<span class="hljs-meta"> [1, 2, 3]</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Initial list:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 2, 3]</span><br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">lst</span>.append(<span class="hljs-number">4</span>)  # 在末尾添加元素<br><span class="hljs-attribute">lst</span>.insert(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>)  # 在索引<span class="hljs-number">1</span>处插入元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after additions:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 1.5, 2, 3, 4]</span><br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;First element:&quot;</span>, lst[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Last element:&quot;</span>, lst[-<span class="hljs-number">1</span>])  # 输出 <span class="hljs-number">4</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">lst</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after modification:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 1.8, 2, 3, 4]</span><br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">lst</span>.remove(<span class="hljs-number">1</span>.<span class="hljs-number">8</span>)  # 删除值为<span class="hljs-number">1</span>.<span class="hljs-number">8</span>的元素<br><span class="hljs-attribute">del</span> lst[<span class="hljs-number">0</span>]  # 删除索引<span class="hljs-number">0</span>处的元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after deletions:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [2, 3, 4]</span><br><br><span class="hljs-comment"># 列表长度</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Length of the list:&quot;</span>, len(lst))  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历列表</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Traversing the list:&quot;</span>)<br><span class="hljs-attribute">for</span> item in lst:<br>    <span class="hljs-attribute">print</span>(item, end=<span class="hljs-string">&quot; &quot;</span>)  # 输出 <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment">### 使用 `collections.deque`</span><br><br><br><span class="hljs-attribute">from</span> collections import deque<br><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Using collections.deque:&quot;</span>)<br><br><span class="hljs-comment"># 初始化deque</span><br><span class="hljs-attribute">d</span> = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Initial deque:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">d</span>.append(<span class="hljs-number">4</span>)  # 在尾部添加<br><span class="hljs-attribute">d</span>.appendleft(<span class="hljs-number">0</span>)  # 在头部添加<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after additions:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 访问元素（需要转换为列表）</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;First element:&quot;</span>, d[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">0</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Last element:&quot;</span>, d[-<span class="hljs-number">1</span>])  # 输出 <span class="hljs-number">4</span><br><br><span class="hljs-comment"># 修改元素（需要转换为列表）</span><br><span class="hljs-attribute">d_list</span> = list(d)<br><span class="hljs-attribute">d_list</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">d</span> = deque(d_list)<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after modification:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">d</span>.pop()  # 删除尾部元素<br><span class="hljs-attribute">d</span>.popleft()  # 删除头部元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after deletions:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">1</span>.<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># deque长度</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Length of the deque:&quot;</span>, len(d))  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历deque</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Traversing the deque:&quot;</span>)<br><span class="hljs-attribute">for</span> item in d:<br>    <span class="hljs-attribute">print</span>(item, end=<span class="hljs-string">&quot; &quot;</span>)  # 输出 <span class="hljs-number">1</span>.<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h2 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">head  head 是一个指针，指向链表的第一个节点，因此它表示整个链表的起始点<br>  |<span class="hljs-string"></span><br><span class="hljs-string">  v</span><br><span class="hljs-string">  ______      ______      ______</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  1   </span>|<span class="hljs-string"> -&gt; </span>|<span class="hljs-string">  2   </span>|<span class="hljs-string"> -&gt; </span>|<span class="hljs-string">  3   </span>|<span class="hljs-string"> -&gt; null</span><br><span class="hljs-string">  ------      ------      ------</span><br><span class="hljs-string"></span><br><span class="hljs-string">ListNode nextHead = head.next;</span><br><span class="hljs-string">head</span><br><span class="hljs-string">  </span>|<br>  v<br>  ______      ______      ______<br> |<span class="hljs-string">  1   </span>|<span class="hljs-string"> -&gt; </span>|<span class="hljs-string">  2   </span>|<span class="hljs-string"> -&gt; </span>|<span class="hljs-string">  3   </span>|<span class="hljs-string"> -&gt; null</span><br><span class="hljs-string">  ------      ------</span><br><span class="hljs-string">     ^</span><br><span class="hljs-string">     </span>|<br>nextHead<br> head.next = last; <br>head<br>  |<span class="hljs-string"></span><br><span class="hljs-string">  v</span><br><span class="hljs-string">  ______      ______      ______</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  1   </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  2   </span>|<span class="hljs-string"> -&gt; </span>|<span class="hljs-string">  3   </span>|<span class="hljs-string"> -&gt; null</span><br><span class="hljs-string">  ------      ------</span><br><span class="hljs-string">    </span>|<br>   null<br>last = head; <br>last<br>  |<span class="hljs-string"></span><br><span class="hljs-string">  v</span><br><span class="hljs-string">  ______      ______      ______</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  1   </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  2   </span>|<span class="hljs-string"> -&gt; </span>|<span class="hljs-string">  3   </span>|<span class="hljs-string"> -&gt; null</span><br><span class="hljs-string">  ------</span><br><span class="hljs-string">    </span>|<br>   null<br>head<br>head = nextHead<br>last            head<br>  |<span class="hljs-string">              </span>|<br>  v              v<br>  ______      ______      ______<br> |<span class="hljs-string">  1   </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  2   </span>|<span class="hljs-string"> -&gt; </span>|<span class="hljs-string">  3   </span>|<span class="hljs-string"> -&gt; null</span><br><span class="hljs-string">  ------      ------</span><br><span class="hljs-string">    </span>|<br>   null<br><br><br> public ListNode reverseList(ListNode head) &#123;        <br>        ListNode last = null;<br>        while (head != null) &#123;<br>            ListNode nextHead = head.next;  // 暂存下一个节点<br>            head.next = last;              // 反转当前节点的指针,重新指向   1 -&gt; null<br>            last = head;                   // 更新last为当前节点<br>            head = nextHead;               // 继续处理下一个节点<br>        &#125;<br>        return last;                       // 返回新头节点<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="三-单调栈"><a href="#三-单调栈" class="headerlink" title="三.单调栈"></a>三.单调栈</h1><pre><code class="hljs"> C++实现
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;C++ 实现\n&quot;</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;栈操作（Stack）：&quot;</span> &lt;&lt; std::endl;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 压栈</span><br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Stack after pushes: &quot;</span>;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; tempStack = stack;<br>    <span class="hljs-keyword">while</span> (!tempStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempStack.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-type">int</span> top = stack.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 获取栈顶元素</span><br>    stack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 出栈</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Popped element: &quot;</span> &lt;&lt; top &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Stack after pop: &quot;</span>;<br>    tempStack = stack;<br>    <span class="hljs-keyword">while</span> (!tempStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempStack.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 队列</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n队列操作（Queue）：&quot;</span> &lt;&lt; std::endl;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; queue;<br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 入队</span><br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Queue after enqueues: &quot;</span>;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; tempQueue = queue;<br>    <span class="hljs-keyword">while</span> (!tempQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempQueue.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempQueue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-type">int</span> front = queue.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 获取队首元素</span><br>    queue.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 出队</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Dequeued element: &quot;</span> &lt;&lt; front &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Queue after dequeue: &quot;</span>;<br>    tempQueue = queue;<br>    <span class="hljs-keyword">while</span> (!tempQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempQueue.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempQueue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 双端队列</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n双端队列操作（Deque）：&quot;</span> &lt;&lt; std::endl;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; deque;<br>    deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 在尾部添加</span><br>    deque.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部添加</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Deque after additions: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : deque) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-type">int</span> last = deque.<span class="hljs-built_in">back</span>();  <span class="hljs-comment">// 获取尾部元素</span><br>    deque.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 从尾部移除</span><br>    <span class="hljs-type">int</span> first = deque.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 获取头部元素</span><br>    deque.<span class="hljs-built_in">pop_front</span>();  <span class="hljs-comment">// 从头部移除</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Deque after removals: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : deque) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 优先队列</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n优先队列操作（Priority Queue）：&quot;</span> &lt;&lt; std::endl;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 入队</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Priority Queue elements: &quot;</span>;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; tempPQ = pq;<br>    <span class="hljs-keyword">while</span> (!tempPQ.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempPQ.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempPQ.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 按优先级顺序出队</span><br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// Java实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">java2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 栈</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Java 实现\n&quot;</span>);<br><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;栈操作（Stack）：&quot;</span>);<br>        java.util.Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> java.util.Stack&lt;&gt;();<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 压栈</span><br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Stack after pushes: &quot;</span> + stack);<br>        <span class="hljs-type">int</span> top = stack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 出栈</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Popped element: &quot;</span> + top);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Stack after pop: &quot;</span> + stack);<br><br>        <span class="hljs-comment">// 队列</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n队列操作（Queue）：&quot;</span>);<br>        java.util.Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> java.util.LinkedList&lt;&gt;();<br>        queue.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 入队</span><br>        queue.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>);<br>        queue.<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Queue after enqueues: &quot;</span> + queue);<br>        <span class="hljs-type">int</span> front = queue.<span class="hljs-built_in">poll</span>();  <span class="hljs-comment">// 出队</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Dequeued element: &quot;</span> + front);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Queue after dequeue: &quot;</span> + queue);<br><br>        <span class="hljs-comment">// 双端队列</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n双端队列操作（Deque）：&quot;</span>);<br>        java.util.Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> java.util.LinkedList&lt;&gt;();<br>        deque.<span class="hljs-built_in">addLast</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 在尾部添加</span><br>        deque.<span class="hljs-built_in">addFirst</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部添加</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Deque after additions: &quot;</span> + deque);<br>        <span class="hljs-type">int</span> last = deque.<span class="hljs-built_in">removeLast</span>();  <span class="hljs-comment">// 从尾部移除</span><br>        <span class="hljs-type">int</span> first = deque.<span class="hljs-built_in">removeFirst</span>();  <span class="hljs-comment">// 从头部移除</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Deque after removals: &quot;</span> + deque);<br><br>        <span class="hljs-comment">// 优先队列</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n优先队列操作（Priority Queue）：&quot;</span>);<br>        java.util.PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> java.util.PriorityQueue&lt;&gt;();<br>        pq.<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 入队</span><br>        pq.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);<br>        pq.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Priority Queue elements: &quot;</span> + pq);<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(pq.<span class="hljs-built_in">poll</span>());  <span class="hljs-comment">// 按优先级顺序出队</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Python实现</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Python 实现&quot;</span>)<br><br><span class="hljs-comment"># 栈</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n栈操作（Stack）：&quot;</span>)<br>stack = []<br>stack.append(1)  # 压栈<br>stack.append(2)<br>stack.append(3)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stack after pushes:&quot;</span>, stack)<br>top = stack.pop()  # 出栈<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Popped element:&quot;</span>, top)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stack after pop:&quot;</span>, stack)<br><br><span class="hljs-comment"># 队列</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n队列操作（Queue）：&quot;</span>)<br><span class="hljs-keyword">from</span> collections import deque<span class="hljs-built_in"></span><br><span class="hljs-built_in">queue </span>= deque()<br>queue.append(1)  # 入队<br>queue.append(2)<br>queue.append(3)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Queue after enqueues:&quot;</span>, queue)<br>front = queue.popleft()  # 出队<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dequeued element:&quot;</span>, front)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Queue after dequeue:&quot;</span>, queue)<br><br><span class="hljs-comment"># 双端队列</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n双端队列操作（Deque）：&quot;</span>)<br>deque = deque()<br>deque.append(1)  # 在尾部添加<br>deque.appendleft(0)  # 在头部添加<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deque after additions:&quot;</span>, deque)<br>last = deque.pop()  # 从尾部移除<br>first = deque.popleft()  # 从头部移除<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deque after removals:&quot;</span>, deque)<br><br><span class="hljs-comment"># 优先队列</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n优先队列操作（Priority Queue）：&quot;</span>)<br>import<span class="hljs-built_in"> queue</span><br><span class="hljs-built_in"></span>pq = queue.PriorityQueue()<br>pq.put((2, <span class="hljs-string">&quot;B&quot;</span>))  # 入队<br>pq.put((1, <span class="hljs-string">&quot;A&quot;</span>))<br>pq.put((3, <span class="hljs-string">&quot;C&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Priority Queue elements:&quot;</span>, pq.queue)<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> pq.empty():<br>    <span class="hljs-built_in">print</span>(pq.<span class="hljs-built_in">get</span>())  # 按优先级顺序出队<br></code></pre></td></tr></table></figure>

<p>经验</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs arduino">核心思想:单调栈考虑前面不影响后面<br>套路模版: <br><span class="hljs-keyword">for</span>()&#123;<br>	<span class="hljs-keyword">while</span>(栈顶与新元素不满足单调栈)&#123;<br>		弹栈<br>		更新<br>		累加<br>	&#125;<br>&#125;<br><br><br><br>例子<br>柱状图中最大矩形<br>heighs=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br><span class="hljs-keyword">private</span>:<br>	stuct UERT&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	stack &lt;UERT&gt; s;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    	heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 便于最后清空栈</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>    		<span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度小于栈顶柱子的高度，则计算面积</span><br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>().height &gt;= height) &#123;<br>                accmulatedWidth += s.<span class="hljs-built_in">top</span>().width;<br>                ans = <span class="hljs-built_in">max</span>(ans,s.<span class="hljs-built_in">top</span>().width*accmulatedWidth);            <br>                s.<span class="hljs-built_in">pop</span>();            <br>        	&#125;<br>        	s.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>   		&#125;<br>    	<span class="hljs-keyword">return</span> maxArea;<br>	&#125;<br><br><br><br>接雨水<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UERT</span>&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	stack &lt;UERT&gt; s;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; s;  <span class="hljs-comment">// 用来保存柱子的索引</span><br>    <span class="hljs-type">int</span> water = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 保存总的接雨水量</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>   		<span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果当前柱子的高度大于栈顶柱子，计算能存储的雨水</span><br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>().height &lt;= height) &#123;<br>            <span class="hljs-type">int</span> bottom = s.<span class="hljs-built_in">top</span>().height;<br>            accmulatedWidth += s.<span class="hljs-built_in">top</span>().width;<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果栈为空，跳过</span><br>            <span class="hljs-type">int</span> up = <span class="hljs-built_in">min</span>(height,s.<span class="hljs-built_in">top</span>().height);<br>            ans += accmulatedWidth*(up-bottom);<br>        &#125;<br>        s.<span class="hljs-built_in">push</span>(&#123;accmulatedWidth<span class="hljs-number">+1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;	<br>	<br>	<br></code></pre></td></tr></table></figure>

<h1 id="四-单调队列"><a href="#四-单调队列" class="headerlink" title="四.单调队列"></a>四.单调队列</h1><h1 id="五-集合和映射"><a href="#五-集合和映射" class="headerlink" title="五. 集合和映射"></a>五. 集合和映射</h1><p>C++实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;C++ 实现\n&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 哈希表（unordered_map）</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;哈希表操作（unordered_map）：&quot;</span> &lt;&lt; std::endl;<br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; hashMap;<br>    hashMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span>;<br>    hashMap[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span>;<br>    hashMap[<span class="hljs-string">&quot;c&quot;</span>] = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 添加元素</span><br>    hashMap[<span class="hljs-string">&quot;d&quot;</span>] = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value for key &#x27;a&#x27;: &quot;</span> &lt;&lt; hashMap[<span class="hljs-string">&quot;a&quot;</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 修改元素</span><br>    hashMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    hashMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>    <span class="hljs-comment">// 遍历哈希表</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hash table elements:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : hashMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查键是否存在</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Key &#x27;c&#x27; in hashMap: &quot;</span> &lt;&lt; (hashMap.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;c&quot;</span>) != hashMap.<span class="hljs-built_in">end</span>()) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 无序集合（unordered_set）</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n无序集合操作（unordered_set）：&quot;</span> &lt;&lt; std::endl;<br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; hashSet;<br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 添加元素</span><br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 删除元素</span><br>    hashSet.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 遍历集合</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Set elements:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem : hashSet) &#123;<br>        std::cout &lt;&lt; elem &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查元素是否存在</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Element 3 in hashSet: &quot;</span> &lt;&lt; (hashSet.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != hashSet.<span class="hljs-built_in">end</span>()) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java实现</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Java实现</span><br>import java.util.HashMap;<br>import java.util.Map;<br>import java.util.HashSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">java3</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 哈希表（HashMap）</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Java 实现\n&quot;</span>);<br><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;哈希表操作（HashMap）：&quot;</span>);<br>        HashMap&lt;String, Integer&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        hashMap.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        hashMap.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);<br>        hashMap.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 添加元素</span><br>        hashMap.put(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 访问元素</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Value for key &#x27;a&#x27;: &quot;</span> + hashMap.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;a&quot;</span>));<br><br>        <span class="hljs-comment">// 修改元素</span><br>        hashMap.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        hashMap.<span class="hljs-keyword">remove</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历哈希表</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hash table elements:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(entry.getKey() + <span class="hljs-string">&quot; &quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">// 检查键是否存在</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Key &#x27;c&#x27; in hashMap: &quot;</span> + hashMap.containsKey(<span class="hljs-string">&quot;c&quot;</span>));<br><br>        <span class="hljs-comment">// 无序集合（HashSet）</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\n无序集合操作（HashSet）：&quot;</span>);<br>        HashSet&lt;Integer&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);<br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 添加元素</span><br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        hashSet.<span class="hljs-keyword">remove</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 遍历集合</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Set elements:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> elem : hashSet) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(elem);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查元素是否存在</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Element 3 in hashSet: &quot;</span> + hashSet.contains(<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的实现</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Python实现</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Python 实现&quot;</span>)<br><br><span class="hljs-comment"># 哈希表（字典）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n哈希表操作（Dictionary）：&quot;</span>)<br>hash_table = &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>: 1,<br>    <span class="hljs-string">&#x27;b&#x27;</span>: 2,<br>    <span class="hljs-string">&#x27;c&#x27;</span>: 3<br>&#125;<br><br><span class="hljs-comment"># 添加元素</span><br>hash_table[<span class="hljs-string">&#x27;d&#x27;</span>] = 4<br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Value for key &#x27;a&#x27;:&quot;</span>, hash_table[<span class="hljs-string">&#x27;a&#x27;</span>])<br><br><span class="hljs-comment"># 修改元素</span><br>hash_table[<span class="hljs-string">&#x27;a&#x27;</span>] = 10<br><br><span class="hljs-comment"># 删除元素</span><br>del hash_table[<span class="hljs-string">&#x27;b&#x27;</span>]<br><br><span class="hljs-comment"># 遍历哈希表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hash table elements:&quot;</span>)<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> hash_table.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br><br><span class="hljs-comment"># 检查键是否存在</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Key &#x27;c&#x27; in hash_table:&quot;</span>, <span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-keyword">in</span> hash_table)<br><br><span class="hljs-comment"># 无序集合（Set）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n无序集合操作（Set）：&quot;</span>)<br>unordered_set = &#123;1, 2, 3&#125;<br><br><span class="hljs-comment"># 添加元素</span><br>unordered_set.<span class="hljs-built_in">add</span>(4)<br><br><span class="hljs-comment"># 删除元素</span><br>unordered_set.<span class="hljs-built_in">remove</span>(2)<br><br><span class="hljs-comment"># 遍历集合</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Set elements:&quot;</span>)<br><span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> unordered_set:<br>    <span class="hljs-built_in">print</span>(elem)<br><br><span class="hljs-comment"># 检查元素是否存在</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Element 3 in unordered_set:&quot;</span>, 3 <span class="hljs-keyword">in</span> unordered_set)<br></code></pre></td></tr></table></figure>

<h2 id="经验-2"><a href="#经验-2" class="headerlink" title="经验"></a>经验</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; h;  <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 遍历数组 nums</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;                    <br>            <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">find</span>(target-num[i]) != h.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;h[target-num[i]], i&#125;;  <span class="hljs-comment">// 找到两数之和，返回其索引</span><br>            &#125;<br>            <span class="hljs-comment">// 如果不存在，将当前元素和索引存入哈希表</span><br>            h[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果未找到符合条件的数对，返回空数组</span><br>    &#125;<br>&#125;;<br><br>模拟行走机器人<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; commands, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dirs[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 四个方向: 北(0,1), 东(1,0), 南(0,-1), 西(-1,0)</span><br>        <span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">60010</span> + y; &#125;;  <span class="hljs-comment">// 将障碍物位置映射为唯一的值</span><br>        std::unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : obstacles) &#123;<br>            s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">f</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : commands) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-2</span>) &#123;<br>                k = (k + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向左转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-1</span>) &#123;<br>                k = (k + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向右转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (c-- &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> nx = x + dirs[k], ny = y + dirs[k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">f</span>(nx, ny))) &#123;<br>                        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 遇到障碍物</span><br>                    &#125;<br>                    x = nx;<br>                    y = ny;<br>                    ans = std::<span class="hljs-built_in">max</span>(ans, x * x + y * y);  <span class="hljs-comment">// 计算离原点的距离的平方</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br><br><br>字母异位词分组<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(std::vector&lt;std::string&gt;&amp; strs) &#123;<br>        std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; h;  <span class="hljs-comment">// 哈希表，键是排序后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strs) &#123;<br>            std::string key = str;<br>            std::<span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 将字符串排序</span><br>            h[key].<span class="hljs-built_in">push_back</span>(str);  <span class="hljs-comment">// 将原始字符串加入哈希表</span><br>        &#125;<br>        <br>        std::vector&lt;std::vector&lt;std::string&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : h) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(p.second);  <span class="hljs-comment">// 收集结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h1 id="六-前缀和"><a href="#六-前缀和" class="headerlink" title="六.前缀和"></a>六.前缀和</h1><h3 id="1-前缀和数组（Prefix-Sum-Array，S）："><a href="#1-前缀和数组（Prefix-Sum-Array，S）：" class="headerlink" title="1. 前缀和数组（Prefix Sum Array，S）："></a>1. <strong>前缀和数组（Prefix Sum Array，S）</strong>：</h3><ul>
<li><p>定义：前缀和数组是用于快速计算数组任意区间和的辅助数组。<code>S[i]</code> 表示从数组开头到第 <code>i</code> 个元素的累加和。</p>
</li>
<li><p>公式：</p>
<ul>
<li>基本公式：<code>S[i] = S[i-1] + A[i]</code></li>
<li>区间和公式：要计算原数组 <code>A</code> 中 <code>[i, j]</code> 区间的和，可以使用前缀和数组：<code>sum(i, j) = S[j] - S[i-1]</code>。</li>
</ul>
</li>
<li><p>例子分析：</p>
<ul>
<li>假设 <code>A = [1, 1, 2, 1, 1]</code>，要求找到连续子数组的和等于 <code>k = 3</code> 的子数组个数。</li>
<li><strong>思路</strong>：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。</li>
</ul>
</li>
</ul>
<h3 id="2-实现代码（子数组和问题）："><a href="#2-实现代码（子数组和问题）：" class="headerlink" title="2. 实现代码（子数组和问题）："></a>2. <strong>实现代码（子数组和问题）</strong>：</h3><ul>
<li><strong>代码</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>    <span class="hljs-type">var</span> <span class="hljs-variable">sums</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-type">var</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;(); <span class="hljs-comment">// 用于记录前缀和出现的次数</span><br>    count.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始前缀和为0时，计数为1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        sums[i] = sums[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算前缀和</span><br>        <span class="hljs-keyword">if</span> (count.containsKey(sums[i] - k)) &#123;<br>            ans += count.get(sums[i] - k); <span class="hljs-comment">// 检查是否存在符合条件的前缀和</span><br>        &#125;<br>        count.put(sums[i], count.getOrDefault(sums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新前缀和的计数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>解析</strong>：<ul>
<li><code>sums[i]</code> 表示到数组的第 <code>i</code> 个元素的前缀和。</li>
<li>哈希表 <code>count</code> 用来存储每个前缀和出现的次数。</li>
<li>对于每个位置 <code>i</code>，我们查看是否存在某个前缀和 <code>sums[j]</code>，使得 <code>sums[i] - sums[j] = k</code>。如果存在，则说明从 <code>j</code> 到 <code>i</code> 的子数组和为 <code>k</code>，将符合条件的子数组计数加一。</li>
</ul>
</li>
</ul>
<h3 id="3-最大子数组和问题（Max-Subarray-Sum-Problem）："><a href="#3-最大子数组和问题（Max-Subarray-Sum-Problem）：" class="headerlink" title="3. 最大子数组和问题（Max Subarray Sum Problem）："></a>3. <strong>最大子数组和问题（Max Subarray Sum Problem）</strong>：</h3><ul>
<li><p>问题描述：给定一个整数数组，要求找到其最大子数组的和。子数组的定义是数组中连续的一部分元素。</p>
</li>
<li><p><strong>思路</strong>：</p>
<ul>
<li>可以通过前缀和的方式来求解最大子数组和问题。</li>
<li>同时我们需要一个 <code>preMin</code> 数组来记录当前子数组的前缀和中的最小值，以便在当前区间进行减法操作时，获得可能的最大子数组和。</li>
</ul>
</li>
</ul>
<h3 id="4-实现代码（最大子数组和问题）："><a href="#4-实现代码（最大子数组和问题）：" class="headerlink" title="4. 实现代码（最大子数组和问题）："></a>4. <strong>实现代码（最大子数组和问题）</strong>：</h3><ul>
<li><strong>代码</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-type">int</span>[] preMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀最小值数组</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算前缀和</span><br>        preMin[i] = Math.min(preMin[i-<span class="hljs-number">1</span>], s[i]); <span class="hljs-comment">// 维护前缀最小值</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>; <span class="hljs-comment">// 初始化答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = Math.max(ans, s[i] - preMin[i-<span class="hljs-number">1</span>]); <span class="hljs-comment">// 计算最大子数组和</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>解析</strong>：<ul>
<li>前缀和数组 <code>s[i]</code> 存储的是从数组开头到第 <code>i</code> 个元素的累加和。</li>
<li><code>preMin[i]</code> 数组存储的是从开头到第 <code>i</code> 个元素的前缀和中的最小值。</li>
<li>每次在计算 <code>s[i]</code> 时，通过减去当前区间的最小前缀和 <code>preMin[i-1]</code>，就可以得到从某个区间到 <code>i</code> 的最大子数组和。</li>
</ul>
</li>
</ul>
<h3 id="5-额外注释和细节："><a href="#5-额外注释和细节：" class="headerlink" title="5. 额外注释和细节："></a>5. <strong>额外注释和细节</strong>：</h3><ul>
<li>在 <strong>子数组和问题</strong> 中，哈希表 <code>count</code> 的作用非常关键，它可以快速定位前缀和的差值是否已经出现过，并通过查找差值来确定是否存在满足条件的子数组。</li>
<li><strong>前缀和法的核心</strong>：将原始问题中的区间和转换为前缀和的差值问题，进而简化计算，达到提高效率的目的。</li>
<li>在 <strong>最大子数组和问题</strong> 中，通过维护一个 <code>preMin</code> 数组来保存当前子数组的最小前缀和，从而可以通过差值来计算最大和。</li>
<li>代码中的 <code>Math.min</code> 和 <code>Math.max</code> 是用于动态更新当前最优的结果。</li>
<li>详细讲解了如何通过前缀和数组快速计算区间和。</li>
<li>针对不同问题，给出了具体的代码实现并且逐步进行了分析。</li>
<li>重点强调了利用 <code>HashMap</code>（哈希表） 来高效存储和查找前缀和，以及如何动态维护前缀和中的最小值。：</li>
</ul>
<h3 id="一维前缀和及其应用："><a href="#一维前缀和及其应用：" class="headerlink" title="一维前缀和及其应用："></a>一维前缀和及其应用：</h3><ul>
<li>在前面的笔记中，我们介绍了<strong>一维前缀和</strong>的概念以及如何利用前缀和来快速解决区间和问题，特别是对于子数组和等于某个目标值的计数问题，我们使用了前缀和和哈希表结合的方法进行高效解答。此外，<strong>最大子数组和问题</strong>通过前缀和与最小前缀和的差值计算得出答案。</li>
</ul>
<h3 id="二维前缀和（2D-Prefix-Sum）："><a href="#二维前缀和（2D-Prefix-Sum）：" class="headerlink" title="二维前缀和（2D Prefix Sum）："></a>二维前缀和（2D Prefix Sum）：</h3><ul>
<li><p>在本部分的笔记中，前缀和的概念被推广到了二维情况。二维前缀和 <code>S[i][j]</code> 表示的是从矩阵左上角 <code>(1, 1)</code> 到当前坐标 <code>(i, j)</code> 的所有元素的累加和，这一概念让我们能够快速计算任意矩形区域内的元素和。</p>
</li>
<li><p>类似于一维前缀和的区间和公式，二维前缀和的矩形区域和通过前缀和数组快速求解，避免了重复计算。计算区域 <code>(p, q)</code> 到 <code>(i, j)</code> 的矩形区域和的公式为：</p>
<ul>
<li><code>sum(p, q, i, j) = S[i][j] - S[i][q-1] - S[p-1][j] + S[p-1][q-1]</code></li>
</ul>
</li>
<li><p>这种方式不仅能快速处理问题，还能提升算法的时间复杂度，尤其适合处理较大规模的矩阵求和问题。</p>
</li>
</ul>
<h3 id="差分数组及其应用："><a href="#差分数组及其应用：" class="headerlink" title="差分数组及其应用："></a>差分数组及其应用：</h3><ul>
<li><p><strong>差分数组</strong>的引入则为高效区间更新提供了一种新的方法。在解决大规模区间更新问题时，如果直接对原数组进行操作，时间复杂度会比较高，而差分数组通过记录相邻元素之间的差值，在常数时间内更新区间，最后通过前缀和恢复原数组。</p>
</li>
<li><p>例如，在航班预定问题中，差分数组 <code>id</code> 被用来记录每个区间的变化量，最终通过前缀和恢复预定后的航班乘客数量。</p>
</li>
<li><p>差分数组的本质是通过对局部变化的记录和累积，使得区间更新可以在 O(1) 时间内完成，极大优化了需要频繁进行更新操作的场景。</p>
</li>
</ul>
<h3 id="综合总结："><a href="#综合总结：" class="headerlink" title="综合总结："></a>综合总结：</h3><ol>
<li><strong>一维前缀和</strong>解决了基本的区间和问题，同时通过哈希表等技巧，可以处理子数组和计数等高级问题。</li>
<li><strong>二维前缀和</strong>将这一思想推广到矩阵，能够快速求解矩形区域和问题，极大提高了处理二维数据的效率。</li>
<li><strong>差分数组</strong>则提供了高效的区间更新方法，特别适合于需要多次区间操作的场景，在减少时间复杂度方面有显著优势。</li>
</ol>
<hr>
<h1 id="七-双指针"><a href="#七-双指针" class="headerlink" title="七.双指针"></a>七.双指针</h1><h3 id="1-双指针算法的核心思想："><a href="#1-双指针算法的核心思想：" class="headerlink" title="1. 双指针算法的核心思想："></a><strong>1. 双指针算法的核心思想</strong>：</h3><ul>
<li><p><strong>定义</strong>：双指针法是通过两个指针从不同方向（常见的是一头一尾）同时进行遍历，进而达到降低时间复杂度的目的。这种方法尤其适合在有序数组或特定问题中使用，通过一左一右或一前一后两个指针逼近来找到符合条件的解。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ol>
<li><strong>有序数组的查找问题</strong>：在一个排序好的数组中，利用双指针可以快速确定满足条件的两个或多个元素，典型的例子是“两数之和”。</li>
<li><strong>区间内查找问题</strong>：通过双指针从区间两端逐渐缩小范围，避免重复遍历。比如“盛水最多的容器问题”。</li>
<li><strong>多元素组合问题</strong>：像“三数之和”问题，通过固定一个数，再使用双指针寻找另外两个数的组合。</li>
</ol>
</li>
</ul>
<h3 id="2-两数之和问题："><a href="#2-两数之和问题：" class="headerlink" title="2. 两数之和问题："></a><strong>2. 两数之和问题</strong>：</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个有序数组，找到两个数，使得它们的和等于目标值 <code>target</code>。返回这两个数的下标，假定数组内没有重复解。</p>
<h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a><strong>思路分析</strong>：</h4><ul>
<li>因为数组已经排序，直接使用双指针从头和尾同时进行遍历：<ul>
<li>如果左右两指针的元素之和 <code>numbers[i] + numbers[j]</code> 等于目标值，则返回结果。</li>
<li>如果和小于目标值，则左指针右移增加和；</li>
<li>如果和大于目标值，则右指针左移减小和。</li>
</ul>
</li>
<li>该方法的时间复杂度是 O(n)，相比于暴力枚举的 O(n²) 更加高效。</li>
</ul>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 两个指针从数组两端开始</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span> (numbers[i] + numbers[j] == target) &#123;<br>            <span class="hljs-keyword">return</span> &#123;i<span class="hljs-number">+1</span>, j<span class="hljs-number">+1</span>&#125;;  <span class="hljs-comment">// 目标值匹配，返回索引，数组索引从1开始</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[i] + numbers[j] &lt; target) &#123;<br>            i++;  <span class="hljs-comment">// 左指针右移，增加和</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j--;  <span class="hljs-comment">// 右指针左移，减小和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="细节与优化："><a href="#细节与优化：" class="headerlink" title="细节与优化："></a><strong>细节与优化</strong>：</h4><ul>
<li><strong>时间复杂度</strong>：排序数组直接使用双指针只需遍历一次，时间复杂度为 O(n)，非常高效。</li>
<li><strong>边界条件</strong>：确保 <code>i &lt; j</code>，即两个指针不能重叠，避免重复或错误的索引访问。</li>
</ul>
<hr>
<h3 id="3-三数之和问题："><a href="#3-三数之和问题：" class="headerlink" title="3. 三数之和问题："></a><strong>3. 三数之和问题</strong>：</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个数组 <code>nums</code>，找出其中的三个数，使得它们的和为 0。可以假设数组中没有重复解。</p>
<h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a><strong>思路分析</strong>：</h4><ul>
<li><p><strong>固定一个数，求剩下两数之和</strong>：</p>
<ol>
<li>先对数组进行排序，便于使用双指针法。</li>
<li>从第一个元素开始，依次固定一个数 <code>nums[i]</code>，接着利用双指针在剩下的数组部分中寻找两数之和为 <code>-nums[i]</code> 的数对。</li>
<li>为了避免重复解，固定的数和双指针处理时需要跳过相同的元素。</li>
</ol>
</li>
<li><p><strong>详细步骤</strong>：</p>
<ol>
<li>排序数组。</li>
<li>遍历数组中的每一个元素，固定 <code>nums[i]</code>。</li>
<li>在 <code>i</code> 之后的元素中用双指针寻找和为 <code>-nums[i]</code> 的数对。</li>
<li>如果找到满足条件的数对，记录下来，继续遍历时跳过重复元素。</li>
</ol>
</li>
</ul>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 先对数组排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 跳过重复元素</span><br>        <span class="hljs-type">int</span> target = -nums[i];  <span class="hljs-comment">// 目标是找到和为 -nums[i] 的两个数</span><br>        <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-type">int</span> sum = nums[j] + nums[k];<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);  <span class="hljs-comment">// 找到一个解</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j<span class="hljs-number">+1</span>]) j++;  <span class="hljs-comment">// 跳过重复</span><br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k<span class="hljs-number">-1</span>]) k--;  <span class="hljs-comment">// 跳过重复</span><br>                j++; k--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                j++;  <span class="hljs-comment">// 左指针右移，增加和</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k--;  <span class="hljs-comment">// 右指针左移，减小和</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="优化与细节："><a href="#优化与细节：" class="headerlink" title="优化与细节："></a><strong>优化与细节</strong>：</h4><ul>
<li><strong>去重处理</strong>：为了避免重复解，固定数和双指针都需要跳过重复的元素。例如，固定数 <code>nums[i]</code> 相同的情况不再处理，双指针的 <code>nums[j]</code> 和 <code>nums[k]</code> 也需要处理重复的情况。</li>
<li><strong>时间复杂度</strong>：排序时间复杂度为 O(nlogn)，之后遍历和双指针查找的时间复杂度是 O(n²)，总体复杂度为 O(n²)。</li>
</ul>
<hr>
<h3 id="4-盛水最多的容器问题："><a href="#4-盛水最多的容器问题：" class="headerlink" title="4. 盛水最多的容器问题："></a><strong>4. 盛水最多的容器问题</strong>：</h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个数组 <code>height</code>，其中每个元素代表容器壁的高度，找到两个容器壁，使得它们与 X 轴构成的容器能盛最多的水。</p>
<h4 id="思路分析：-2"><a href="#思路分析：-2" class="headerlink" title="思路分析："></a><strong>思路分析</strong>：</h4><ul>
<li><strong>双指针法</strong>：<ol>
<li>通过两个指针分别指向数组的最左和最右位置。</li>
<li>每次计算两根柱子之间的容积：<code>min(height[i], height[j]) * (j - i)</code>。</li>
<li>为了使盛水的容量最大，移动较短的一端指针，试图找到更高的柱子，从而获得更大的面积。</li>
</ol>
</li>
</ul>
<h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));  <span class="hljs-comment">// 计算当前面积并更新最大面积</span><br>        <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) &#123;<br>            i++;  <span class="hljs-comment">// 移动较短的那一端</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j--;  <span class="hljs-comment">// 移动较短的那一端</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="优化与细节：-1"><a href="#优化与细节：-1" class="headerlink" title="优化与细节："></a><strong>优化与细节</strong>：</h4><ul>
<li><strong>双指针法的精髓</strong>：通过移动较短的一端，不断调整容器两壁的位置，试图找到盛水的最大面积。</li>
<li><strong>时间复杂度</strong>：由于只需遍历一次，时间复杂度为 O(n)，是一种高效的解法。</li>
</ul>
<hr>
<h3 id="5-笔记中的重要提示："><a href="#5-笔记中的重要提示：" class="headerlink" title="5. 笔记中的重要提示："></a><strong>5. 笔记中的重要提示</strong>：</h3><h4 id="双指针的本质："><a href="#双指针的本质：" class="headerlink" title="双指针的本质："></a><strong>双指针的本质</strong>：</h4><ul>
<li>双指针的核心思想是通过对称的方式从两端或从不同方向移动，能够在保持线性时间复杂度的同时解决较为复杂的问题，如查找和、最优解等。</li>
<li>无论是“两数之和”、“三数之和”还是“盛水最多的容器”，都通过双指针在适当的场景下提高效率，避免了暴力解法的高时间复杂度。</li>
</ul>
<h4 id="关键细节总结："><a href="#关键细节总结：" class="headerlink" title="关键细节总结："></a><strong>关键细节总结</strong>：</h4><ul>
<li>在处理“两数之和”和“三数之和”问题时，注意通过排序和去重来简化问题，避免重复计算和解的重复。</li>
<li>对于“盛水最多的容器”问题，利用双指针的对称移动特性，可以在 O(n) 时间内获得最优解。</li>
</ul>
<hr>
<p>比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况</p>
<ol>
<li>前缀和（Prefix Sum）<br>适用情况：<br>快速计算数组某个子区间的和：适用于需要多次计算数组某个区间和的场景。<br>区间查询和更新较少：适合静态数组或查询操作远多于更新操作的情况。</li>
<li>差分（Difference Array）<br>适用情况：<br>快速进行区间修改：适用于需要频繁对数组某个区间进行加减操作的场景。<br>需要高效进行批量更新：适合大规模区间更新操作。</li>
<li>双指针（Two Pointers）<br>适用情况：<br>处理有序数组：适用于需要在有序数组或链表中查找、遍历等操作。<br>解决滑动窗口问题：适合在数组或字符串上维护动态区间的问题。</li>
<li>滑动窗口（Sliding Window）<br>适用情况：<br>子数组问题：适用于需要找到数组中满足特定条件的子数组或子字符串的问题。<br>连续子区间：适合处理需要计算连续子区间的问题。</li>
<li>单调栈（Monotonic Stack）<br>适用情况：<br>找到数组中每个元素的下一个更大（或更小）元素：适用于需要在数组中找到特定方向上的极值问题。<br>维护区间单调性：适合处理需要保持区间单调性的问题。</li>
</ol>
<hr>
<h1 id="八-递归"><a href="#八-递归" class="headerlink" title="八.递归"></a>八.递归</h1><h3 id="1-回溯法的核心思想："><a href="#1-回溯法的核心思想：" class="headerlink" title="1. 回溯法的核心思想："></a><strong>1. 回溯法的核心思想</strong>：</h3><ul>
<li><strong>定义</strong>：回溯法是一种通过递归逐步生成解空间，遇到不满足条件时及时回溯到上一个状态的算法，通常用于解决排列组合、子集、路径等问题。</li>
<li><strong>基本框架</strong>：<ul>
<li>在递归中不断尝试新的可能性，当某种解不满足条件时，回溯到上一层继续尝试其他分支。</li>
<li>常见问题包括：全排列、组合、子集生成、N皇后等。</li>
<li><strong>剪枝优化</strong>：为了避免不必要的搜索，常常通过提前判断，进行剪枝操作。</li>
</ul>
</li>
</ul>
<h3 id="2-子集问题（Subsets）："><a href="#2-子集问题（Subsets）：" class="headerlink" title="2. 子集问题（Subsets）："></a><strong>2. 子集问题（Subsets）</strong>：</h3><p>给定一个数组 <code>nums</code>，要求生成所有的子集。</p>
<h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归生成子集</strong>：<ul>
<li>每次递归选择是否将当前元素加入子集。</li>
<li>遍历整个数组，生成所有可能的子集。</li>
</ul>
</li>
<li><strong>回溯的实现</strong>：<ul>
<li>使用一个 <code>chosen</code> 数组保存当前已经选择的元素，递归时选择是否添加当前元素，完成后回溯（撤销选择）。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">recur</span>(nums, <span class="hljs-number">0</span>, chosen, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, vector&lt;<span class="hljs-type">int</span>&gt;&amp; chosen, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == nums.<span class="hljs-built_in">size</span>()) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(chosen);  <span class="hljs-comment">// 记录结果</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">recur</span>(nums, i<span class="hljs-number">+1</span>, chosen, ans);  <span class="hljs-comment">// 不选 nums[i]</span><br>    chosen.<span class="hljs-built_in">push_back</span>(nums[i]);  <span class="hljs-comment">// 选择 nums[i]</span><br>    <span class="hljs-built_in">recur</span>(nums, i<span class="hljs-number">+1</span>, chosen, ans);  <span class="hljs-comment">// 递归下一个元素</span><br>    chosen.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 回溯，撤销选择</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>回溯过程</strong>：递归的过程中不断选择是否包含当前元素，形成子集。每当一个选择完成后，回溯撤销上一步的选择，继续探索下一个可能的解。</li>
<li><strong>时间复杂度</strong>：O(2^n)，每个元素都有两种选择（选择或不选择）。</li>
</ul>
<hr>
<h3 id="3-组合问题（Combinations）："><a href="#3-组合问题（Combinations）：" class="headerlink" title="3. 组合问题（Combinations）："></a><strong>3. 组合问题（Combinations）</strong>：</h3><p>给定整数 <code>n</code> 和 <code>k</code>，从 <code>[1, 2, ..., n]</code> 中选择 <code>k</code> 个数的所有组合。</p>
<h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归生成组合</strong>：<ul>
<li>遍历 <code>[1, n]</code> 中的每一个数，每次递归选择或不选择该数，直到选满 <code>k</code> 个数。</li>
<li>剪枝优化：当剩下的元素数量不足以填满 <code>k</code> 个数时可以提前结束递归。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    <span class="hljs-built_in">recur</span>(<span class="hljs-number">1</span>, n, k, chosen, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; chosen, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (chosen.<span class="hljs-built_in">size</span>() == k) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(chosen);  <span class="hljs-comment">// 找到一个组合</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= n; i++) &#123;<br>        chosen.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">// 选择当前数</span><br>        <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>, n, k, chosen, ans);  <span class="hljs-comment">// 递归下一层</span><br>        chosen.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 回溯，撤销选择</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>递归选择与回溯</strong>：从 <code>1</code> 到 <code>n</code> 的数中逐个选择，直到选满 <code>k</code> 个数，每次选择完后回溯撤销选择。</li>
<li><strong>剪枝优化</strong>：当剩余数不足 <code>k - chosen.size()</code> 时，直接结束递归，避免无效操作。</li>
<li><strong>时间复杂度</strong>：O(C(n, k))，组合数的复杂度。</li>
</ul>
<hr>
<h3 id="4-全排列问题（Permutations）："><a href="#4-全排列问题（Permutations）：" class="headerlink" title="4. 全排列问题（Permutations）："></a><strong>4. 全排列问题（Permutations）</strong>：</h3><p>给定一个不包含重复数字的数组 <code>nums</code>，要求生成所有可能的全排列。</p>
<h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归生成全排列</strong>：<ul>
<li>每次递归选择一个尚未使用的数，直到所有数都被选过。</li>
<li>使用一个布尔数组 <code>used</code> 来标记哪些数已经被使用，防止重复使用。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">recur</span>(nums, <span class="hljs-number">0</span>, chosen, used, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> pos, vector&lt;<span class="hljs-type">int</span>&gt;&amp; chosen, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos == nums.<span class="hljs-built_in">size</span>()) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(chosen);  <span class="hljs-comment">// 找到一个排列</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>            used[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为使用</span><br>            chosen.<span class="hljs-built_in">push_back</span>(nums[i]);  <span class="hljs-comment">// 选择当前数</span><br>            <span class="hljs-built_in">recur</span>(nums, pos + <span class="hljs-number">1</span>, chosen, used, ans);  <span class="hljs-comment">// 递归下一层</span><br>            chosen.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 回溯，撤销选择</span><br>            used[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记为未使用</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>回溯与排列</strong>：每次递归选择一个未使用的数，直到所有数都被选过，形成一个排列。回溯时撤销选择并将数标记为未使用。</li>
<li><strong>时间复杂度</strong>：O(n!)，全排列的复杂度，每次递归需要遍历未使用的元素。</li>
</ul>
<hr>
<h3 id="5-反转二叉树（Invert-Binary-Tree）："><a href="#5-反转二叉树（Invert-Binary-Tree）：" class="headerlink" title="5. 反转二叉树（Invert Binary Tree）："></a><strong>5. 反转二叉树（Invert Binary Tree）</strong>：</h3><p>该问题要求对一个二叉树进行左右子树的交换。</p>
<h4 id="算法思路：-3"><a href="#算法思路：-3" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归反转左右子树</strong>：<ul>
<li>对当前节点的左右子树递归交换。</li>
<li>递归终止条件是当前节点为空。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-6"><a href="#代码实现：-6" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 空节点返回</span><br>    TreeNode* temp = root-&gt;left;  <span class="hljs-comment">// 交换左右子树</span><br>    root-&gt;left = root-&gt;right;<br>    root-&gt;right = temp;<br>    <span class="hljs-built_in">invertTree</span>(root-&gt;left);  <span class="hljs-comment">// 递归反转左子树</span><br>    <span class="hljs-built_in">invertTree</span>(root-&gt;right);  <span class="hljs-comment">// 递归反转右子树</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>递归反转过程</strong>：从根节点开始，对每个节点的左右子树进行交换，并递归处理子树。</li>
<li><strong>时间复杂度</strong>：O(n)，每个节点遍历一次。</li>
</ul>
<h3 id="6-总结："><a href="#6-总结：" class="headerlink" title="6. 总结："></a><strong>6. 总结</strong>：</h3><ul>
<li><strong>回溯法</strong>是一种经典的递归算法，适用于组合、排列、子集等问题。其核心思想是在递归过程中通过试探的方式逐步生成解，遇到不满足条件的解时回溯到上一步重新尝试。</li>
<li><strong>子集与组合</strong>：通过回溯生成所有可能的子集或组合，并在递归过程中进行剪枝优化。</li>
<li><strong>全排列</strong>：回溯法生成全排列时，需要通过标记已使用的元素来避免重复使用元素。</li>
<li><strong>二叉树的递归操作</strong>：类似反转二叉树等问题可以通过递归方式简化操作，每次递归处理左右子树即可。</li>
</ul>
<p>这些笔记展示了回溯法在多种问题中的应用，并提供了相应的递归实现。</p>
<hr>
<h1 id="九-分治"><a href="#九-分治" class="headerlink" title="九.分治"></a>九.分治</h1><h3 id="1-分治算法（Divide-and-Conquer）："><a href="#1-分治算法（Divide-and-Conquer）：" class="headerlink" title="1. 分治算法（Divide and Conquer）："></a><strong>1. 分治算法（Divide and Conquer）</strong>：</h3><ul>
<li><strong>定义</strong>：将原问题划分为若干个相同或相似的子问题，递归求解子问题，然后将各个子问题的解合并成原问题的解。</li>
<li><strong>应用场景</strong>：分治法常用于大规模问题的解决，比如快速排序、归并排序、矩阵乘法等。</li>
<li><strong>要点</strong>：<ul>
<li>将问题分成若干子问题；</li>
<li>分别递归求解每个子问题；</li>
<li>合并子问题的解得到最终解。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-递归实现-pow-x-n-问题："><a href="#2-递归实现-pow-x-n-问题：" class="headerlink" title="2. 递归实现 pow(x, n) 问题："></a><strong>2. 递归实现 <code>pow(x, n)</code> 问题</strong>：</h3><p>计算 <code>x</code> 的 <code>n</code> 次方。</p>
<h4 id="算法思路：-4"><a href="#算法思路：-4" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归公式</strong>：<ul>
<li>如果 <code>n</code> 为偶数，<code>pow(x, n) = pow(x, n / 2) * pow(x, n / 2)</code>。</li>
<li>如果 <code>n</code> 为奇数，<code>pow(x, n) = pow(x, (n - 1) / 2) * pow(x, (n - 1) / 2) * x</code>。</li>
<li>如果 <code>n</code> 为负数，则 <code>pow(x, n) = 1 / pow(x, -n)</code>。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-7"><a href="#代码实现：-7" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 任何数的 0 次方都等于 1</span><br>    <span class="hljs-keyword">if</span> (n == INT_MIN) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">myPow</span>(x, -(n<span class="hljs-number">+1</span>)) * x);  <span class="hljs-comment">// 处理 n 为最小负数的特殊情况</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-built_in">myPow</span>(x, -n);  <span class="hljs-comment">// 负数次幂</span><br>    <span class="hljs-type">double</span> temp = <span class="hljs-built_in">myPow</span>(x, n / <span class="hljs-number">2</span>);  <span class="hljs-comment">// 递归计算</span><br>    <span class="hljs-type">double</span> ans = temp * temp;  <span class="hljs-comment">// 平方</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ans *= x;  <span class="hljs-comment">// 处理奇数次幂</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>时间复杂度</strong>：O(log n)，递归每次将 <code>n</code> 减半。</li>
<li><strong>空间复杂度</strong>：O(log n)，递归调用栈的深度。</li>
</ul>
<hr>
<h3 id="3-括号生成问题（Generate-Parentheses）："><a href="#3-括号生成问题（Generate-Parentheses）：" class="headerlink" title="3. 括号生成问题（Generate Parentheses）："></a><strong>3. 括号生成问题（Generate Parentheses）</strong>：</h3><p>给定整数 <code>n</code>，生成所有可能的包含 <code>n</code> 对括号的有效组合。</p>
<h4 id="算法思路：-5"><a href="#算法思路：-5" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>使用递归生成所有括号组合，依次生成 <code>k</code> 对括号与 <code>n-k</code> 对括号的组合，再将它们合并。</li>
<li><strong>递归优化</strong>：通过 <code>unordered_map</code> 缓存中间结果，避免重复计算（记忆化搜索）。</li>
</ul>
<h4 id="代码实现：-8"><a href="#代码实现：-8" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;  <span class="hljs-comment">// 基本情况，n=0时返回空字符串</span><br>    <span class="hljs-keyword">if</span> (store.<span class="hljs-built_in">find</span>(n) != store.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> store[n];  <span class="hljs-comment">// 如果已经计算过，直接返回缓存的结果</span><br>    <br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;  <span class="hljs-comment">// 遍历所有可能的 k 值</span><br>        vector&lt;string&gt; A = <span class="hljs-built_in">generateParenthesis</span>(k - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 生成 k-1 对括号</span><br>        vector&lt;string&gt; B = <span class="hljs-built_in">generateParenthesis</span>(n - k);  <span class="hljs-comment">// 生成 n-k 对括号</span><br>        <span class="hljs-keyword">for</span> (string&amp; a : A) &#123;<br>            <span class="hljs-keyword">for</span> (string&amp; b : B) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;(&quot;</span> + a + <span class="hljs-string">&quot;)&quot;</span> + b);  <span class="hljs-comment">// 将两部分组合</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    store[n] = ans;  <span class="hljs-comment">// 缓存当前 n 对括号的所有组合</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;string&gt;&gt; store;  <span class="hljs-comment">// 用于记忆化搜索，避免重复计算</span><br></code></pre></td></tr></table></figure>

<h4 id="分析：-5"><a href="#分析：-5" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>记忆化搜索</strong>：通过 <code>unordered_map</code> 缓存递归中间结果，避免重复计算，提升效率。</li>
<li><strong>时间复杂度</strong>：理论上为 O(4^n &#x2F; sqrt(n))，因为每次递归生成所有可能的括号组合。</li>
</ul>
<hr>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4. 总结："></a><strong>4. 总结</strong>：</h3><ul>
<li><strong>分治法</strong>是一种强大的算法思想，适用于将大问题分解为小问题的场景，通过递归求解小问题来解决大问题。</li>
<li><strong>递归优化</strong>：在实现递归算法时，可以通过<strong>记忆化搜索</strong>等方式来优化重复计算问题，大大提升算法的效率。</li>
<li><strong>递归框架</strong>：很多复杂问题都可以通过递归分解为子问题来解决，比如 <code>pow</code> 问题通过递归将指数减半、括号生成问题通过递归生成不同数量括号的组合等。</li>
</ul>
<hr>
<h1 id="十-二叉树"><a href="#十-二叉树" class="headerlink" title="十.二叉树"></a>十.二叉树</h1><h3 id="1-二叉树的定义和遍历方式："><a href="#1-二叉树的定义和遍历方式：" class="headerlink" title="1. 二叉树的定义和遍历方式："></a>1. 二叉树的定义和遍历方式：</h3><ul>
<li>二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。</li>
<li><strong>遍历方式</strong>：<ul>
<li><strong>前序遍历</strong>（Pre-order Traversal）：按根节点 -&gt; 左子树 -&gt; 右子树的顺序遍历。</li>
<li><strong>中序遍历</strong>（In-order Traversal）：按左子树 -&gt; 根节点 -&gt; 右子树的顺序遍历。</li>
<li><strong>后序遍历</strong>（Post-order Traversal）：按左子树 -&gt; 右子树 -&gt; 根节点的顺序遍历。</li>
<li><strong>层次遍历</strong>（Level-order Traversal）：按层从上到下、从左到右的顺序遍历树节点。</li>
</ul>
</li>
</ul>
<h4 id="遍历方式总结："><a href="#遍历方式总结：" class="headerlink" title="遍历方式总结："></a><strong>遍历方式总结</strong>：</h4><h3 id="2-前序遍历的递归实现："><a href="#2-前序遍历的递归实现：" class="headerlink" title="2. 前序遍历的递归实现："></a><strong>2. 前序遍历的递归实现</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; seq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> seq;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    seq.add(root.val);<br>    dfs(root.left);<br>    dfs(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong>：使用递归的方式遍历树，先访问当前节点，然后递归访问左子树和右子树。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h3 id="3-后序遍历的递归实现："><a href="#3-后序遍历的递归实现：" class="headerlink" title="3. 后序遍历的递归实现："></a><strong>3. 后序遍历的递归实现</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    dfs(root.left);<br>    dfs(root.right);<br>    seq.add(root.val);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong>：先递归遍历左子树，再递归遍历右子树，最后访问根节点。</li>
</ul>
<h3 id="4-树的层次遍历（广度优先搜索）："><a href="#4-树的层次遍历（广度优先搜索）：" class="headerlink" title="4. 树的层次遍历（广度优先搜索）："></a><strong>4. 树的层次遍历（广度优先搜索）</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>    Queue&lt;Pair&lt;Node, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; seq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> seq;<br><br>    q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(root, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.peek().getKey();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> q.poll().getValue();<br><br>        <span class="hljs-keyword">if</span> (depth &gt;= seq.size()) <br>            seq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        seq.get(depth).add(node.val);<br><br>        <span class="hljs-keyword">for</span> (Node child : node.children) &#123;<br>            q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(child, depth + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seq;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong>：使用队列辅助实现层次遍历，每次取出一个节点，并将其所有子节点加入队列。遍历每一层时记录该层的深度。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h3 id="5-根据前序遍历和中序遍历重建二叉树："><a href="#5-根据前序遍历和中序遍历重建二叉树：" class="headerlink" title="5. 根据前序遍历和中序遍历重建二叉树："></a><strong>5. 根据前序遍历和中序遍历重建二叉树</strong>：</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>给定二叉树的前序遍历和中序遍历，重建这棵二叉树。</p>
<h4 id="算法思路：-6"><a href="#算法思路：-6" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>前序遍历的第一个节点是根节点。</li>
<li>在中序遍历中找到根节点的位置，根节点左边的部分是左子树，右边的部分是右子树。</li>
<li>递归构建左子树和右子树。</li>
</ul>
<h4 id="代码实现：-9"><a href="#代码实现：-9" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>    <span class="hljs-built_in">this</span>.preorder = preorder;<br>    <span class="hljs-built_in">this</span>.inorder = inorder;<br>    <span class="hljs-keyword">return</span> build(<span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>&#125;<br><br>TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l1 &gt; r1) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[l1]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l2;<br>    <span class="hljs-keyword">while</span> (inorder[mid] != preorder[l1]) mid++;<br><br>    root.left = build(l1 + <span class="hljs-number">1</span>, l1 + mid - l2, l2, mid - <span class="hljs-number">1</span>);<br>    root.right = build(l1 + mid - l2 + <span class="hljs-number">1</span>, r1, mid + <span class="hljs-number">1</span>, r2);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>分析</strong>：<ul>
<li>前序遍历的第一个元素是当前子树的根节点。</li>
<li>在中序遍历中找到根节点，划分出左子树和右子树。</li>
<li>递归地对左右子树进行同样的处理。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h3 id="6-找到两个节点的最近公共祖先："><a href="#6-找到两个节点的最近公共祖先：" class="headerlink" title="6. 找到两个节点的最近公共祖先："></a><strong>6. 找到两个节点的最近公共祖先</strong>：</h3><h4 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>在二叉树中找到两个节点的最近公共祖先（LCA）。</p>
<h4 id="算法思路：-7"><a href="#算法思路：-7" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>对每个节点递归判断：<ul>
<li>如果节点等于 p 或 q，则返回当前节点。</li>
<li>如果左右子树分别找到了 p 和 q，则当前节点为最近公共祖先。</li>
<li>如果只有一侧找到 p 或 q，则返回这一侧的结果。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-10"><a href="#代码实现：-10" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>    <span class="hljs-built_in">this</span>.p = p;<br>    <span class="hljs-built_in">this</span>.q = q;<br>    <span class="hljs-keyword">return</span> dfs(root);<br>&#125;<br><br>TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(root.left);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(root.right);<br><br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">return</span> left != <span class="hljs-literal">null</span> ? left : right;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>分析</strong>：<ul>
<li>通过递归遍历整棵树，当一个节点的左右子树分别找到 p 和 q 时，该节点即为最近公共祖先。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
</li>
</ul>
<h3 id="7-笔记中还涉及的图和链表相关的补充知识："><a href="#7-笔记中还涉及的图和链表相关的补充知识：" class="headerlink" title="7. 笔记中还涉及的图和链表相关的补充知识："></a><strong>7. 笔记中还涉及的图和链表相关的补充知识</strong>：</h3><ul>
<li><strong>广度优先搜索（BFS）与深度优先搜索（DFS）</strong>：图的遍历方式类似于树的层次遍历和前序遍历。</li>
<li><strong>动态规划问题</strong>：如矩阵路径求解的动态规划方法，使用递推公式求解最短路径或最长路径问题。</li>
<li><strong>链表操作</strong>：涉及链表节点的插入、删除和反转操作，通常通过定义 <code>head</code> 指针和递归方法实现。</li>
</ul>
<hr>
<h1 id="十一-图"><a href="#十一-图" class="headerlink" title="十一.图"></a>十一.图</h1><h3 id="1-图的存储方式："><a href="#1-图的存储方式：" class="headerlink" title="1. 图的存储方式："></a><strong>1. 图的存储方式</strong>：</h3><p>图可以通过多种方式表示，常见的有：</p>
<ul>
<li><p><strong>邻接矩阵</strong>：</p>
<ul>
<li>使用二维数组 <code>graph[MAX_N][MAX_N]</code>，其中 <code>graph[x][y] = 1</code> 表示节点 <code>x</code> 与节点 <code>y</code> 之间有一条边。</li>
<li>适用于稠密图，但在处理稀疏图时会占用大量空间，复杂度为 O(N^2)。</li>
</ul>
</li>
<li><p><strong>邻接表</strong>：</p>
<ul>
<li>使用动态数组 <code>vector&lt;int&gt; graph[MAX_N]</code> 来存储邻接表，每个元素存储与该节点相邻的所有节点。</li>
<li>这种方式更适合稀疏图，复杂度为 O(M)，其中 M 是图中边的数量。</li>
</ul>
</li>
<li><p><strong>链式前向星</strong>：</p>
<ul>
<li>使用结构体数组来存储边的信息，每个边包含两个属性：<code>from</code> 和 <code>to</code> 表示边的起点和终点，以及 <code>next</code> 指向下一条边。</li>
<li><code>head</code> 数组用于记录每个顶点的第一条边。适合空间较紧张的情况。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-图的遍历："><a href="#2-图的遍历：" class="headerlink" title="2. 图的遍历："></a><strong>2. 图的遍历</strong>：</h3><p>图的遍历包括深度优先搜索（DFS）和广度优先搜索（BFS）。</p>
<h4 id="DFS（深度优先搜索）："><a href="#DFS（深度优先搜索）：" class="headerlink" title="DFS（深度优先搜索）："></a><strong>DFS（深度优先搜索）</strong>：</h4><ul>
<li><strong>递归实现</strong>：<ul>
<li>使用递归来实现 DFS，首先访问当前节点，然后递归访问与当前节点相连的节点。</li>
<li>常用于检测图中是否存在环、连通分量的统计等问题。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-11"><a href="#代码实现：-11" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点已访问</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, to, visited);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-环检测："><a href="#3-环检测：" class="headerlink" title="3. 环检测："></a><strong>3. 环检测</strong>：</h3><p>环检测是一个典型的图论问题，通常使用 DFS 来实现。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路</strong>：</h4><ul>
<li><strong>DFS 实现环检测</strong>：<ul>
<li>在进行 DFS 时，如果当前节点已经被访问过且是祖先节点，则说明存在环。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-12"><a href="#代码实现：-12" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; onPath)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点为已访问</span><br>    onPath[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点位于递归路径上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, to, visited, onPath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (onPath[v]) &#123;<br>            hasCycle = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 检测到环</span><br>        &#125;<br>    &#125;<br>    onPath[u] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 递归结束后，移除路径上的节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-拓扑排序："><a href="#4-拓扑排序：" class="headerlink" title="4. 拓扑排序："></a><strong>4. 拓扑排序</strong>：</h3><p>拓扑排序是对有向无环图（DAG）节点的排序，使得对于每条边 <code>(u, v)</code>，节点 <code>u</code> 在节点 <code>v</code> 之前被排序。</p>
<h4 id="算法思路：-8"><a href="#算法思路：-8" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>拓扑排序可以通过<strong>广度优先搜索（BFS）</strong>和<strong>DFS</strong>实现。</li>
<li><strong>入度表</strong>：使用一个数组 <code>inDeg</code> 来记录每个节点的入度。在 BFS 中，每次选择入度为 0 的节点，将其移出图，并更新其相邻节点的入度。</li>
<li><strong>BFS 实现</strong>：<ol>
<li>先将所有入度为 0 的节点加入队列。</li>
<li>从队列中取出节点，将其从图中移除，并更新其相邻节点的入度。</li>
<li>重复该过程，直到队列为空。如果存在未处理的节点，说明图中存在环。</li>
</ol>
</li>
</ul>
<h4 id="代码实现：-13"><a href="#代码实现：-13" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(numCourses);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDeg</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 构建邻接表并计算入度</span><br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre : prerequisites) &#123;<br>        <span class="hljs-type">int</span> a = pre[<span class="hljs-number">0</span>], b = pre[<span class="hljs-number">1</span>];<br>        to[b].<span class="hljs-built_in">push_back</span>(a);<br>        inDeg[a]++;<br>    &#125;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// 将所有入度为 0 的节点入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> lessonCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        lessonCount++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>            inDeg[v]--;<br>            <span class="hljs-keyword">if</span> (inDeg[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lessonCount == numCourses;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-6"><a href="#分析：-6" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>入度为 0 的节点优先处理</strong>，广度优先搜索的过程类似于层次遍历。</li>
<li><strong>时间复杂度</strong>：O(V + E)，其中 V 为节点数量，E 为边数量。</li>
</ul>
<hr>
<h3 id="5-课程安排问题："><a href="#5-课程安排问题：" class="headerlink" title="5. 课程安排问题："></a><strong>5. 课程安排问题</strong>：</h3><h4 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>给定 <code>numCourses</code> 门课程和它们之间的先修课程关系 <code>prerequisites</code>，判断是否可以完成所有课程。</p>
<h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a><strong>解决思路</strong>：</h4><ul>
<li>使用<strong>拓扑排序</strong>判断是否存在环。如果图中存在环，则课程安排存在冲突，无法完成所有课程。</li>
<li>使用 DFS 或 BFS 实现拓扑排序，并检测是否存在环。</li>
</ul>
<h4 id="代码实现：-14"><a href="#代码实现：-14" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pre : prerequisites) &#123;<br>        graph[pre[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(pre[<span class="hljs-number">0</span>]);<br>        inDegree[pre[<span class="hljs-number">0</span>]]++;<br>    &#125;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 入度为0的课程可以先学习</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> curr = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        count++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[curr]) &#123;<br>            inDegree[neighbor]--;<br>            <span class="hljs-keyword">if</span> (inDegree[neighbor] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(neighbor);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> count == numCourses;  <span class="hljs-comment">// 如果学习的课程数等于课程总数，则可以完成所有课程</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>图的表示方式</strong>：通过邻接矩阵、邻接表或链式前向星表示图结构，适应不同的场景和空间复杂度要求。</li>
<li><strong>图的遍历</strong>：DFS 和 BFS 是图的两种基本遍历方式，DFS 常用于连通分量、环检测，BFS 常用于最短路径和拓扑排序。</li>
<li><strong>拓扑排序</strong>：基于入度的 BFS 是一种高效的拓扑排序方法，广泛应用于课程安排、任务调度等场景。</li>
<li><strong>环检测与课程安排</strong>：通过 DFS 或 BFS 进行环检测，确定是否存在循环依赖，从而判断课程能否按要求完成。</li>
</ul>
<hr>
<h1 id="十二-搜索"><a href="#十二-搜索" class="headerlink" title="十二.搜索"></a>十二.搜索</h1><h3 id="1-状态与状态空间搜索："><a href="#1-状态与状态空间搜索：" class="headerlink" title="1. 状态与状态空间搜索："></a><strong>1. 状态与状态空间搜索</strong>：</h3><ul>
<li><p><strong>状态</strong>：状态表示问题的每一个可能的配置。状态可以看作图中的一个顶点，状态的转移则对应图中的边。状态空间的搜索通常用于解决某些搜索问题，如寻找最优解、遍历所有可能的解等。</p>
</li>
<li><p><strong>搜索算法</strong>：</p>
<ul>
<li><strong>深度优先搜索（DFS）</strong>：优先探索当前路径，深入到不能继续为止，再进行回溯。适用于需要遍历整棵搜索树或图的场景。</li>
<li><strong>广度优先搜索（BFS）</strong>：按照层次逐步扩展所有状态，适用于最短路径等需要找到最早解的场景。</li>
</ul>
</li>
</ul>
<h4 id="状态搜索的步骤："><a href="#状态搜索的步骤：" class="headerlink" title="状态搜索的步骤："></a><strong>状态搜索的步骤</strong>：</h4><ul>
<li><strong>确定初始状态</strong>：选择问题的起始状态，通常是一个明确的初始条件。</li>
<li><strong>确定状态转移</strong>：定义状态如何从一个状态转移到下一个状态，类似于图中的边。</li>
<li><strong>搜索终止条件</strong>：根据问题的性质，设置搜索的结束条件。</li>
</ul>
<h4 id="DFS-和-BFS-的比较："><a href="#DFS-和-BFS-的比较：" class="headerlink" title="DFS 和 BFS 的比较："></a><strong>DFS 和 BFS 的比较</strong>：</h4><ul>
<li><strong>DFS</strong>：在找到目标解之前，会不断深入搜索某条路径。适用于找到所有解，或不关心最优解的场景。</li>
<li><strong>BFS</strong>：逐层扩展搜索，通常用于寻找最优解或最短路径。</li>
</ul>
<hr>
<h3 id="2-电话号码的字母组合问题："><a href="#2-电话号码的字母组合问题：" class="headerlink" title="2. 电话号码的字母组合问题："></a><strong>2. 电话号码的字母组合问题</strong>：</h3><h4 id="问题描述：-3"><a href="#问题描述：-3" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话按键一致。</p>
<p>例如：</p>
<ul>
<li>输入：”23”</li>
<li>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li>
</ul>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路</strong>：</h4><ul>
<li><strong>递归（DFS）实现</strong>：该问题可以被看作是一个递归问题，每个数字对应多个字母，每个数字的字母组合都与前一个数字的字母组合进行全排列。</li>
<li><strong>状态转移</strong>：每个状态表示当前递归到第几个数字，每次递归时选择对应数字所映射的字母，生成所有可能的字母组合。</li>
</ul>
<h4 id="代码实现：-15"><a href="#代码实现：-15" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <br>    <span class="hljs-keyword">this</span>-&gt;digits = digits;<br>    alphabet[<span class="hljs-string">&#x27;2&#x27;</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;3&#x27;</span>] = <span class="hljs-string">&quot;def&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;4&#x27;</span>] = <span class="hljs-string">&quot;ghi&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;5&#x27;</span>] = <span class="hljs-string">&quot;jkl&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;6&#x27;</span>] = <span class="hljs-string">&quot;mno&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;7&#x27;</span>] = <span class="hljs-string">&quot;pqrs&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;8&#x27;</span>] = <span class="hljs-string">&quot;tuv&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;9&#x27;</span>] = <span class="hljs-string">&quot;wxyz&quot;</span>;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, string str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(str);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取当前数字对应的字母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : alphabet[digits[index]]) &#123;<br>        <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, str + c);  <span class="hljs-comment">// 递归处理下一个数字</span><br>    &#125;<br>&#125;<br><br>string digits;<br>vector&lt;string&gt; ans;<br>unordered_map&lt;<span class="hljs-type">char</span>, string&gt; alphabet;<br></code></pre></td></tr></table></figure>

<h4 id="详细分析："><a href="#详细分析：" class="headerlink" title="详细分析："></a><strong>详细分析</strong>：</h4><ul>
<li><strong>递归过程</strong>：每次递归处理一个数字的所有字母组合，并将结果传递到下一层递归中。直到处理完所有数字后，结果将累积到 <code>ans</code> 中。</li>
<li><strong>时间复杂度</strong>：O(3^n * 4^m)，其中 n 是映射到 3 个字母的数字的数量，m 是映射到 4 个字母的数字的数量。</li>
</ul>
<hr>
<h3 id="3-状态的存储与计算优化："><a href="#3-状态的存储与计算优化：" class="headerlink" title="3. 状态的存储与计算优化："></a><strong>3. 状态的存储与计算优化</strong>：</h3><p>笔记中提到通过<strong>哈希表（unordered_map）</strong>来存储和检索状态，以提高搜索效率。对于类似电话号码字母组合的问题，哈希表用于存储数字与字母的对应关系，方便快速查询。</p>
<h4 id="哈希表应用："><a href="#哈希表应用：" class="headerlink" title="哈希表应用："></a><strong>哈希表应用</strong>：</h4><ul>
<li><strong>存储映射关系</strong>：数字到字母的映射使用 <code>unordered_map</code>，在搜索过程中可以快速查找某个数字对应的字母。</li>
<li><strong>状态去重</strong>：在某些状态搜索问题中，如果某个状态已经被访问过，可以使用哈希表来存储已访问状态，避免重复搜索，提升效率。</li>
</ul>
<hr>
<h3 id="4-其他优化策略："><a href="#4-其他优化策略：" class="headerlink" title="4. 其他优化策略："></a><strong>4. 其他优化策略</strong>：</h3><h4 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a><strong>剪枝</strong>：</h4><p>在状态空间搜索中，剪枝是指提前终止那些不可能产生有效解的状态，减少搜索空间。常见的剪枝条件包括：</p>
<ul>
<li>状态不满足约束条件时，直接返回。</li>
<li>通过某些启发式方法判断该路径无法产生最优解，从而终止进一步搜索。</li>
</ul>
<h4 id="记忆化搜索："><a href="#记忆化搜索：" class="headerlink" title="记忆化搜索："></a><strong>记忆化搜索</strong>：</h4><p>将已经计算过的状态及其结果进行缓存，避免在递归过程中重复计算。电话号码字母组合问题通过字典存储每个数字与字母的映射，就是一种简化的记忆化优化。</p>
<hr>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>状态空间搜索</strong>是一种广泛应用于图遍历和组合问题的技术，主要通过 DFS 和 BFS 实现。对于复杂问题，合理地定义状态和状态转移是关键。</li>
<li><strong>电话号码的字母组合问题</strong>是一个经典的状态搜索问题，通过 DFS 实现可以生成所有可能的组合，借助哈希表存储映射关系提高搜索效率。</li>
<li><strong>递归和剪枝</strong>：在搜索过程中，使用递归和剪枝可以有效减少不必要的计算，提升算法性能。</li>
</ul>
<p>这张笔记介绍了<strong>基因突变问题</strong>，并通过<strong>广度优先搜索（BFS）</strong>求解，最后还总结了<strong>深度优先搜索（DFS）</strong>与<strong>广度优先搜索（BFS）</strong>的适用场景及其特点。以下是详细总结：</p>
<hr>
<h3 id="1-基因突变问题："><a href="#1-基因突变问题：" class="headerlink" title="1. 基因突变问题："></a><strong>1. 基因突变问题</strong>：</h3><h4 id="问题描述：-4"><a href="#问题描述：-4" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><ul>
<li>给定一个初始基因序列 <code>start</code> 和目标基因序列 <code>end</code>，每个基因序列由长度为 8 的字符（A、C、G、T）组成。</li>
<li>通过一次基因突变，可以将一个基因序列中的某个位置的字符变为另一个字符。</li>
<li>还给定了一个基因库 <code>bank</code>，该基因库中的基因序列为合法的突变序列。</li>
<li>问题要求找到从 <code>start</code> 变为 <code>end</code> 的最少突变次数，如果无法完成转换则返回 <code>-1</code>。</li>
</ul>
<h4 id="解法思路："><a href="#解法思路：" class="headerlink" title="解法思路："></a><strong>解法思路</strong>：</h4><ul>
<li><strong>广度优先搜索（BFS）</strong>：每次将当前基因序列的合法突变加入队列，按层次遍历，直到找到目标基因序列为止。</li>
<li><strong>状态表示</strong>：每个基因序列是一个状态。</li>
<li><strong>状态转移</strong>：一次合法突变即为从当前基因序列变为另一个基因序列。</li>
</ul>
<h4 id="代码实现：-16"><a href="#代码实现：-16" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>    <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">hasBank</span><span class="hljs-params">(bank.begin(), bank.end())</span></span>;  <span class="hljs-comment">// 将基因库存入哈希表</span><br>    <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(end) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果目标基因不在基因库中，直接返回-1</span><br>    <br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; depth;  <span class="hljs-comment">// 记录每个基因序列到达的层数（突变次数）</span><br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);  <span class="hljs-comment">// 初始基因序列入队</span><br>    depth[start] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> gene[] = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;  <span class="hljs-comment">// 可变的基因字符</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        string s = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;  <span class="hljs-comment">// 遍历每个位置</span><br>            <span class="hljs-type">char</span> original = s[i];  <span class="hljs-comment">// 保存原始字符</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : gene) &#123;  <span class="hljs-comment">// 尝试变成其他基因字符</span><br>                <span class="hljs-keyword">if</span> (s[i] == c) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 不变的情况跳过</span><br>                s[i] = c;<br>                <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(s) != hasBank.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 如果是合法的突变</span><br>                    <span class="hljs-keyword">if</span> (depth.<span class="hljs-built_in">find</span>(s) == depth.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 如果这个基因序列没有被访问过</span><br>                        depth[s] = depth[q.<span class="hljs-built_in">front</span>()] + <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">if</span> (s == end) <span class="hljs-keyword">return</span> depth[s];  <span class="hljs-comment">// 如果找到目标序列，返回突变次数</span><br>                        q.<span class="hljs-built_in">push</span>(s);  <span class="hljs-comment">// 加入队列</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            s[i] = original;  <span class="hljs-comment">// 恢复原始基因字符</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果遍历结束后没有找到目标基因，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="细节分析："><a href="#细节分析：" class="headerlink" title="细节分析："></a><strong>细节分析</strong>：</h4><ul>
<li><strong>广度优先搜索</strong>：BFS 是一种层次遍历，每次只处理当前层的突变，确保找到的第一个满足条件的路径就是最短路径。</li>
<li><strong>哈希表优化</strong>：基因库和已经访问过的基因序列存储在哈希表中，以便快速查找和去重。</li>
</ul>
<h4 id="时间复杂度：O-n-8-，其中-n-是基因库的大小，8-是基因序列的长度，每个基因序列都需要对每一位进行-4-种变换尝试。"><a href="#时间复杂度：O-n-8-，其中-n-是基因库的大小，8-是基因序列的长度，每个基因序列都需要对每一位进行-4-种变换尝试。" class="headerlink" title="时间复杂度：O(n * 8)，其中 n 是基因库的大小，8 是基因序列的长度，每个基因序列都需要对每一位进行 4 种变换尝试。"></a><strong>时间复杂度</strong>：O(n * 8)，其中 n 是基因库的大小，8 是基因序列的长度，每个基因序列都需要对每一位进行 4 种变换尝试。</h4><hr>
<h3 id="2-DFS-和-BFS-的对比："><a href="#2-DFS-和-BFS-的对比：" class="headerlink" title="2. DFS 和 BFS 的对比："></a><strong>2. DFS 和 BFS 的对比</strong>：</h3><p>笔记还详细总结了 <strong>DFS</strong> 和 <strong>BFS</strong> 的不同适用场景及其特点：</p>
<h4 id="DFS（深度优先搜索）：-1"><a href="#DFS（深度优先搜索）：-1" class="headerlink" title="DFS（深度优先搜索）："></a><strong>DFS（深度优先搜索）</strong>：</h4><ul>
<li><strong>适用场景</strong>：<ul>
<li>适用于树形或图形结构的状态空间搜索，尤其是需要遍历所有可能解的场景。</li>
<li>更适合递归实现，适合处理树或图结构。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>深度优先</strong>：优先探索当前路径，深入到不能继续时才回溯。</li>
<li><strong>需要回溯</strong>：由于优先走到最深处，可能会走很多不必要的路径，因此需要回溯。</li>
<li><strong>应用场景</strong>：如全排列、子集等需要遍历所有可能状态的问题。</li>
</ul>
</li>
</ul>
<h4 id="BFS（广度优先搜索）："><a href="#BFS（广度优先搜索）：" class="headerlink" title="BFS（广度优先搜索）："></a><strong>BFS（广度优先搜索）</strong>：</h4><ul>
<li><strong>适用场景</strong>：<ul>
<li>适用于寻找最短路径类问题，尤其在状态空间搜索中找到从起点到目标的最短步骤。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>广度优先</strong>：按层次遍历，优先处理当前层的节点，逐步扩展到下一层。</li>
<li><strong>最短路径</strong>：BFS 能够确保找到的解是步数最少的解，适合寻找最短路径、最小步数的场景。</li>
<li><strong>应用场景</strong>：如最短路径、最小步数、无权图的最短路径等问题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>基因突变问题</strong>通过 BFS 解决，是一个经典的层次遍历问题。BFS 可以保证找到的路径是最短的，适合解决此类寻找最小步数的问题。</li>
<li><strong>DFS 和 BFS 的适用场景不同</strong>，DFS 更适合于需要遍历所有解的场景，而 BFS 则适合用于最短路径类问题。这两种搜索方法在不同的应用场景下各有优势。</li>
</ul>
<hr>
<h1 id="十三-二分"><a href="#十三-二分" class="headerlink" title="十三.二分"></a>十三.二分</h1><p>各种排序算法 分为基于比较的和非比较的排序 比较：交换 冒泡 快速     插入 插入 希尔     选择 选择 堆     归并 二路 多路 非比较： 计数排序 桶排序 基数排序 用c++语言总结这些算法怎么写,技巧等</p>
<h3 id="1-二分查找的基本实现："><a href="#1-二分查找的基本实现：" class="headerlink" title="1. 二分查找的基本实现："></a><strong>1. 二分查找的基本实现</strong>：</h3><h4 id="问题描述：-5"><a href="#问题描述：-5" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>二分查找用于在有序数组中查找目标值 <code>target</code>，其时间复杂度为 O(log n)。</p>
<h4 id="算法思路：-9"><a href="#算法思路：-9" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>将数组的搜索范围缩小为左边界 <code>left</code> 和右边界 <code>right</code>，每次取中间位置 <code>mid</code> 的值进行比较：<ul>
<li>如果 <code>array[mid] == target</code>，则找到了目标值，返回 <code>mid</code>。</li>
<li>如果 <code>array[mid] &lt; target</code>，则将左边界 <code>left</code> 移动到 <code>mid + 1</code>，缩小搜索范围。</li>
<li>如果 <code>array[mid] &gt; target</code>，则将右边界 <code>right</code> 移动到 <code>mid - 1</code>，缩小搜索范围。</li>
</ul>
</li>
</ul>
<h4 id="C-Java-实现："><a href="#C-Java-实现：" class="headerlink" title="C++&#x2F;Java 实现："></a><strong>C++&#x2F;Java 实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] == target)<br>        <span class="hljs-keyword">return</span> mid;<br>    <span class="hljs-keyword">if</span> (array[mid] &lt; target)<br>        left = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure>

<h4 id="Python-实现："><a href="#Python-实现：" class="headerlink" title="Python 实现："></a><strong>Python 实现</strong>：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(array) - <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> left &lt;= right:<br>    mid = (left + right) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> array[mid] == target:<br>        <span class="hljs-keyword">return</span> mid<br>    <span class="hljs-keyword">elif</span> array[mid] &lt; target:<br>        left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        right = mid - <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-二分查找的变体："><a href="#2-二分查找的变体：" class="headerlink" title="2. 二分查找的变体："></a><strong>2. 二分查找的变体</strong>：</h3><p>除了直接查找目标值外，二分查找还有一些常见的变体，主要用于查找边界值或处理重复元素。</p>
<h4 id="2-1-查找左边界（Lower-Bound）："><a href="#2-1-查找左边界（Lower-Bound）：" class="headerlink" title="2.1 查找左边界（Lower Bound）："></a><strong>2.1 查找左边界（Lower Bound）</strong>：</h4><p>当数组中存在多个相同的元素时，可以使用二分查找的变体来查找第一个等于目标值的位置（即左边界）。</p>
<ul>
<li>在找到目标值时，不直接返回，而是继续缩小右边界 <code>right = mid - 1</code>，直到 <code>left</code> 等于目标值的最小位置。</li>
</ul>
<h4 id="2-2-查找右边界（Upper-Bound）："><a href="#2-2-查找右边界（Upper-Bound）：" class="headerlink" title="2.2 查找右边界（Upper Bound）："></a><strong>2.2 查找右边界（Upper Bound）</strong>：</h4><p>与查找左边界类似，但在找到目标值时，缩小左边界 <code>left = mid + 1</code>，最后返回目标值的最大位置。</p>
<h4 id="查找左边界的代码实现："><a href="#查找左边界的代码实现：" class="headerlink" title="查找左边界的代码实现："></a><strong>查找左边界的代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] &gt;= target)<br>        right = mid;  <span class="hljs-comment">// 缩小右边界</span><br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 缩小左边界</span><br>&#125;<br><span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure>

<h4 id="查找右边界的代码实现："><a href="#查找右边界的代码实现：" class="headerlink" title="查找右边界的代码实现："></a><strong>查找右边界的代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] &gt; target)<br>        right = mid;  <span class="hljs-comment">// 缩小右边界</span><br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 缩小左边界</span><br>&#125;<br><span class="hljs-keyword">return</span> right;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-二分查找的应用场景："><a href="#3-二分查找的应用场景：" class="headerlink" title="3. 二分查找的应用场景："></a><strong>3. 二分查找的应用场景</strong>：</h3><p>二分查找通常用于<strong>有序数组</strong>或<strong>单调函数</strong>的查找问题。通过二分查找可以高效解决以下问题：</p>
<ul>
<li><strong>查找目标值</strong>：直接查找一个值是否存在于有序数组中。</li>
<li><strong>查找插入位置</strong>：通过查找左边界或右边界，可以判断一个目标值应该插入数组的哪个位置，常用于实现<strong>二分插入排序</strong>。</li>
<li><strong>统计某个数的出现次数</strong>：通过查找左边界和右边界，可以快速统计某个数在有序数组中的出现次数。</li>
</ul>
<hr>
<h3 id="4-示例问题："><a href="#4-示例问题：" class="headerlink" title="4. 示例问题："></a><strong>4. 示例问题</strong>：</h3><h4 id="问题描述：-6"><a href="#问题描述：-6" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>已知一个有序数组 <code>10 10 19 25 27 30 32 37 42</code>，现在需要查找大于等于 26 的第一个数字的位置（即使用上边界的二分查找）。</p>
<h4 id="代码实现：-17"><a href="#代码实现：-17" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] &gt;= <span class="hljs-number">26</span>)<br>        right = mid;<br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right;  <span class="hljs-comment">// 返回第一个大于等于 26 的位置</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>二分查找</strong>是一种非常高效的查找算法，尤其适用于在有序数组或单调函数中查找目标值或边界值。</li>
<li>通过变形的二分查找，可以解决查找左边界、右边界、统计重复元素出现次数等问题。</li>
<li>实现二分查找时要注意终止条件和边界处理，确保不会出现死循环或越界问题。</li>
</ul>
<p>这张笔记继续探讨了<strong>二分查找</strong>，并展示了如何在排序数组中找到元素的<strong>第一个和最后一个位置</strong>，同时还探讨了<strong>求平方根的二分法</strong>。以下是详细总结：</p>
<hr>
<h3 id="1-在排序数组中查找元素的第一个和最后一个位置："><a href="#1-在排序数组中查找元素的第一个和最后一个位置：" class="headerlink" title="1. 在排序数组中查找元素的第一个和最后一个位置："></a><strong>1. 在排序数组中查找元素的第一个和最后一个位置</strong>：</h3><h4 id="问题描述：-7"><a href="#问题描述：-7" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>给定一个排序数组和一个目标值 <code>target</code>，要求返回目标值在数组中出现的<strong>第一个和最后一个位置</strong>。如果目标值不在数组中，返回 <code>[-1, -1]</code>。</p>
<h4 id="算法思路：-10"><a href="#算法思路：-10" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><p>该问题可以通过二分查找分别找到目标值的<strong>第一个位置</strong>和<strong>最后一个位置</strong>：</p>
<ul>
<li>使用二分查找的变体分别找到 <code>target</code> 的左边界（第一个出现的位置）和右边界（最后一个出现的位置）。</li>
</ul>
<h4 id="代码实现：-18"><a href="#代码实现：-18" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 找到目标值的第一个位置（左边界）</span><br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= target)<br>        right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 缩小右边界</span><br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 缩小左边界</span><br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(left);  <span class="hljs-comment">// 记录左边界</span><br><br><span class="hljs-comment">// 重置左右边界，寻找目标值的最后一个位置（右边界）</span><br>left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)<br>        left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 缩小左边界</span><br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 缩小右边界</span><br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(right);  <span class="hljs-comment">// 记录右边界</span><br><br><span class="hljs-comment">// 判断是否找到目标值</span><br><span class="hljs-keyword">if</span> (ans[<span class="hljs-number">0</span>] &gt; ans[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a><strong>解释</strong>：</h4><ul>
<li>通过两次二分查找，第一次找到<strong>第一个大于等于目标值的位置</strong>（即左边界），第二次找到<strong>最后一个小于等于目标值的位置</strong>（即右边界）。</li>
<li>最后判断是否找到目标值：如果左边界超过了右边界，说明数组中不存在目标值，返回 <code>[-1, -1]</code>。</li>
</ul>
<hr>
<h3 id="2-平方根的二分查找（整数平方根和精确平方根）："><a href="#2-平方根的二分查找（整数平方根和精确平方根）：" class="headerlink" title="2. 平方根的二分查找（整数平方根和精确平方根）："></a><strong>2. 平方根的二分查找（整数平方根和精确平方根）</strong>：</h3><h4 id="整数平方根："><a href="#整数平方根：" class="headerlink" title="整数平方根："></a><strong>整数平方根</strong>：</h4><p>整数平方根问题可以通过二分法求解，即给定一个非负整数 <code>x</code>，求其平方根的整数部分。</p>
<h4 id="算法思路：-11"><a href="#算法思路：-11" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>初始时将左右边界分别设为 <code>left = 1</code> 和 <code>right = x</code>。</li>
<li>通过二分查找缩小区间，直到找到平方根的整数部分。</li>
</ul>
<h4 id="代码实现：-19"><a href="#代码实现：-19" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">1</span>, right = x;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (mid * mid == x)<br>        <span class="hljs-keyword">return</span> mid;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid * mid &lt; x)<br>        left = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right;  <span class="hljs-comment">// 返回整数部分的平方根</span><br></code></pre></td></tr></table></figure>

<h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a><strong>解释</strong>：</h4><ul>
<li>二分查找的核心是通过判断 <code>mid * mid</code> 和 <code>x</code> 的关系，来调整左右边界，直到找到平方根的整数部分。</li>
<li>最终的答案是 <code>right</code>，因为 <code>right</code> 会指向最接近 <code>x</code> 的平方数。</li>
</ul>
<h4 id="精确平方根："><a href="#精确平方根：" class="headerlink" title="精确平方根："></a><strong>精确平方根</strong>：</h4><p>如果需要更高精度的平方根，可以在整数平方根的基础上进行<strong>小数部分的精确计算</strong>，例如通过二分法细化到小数点后的几位。</p>
<h4 id="精确平方根的代码实现："><a href="#精确平方根的代码实现：" class="headerlink" title="精确平方根的代码实现："></a><strong>精确平方根的代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-type">double</span> left = <span class="hljs-number">0</span>, right = x, eps = <span class="hljs-number">1e-7</span>;  <span class="hljs-comment">// 精度设定为 1e-7</span><br>    <span class="hljs-keyword">while</span> (right - left &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt; x)<br>            left = mid;<br>        <span class="hljs-keyword">else</span><br>            right = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;  <span class="hljs-comment">// 返回精确到小数点后的平方根</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a><strong>解释</strong>：</h4><ul>
<li>精确平方根的思路与整数平方根类似，只不过停止条件是 <code>right - left</code> 小于某个精度 <code>eps</code>，从而确保结果精确到指定的小数位数。</li>
</ul>
<hr>
<h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>二分查找</strong>不仅能解决简单的查找问题，还能通过调整条件找到数组中目标值的边界位置，适用于有序数组的场景。</li>
<li><strong>平方根问题</strong>可以通过二分查找求解，不论是整数平方根还是精确平方根，通过调整精度可以得到不同的结果。</li>
</ul>
<p>这张笔记主要介绍了<strong>三分查找算法</strong>，以及如何应用三分查找解决峰值问题，随后还提到了一个<strong>分割数组</strong>的问题。以下是详细总结：</p>
<hr>
<h3 id="1-三分查找算法："><a href="#1-三分查找算法：" class="headerlink" title="1. 三分查找算法："></a><strong>1. 三分查找算法</strong>：</h3><h4 id="三分查找的适用场景："><a href="#三分查找的适用场景：" class="headerlink" title="三分查找的适用场景："></a><strong>三分查找的适用场景</strong>：</h4><ul>
<li><strong>函数单峰性问题</strong>：三分查找常用于寻找某个函数的极值点，适用于函数在某区间内具有单峰性（即该函数在区间内只有一个极大值或极小值），且能够保证递增或递减的规律。</li>
<li><strong>核心思想</strong>：与二分查找类似，不同之处在于每次将区间分成三份，分别计算中间两点 <code>lmid</code> 和 <code>rmid</code>，通过比较 <code>f(lmid)</code> 和 <code>f(rmid)</code> 的大小，缩小搜索范围。</li>
</ul>
<h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤</strong>：</h4><ul>
<li><strong>比较两点</strong> <code>lmid</code> 和 <code>rmid</code> 的函数值：<ul>
<li>如果 <code>f(lmid) &lt; f(rmid)</code>，则极值位于 <code>lmid</code> 的右边（排除 <code>lmid</code> 左侧区间），所以更新左边界 <code>left = lmid + 1</code>。</li>
<li>否则，极值位于 <code>rmid</code> 的左边（排除 <code>rmid</code> 右侧区间），更新右边界 <code>right = rmid - 1</code>。</li>
</ul>
</li>
<li>不断重复上述过程，直到区间收缩到极值点。</li>
</ul>
<h4 id="代码实现：-20"><a href="#代码实现：-20" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> lmid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> rmid = lmid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[lmid] &lt; nums[rmid])  <span class="hljs-comment">// 如果左中点小于右中点</span><br>        left = lmid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 极值位于右半部分</span><br>    <span class="hljs-keyword">else</span><br>        right = rmid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 极值位于左半部分</span><br>&#125;<br><span class="hljs-keyword">return</span> right;  <span class="hljs-comment">// 返回峰值所在的位置</span><br></code></pre></td></tr></table></figure>

<h4 id="解释：-3"><a href="#解释：-3" class="headerlink" title="解释："></a><strong>解释</strong>：</h4><ul>
<li>该算法通过三分查找，逐渐缩小区间直到找到数组的峰值位置。</li>
<li>在单峰函数中，这种方法能有效找到极值点。</li>
</ul>
<hr>
<h3 id="2-分割数组问题："><a href="#2-分割数组问题：" class="headerlink" title="2. 分割数组问题："></a><strong>2. 分割数组问题</strong>：</h3><h4 id="问题描述：-8"><a href="#问题描述：-8" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>将数组 <code>nums</code> 分成 <code>m</code> 个连续的子数组，使得这些子数组中的<strong>最大和</strong>最小，并保证划分是合理的（即尽量均匀）。</p>
<h4 id="算法思路：-12"><a href="#算法思路：-12" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>通过二分查找来求解最大和的最小值。</li>
<li><strong>初始范围</strong>：最小值为数组中的最大元素，最大值为数组所有元素的和。</li>
<li><strong>判定条件</strong>：给定一个划分值 <code>T</code>，判断能否将数组划分成不超过 <code>m</code> 个子数组，使得每个子数组的和都不大于 <code>T</code>。</li>
</ul>
<h4 id="判定函数："><a href="#判定函数：" class="headerlink" title="判定函数："></a><strong>判定函数</strong>：</h4><ul>
<li>遍历数组，累加当前子数组的和 <code>sum</code>，一旦 <code>sum</code> 超过了 <code>T</code>，就开始划分新的一组，并重置 <code>sum</code>。</li>
<li>如果划分的组数超过了 <code>m</code>，则说明 <code>T</code> 不足够大，需要增大 <code>T</code>；否则，说明 <code>T</code> 是一个可行的值，尝试减小 <code>T</code>。</li>
</ul>
<h4 id="代码实现：-21"><a href="#代码实现：-21" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数组中的最大值</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 数组所有元素的和</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canSplit</span>(nums, mid, m))<br>            right = mid;  <span class="hljs-comment">// 尝试减小最大值</span><br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 增大最大值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canSplit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> maxSum, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        <span class="hljs-keyword">if</span> (sum &gt; maxSum) &#123;  <span class="hljs-comment">// 如果当前子数组的和超过了允许的最大值</span><br>            sum = num;<br>            count++;  <span class="hljs-comment">// 划分出新的子数组</span><br>            <span class="hljs-keyword">if</span> (count &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解释：-4"><a href="#解释：-4" class="headerlink" title="解释："></a><strong>解释</strong>：</h4><ul>
<li><strong>二分查找</strong>：二分查找用于确定最大子数组和的最小可能值。</li>
<li><strong>判定函数</strong>：通过不断尝试不同的 <code>mid</code> 值（即可能的最大子数组和），判断是否能够在不超过 <code>m</code> 次划分的前提下，将数组划分为子数组。</li>
</ul>
<hr>
<h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>三分查找</strong>适用于处理单峰性问题，尤其是在寻找极值点时，能够有效缩小区间。</li>
<li><strong>分割数组问题</strong>使用二分查找来确定最大子数组和的最小值，通过判定函数来检查当前划分是否满足条件。这种思路在需要均匀分配任务或资源时非常常用。</li>
</ul>
<h1 id="十四-排序"><a href="#十四-排序" class="headerlink" title="十四.排序"></a>十四.排序</h1><p>在 C++ 语言中，常见的排序算法可以分为基于比较的和非比较的两类。总结这些算法时，可以从算法的时间复杂度、空间复杂度以及适用场景的角度来进行编写。以下是每种排序算法的简要说明、代码实现和一些技巧：</p>
<h3 id="一、基于比较的排序"><a href="#一、基于比较的排序" class="headerlink" title="一、基于比较的排序"></a>一、基于比较的排序</h3><h4 id="1-交换类排序"><a href="#1-交换类排序" class="headerlink" title="1. 交换类排序"></a>1. 交换类排序</h4><p><strong>(1) 冒泡排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每一轮遍历可以把最大（或最小）的元素放在数组的末尾。</p>
<p><strong>(2) 快速排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(log n)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;<br>        arr[low] = arr[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++;<br>        arr[high] = arr[low];<br>    &#125;<br>    arr[low] = pivot;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(arr, low, high);<br>        <span class="hljs-built_in">quickSort</span>(arr, low, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过分治法将数组划分为较小的子数组，递归排序。</p>
<h4 id="2-插入类排序"><a href="#2-插入类排序" class="headerlink" title="2. 插入类排序"></a>2. 插入类排序</h4><p><strong>(1) 直接插入排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> key = arr[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合小规模数据集，具有局部性特点的数据性能较好。</p>
<p><strong>(2) 希尔排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> key = arr[i];<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;<br>                arr[j] = arr[j - gap];<br>                j -= gap;<br>            &#125;<br>            arr[j] = key;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过缩小增量逐步优化插入排序。</p>
<h4 id="3-选择类排序"><a href="#3-选择类排序" class="headerlink" title="3. 选择类排序"></a>3. 选择类排序</h4><p><strong>(1) 选择排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> minIdx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;<br>                minIdx = j;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每轮找到最小（或最大）值并交换到对应位置。</p>
<p><strong>(2) 堆排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = i;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;<br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;<br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[largest]);<br>        <span class="hljs-built_in">heapify</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-built_in">heapify</span>(arr, n, i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        std::<span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：利用堆结构维护最大或最小堆。</p>
<h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h4><ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n1 = m - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n2 = r - m;<br>    <span class="hljs-type">int</span> L[n1], R[n2];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++) L[i] = arr[l + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; j++) R[j] = arr[m + <span class="hljs-number">1</span> + j];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = l;<br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) arr[k++] = L[i++];<br>        <span class="hljs-keyword">else</span> arr[k++] = R[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; n1) arr[k++] = L[i++];<br>    <span class="hljs-keyword">while</span> (j &lt; n2) arr[k++] = R[j++];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr, l, m);<br>        <span class="hljs-built_in">mergeSort</span>(arr, m + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">merge</span>(arr, l, m, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：递归分割数组，合并时排序。</p>
<h3 id="二、非比较类排序"><a href="#二、非比较类排序" class="headerlink" title="二、非比较类排序"></a>二、非比较类排序</h3><h4 id="1-计数排序"><a href="#1-计数排序" class="headerlink" title="1. 计数排序"></a>1. 计数排序</h4><ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(k)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> max)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count[max + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> output[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[arr[i]]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[arr[i]] - <span class="hljs-number">1</span>] = arr[i];<br>        count[arr[i]]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合范围较小的整数排序。</p>
<h4 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2. 桶排序"></a>2. 桶排序</h4><ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-type">float</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">float</span>&gt; buckets[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> idx = n * arr[i];<br>        buckets[idx].<span class="hljs-built_in">push_back</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::<span class="hljs-built_in">sort</span>(buckets[i].<span class="hljs-built_in">begin</span>(), buckets[i].<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;val : buckets[i]) &#123;<br>            arr[idx++] = val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合分布均匀的实数排序。</p>
<h4 id="3-基数排序"><a href="#3-基数排序" class="headerlink" title="3. 基数排序"></a>3. 基数排序</h4><ul>
<li>时间复杂度：O(nk)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSortForRadix</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> exp)</span> </span>&#123;<br>    <span class="hljs-type">int</span> output[n], count[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[(arr[i] / exp) % <span class="hljs-number">10</span>]++;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[(arr[i] / exp) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = arr[i];<br>        count[(arr[i] / exp) % <span class="hljs-number">10</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = <span class="hljs-built_in">getMax</span>(arr, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> exp = <span class="hljs-number">1</span>; max / exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) <span class="hljs-built_in">countingSortForRadix</span>(arr, n, exp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：按位排序，从低位到高位逐一处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>算法选择</strong>：根据数据的规模、分布特点选择合适的算法。快速排序在多数情况下表现良好，但对于极端情况可能退化；归并排序的稳定性和性能较优但占用额外空间；堆排序在处理大规模数据时表现优异。</li>
<li><strong>非比较排序</strong>：如计数排序、桶排序和基数排序，适合特定场景，通常用于整型或有范围限制的数据。</li>
</ul>
<h1 id="十五-贪心"><a href="#十五-贪心" class="headerlink" title="十五. 贪心"></a>十五. 贪心</h1><h1 id="十六-动态规划"><a href="#十六-动态规划" class="headerlink" title="十六.动态规划"></a>十六.动态规划</h1><h1 id="十七-字典树-并查集"><a href="#十七-字典树-并查集" class="headerlink" title="十七.字典树,并查集"></a>十七.字典树,并查集</h1><h1 id="十八-图论"><a href="#十八-图论" class="headerlink" title="十八.图论"></a>十八.图论</h1><h1 id="十九-字符串处理"><a href="#十九-字符串处理" class="headerlink" title="十九.字符串处理"></a>十九.字符串处理</h1><h1 id="二十-高级搜索"><a href="#二十-高级搜索" class="headerlink" title="二十.高级搜索"></a>二十.高级搜索</h1><h1 id="二十一-平衡二叉树"><a href="#二十一-平衡二叉树" class="headerlink" title="二十一.平衡二叉树"></a>二十一.平衡二叉树</h1><h1 id="二十二-跳跃表"><a href="#二十二-跳跃表" class="headerlink" title="二十二.跳跃表"></a>二十二.跳跃表</h1><h1 id="二十三-线段树"><a href="#二十三-线段树" class="headerlink" title="二十三.线段树"></a>二十三.线段树</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法笔记</div>
      <div>https://theganlove.github.io/2024/09/09/算法笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>uert</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/" title="服务器部署">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">服务器部署</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/08/%E9%9A%90%E5%86%99/" title="隐写">
                        <span class="hidden-mobile">隐写</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
