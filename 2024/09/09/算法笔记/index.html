

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="uert">
  <meta name="keywords" content="">
  
    <meta name="description" content="注意:本笔记代码都是c++，而且为了蓝桥杯做了很大的改变，所以初次学不要按照本笔记 c++代码的基础内容DevC++常用快捷键 F9：编译并运行程序。  Shift + F9：仅编译（不运行）  Ctrl + &#x2F;：注释当前行或选中的代码  Ctrl + Shift + &#x2F;：取消注释  进入 工具 -&gt; 编辑器选项 -&gt; 代码模板，在其中添加你常用的代码片段。例如，可以创建一个 for">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://theganlove.github.io/2024/09/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="注意:本笔记代码都是c++，而且为了蓝桥杯做了很大的改变，所以初次学不要按照本笔记 c++代码的基础内容DevC++常用快捷键 F9：编译并运行程序。  Shift + F9：仅编译（不运行）  Ctrl + &#x2F;：注释当前行或选中的代码  Ctrl + Shift + &#x2F;：取消注释  进入 工具 -&gt; 编辑器选项 -&gt; 代码模板，在其中添加你常用的代码片段。例如，可以创建一个 for">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-09T11:20:21.000Z">
<meta property="article:modified_time" content="2025-04-02T07:57:55.534Z">
<meta property="article:author" content="uert">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算法笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"theganlove.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>主题</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-09 19:20" pubdate>
          2024年9月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          64k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          537 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>注意:本笔记代码都是c++，而且为了蓝桥杯做了很大的改变，所以初次学不要按照本笔记</p>
<h1 id="c-代码的基础内容"><a href="#c-代码的基础内容" class="headerlink" title="c++代码的基础内容"></a>c++代码的基础内容</h1><h2 id="DevC-常用快捷键"><a href="#DevC-常用快捷键" class="headerlink" title="DevC++常用快捷键"></a>DevC++常用快捷键</h2><ol>
<li><p>F9<code>：编译并运行程序。</code></p>
</li>
<li><p>Shift + F9：仅编译（不运行）</p>
</li>
<li><p><code>Ctrl + /</code>：注释当前行或选中的代码</p>
</li>
<li><p><code>Ctrl + Shift + /</code>：取消注释</p>
</li>
<li><p>进入 <code>工具</code> -&gt; <code>编辑器选项</code> -&gt; <code>代码模板</code>，在其中添加你常用的代码片段。例如，可以创建一个 <code>for</code> 循环模板，快速插入到代码中。</p>
</li>
<li><p>打开 Dev C++，点击 <strong>工具</strong> -&gt; <strong>编译选项</strong>。</p>
<p>在 <strong>编译选项</strong> 窗口中，选择 <strong>编译器设置</strong>。</p>
<p>在 <strong>设置</strong> 选项卡下的 <strong>命令行</strong> 中，加入 <code>-std=c++11</code>（或更高版本的标准，如 <code>-std=c++14</code>、<code>-std=c++17</code>）。</p>
</li>
<li><p>ctrl+n开cpp，ctrl+shift+a进行优化代码</p>
</li>
<li><p>背景设置高亮为黑色，模板为obvilition</p>
</li>
</ol>
<p>++++</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul>
<li><p><code>#include &lt;bits/stdc++.h&gt;</code><br>不需要一一手动包含，但是占时间，容易超时，不会再写。不过编译时间无所谓了</p>
</li>
<li><p><code>#include &lt;iostream&gt;</code><br>标准输入输出流，常用对象：<code>std::cin</code>, <code>std::cout</code>, <code>std::cerr</code>, <code>std::endl</code>。</p>
</li>
<li><p><code>#include &lt;string&gt;</code><br>字符串操作，常用类：<code>std::string</code>，常用函数：<code>std::getline</code>。</p>
</li>
<li><p><code>#include &lt;cstring&gt;</code><br>C风格字符串操作，常用函数：<code>strlen</code>, <code>strcpy</code>, <code>strcmp</code>。</p>
</li>
<li><p><code>#include &lt;vector&gt;</code><br>动态数组容器，常用类：<code>std::vector</code>。</p>
</li>
<li><p><code>#include &lt;algorithm&gt;</code><br>通用算法，常用函数：<code>std::sort</code>, <code>std::find</code>, <code>std::max</code>, <code>std::min</code>。</p>
</li>
<li><p><code>#include &lt;map&gt;</code><br>有序键值对容器，常用类：<code>std::map</code>。</p>
</li>
<li><p><code>#include &lt;unordered_map&gt;</code><br>无序键值对容器，常用类：<code>std::unordered_map</code>。</p>
</li>
<li><p><code>#include &lt;unordered_set&gt;</code><br>提供哈希集合，常用类：<code>std::unordered_set</code></p>
</li>
<li><p><code>#include &lt;cmath&gt;</code><br>数学函数，常用函数：<code>std::sqrt</code>, <code>std::pow</code>, <code>std::sin</code>, <code>std::cos</code>。</p>
</li>
<li><p><code>#include &lt;numeric&gt;</code><br>数值操作，常用函数：<code>std::accumulate</code>, <code>std::gcd</code>。</p>
</li>
<li><p><code>#include &lt;utility&gt;</code><br>工具函数，常用类：<code>std::pair</code>。</p>
</li>
</ul>
<h2 id="日期填空题巧用电脑自带Office软件"><a href="#日期填空题巧用电脑自带Office软件" class="headerlink" title="日期填空题巧用电脑自带Office软件"></a>日期填空题巧用电脑自带Office软件</h2><h4 id="求日期差（excel）"><a href="#求日期差（excel）" class="headerlink" title="求日期差（excel）"></a>求日期差（excel）</h4><p>格中输入： </p>
<hr>
<h1 id="蓝桥杯备考"><a href="#蓝桥杯备考" class="headerlink" title="蓝桥杯备考"></a>蓝桥杯备考</h1><p>C++代码中的操作次数控制在 10的7为最佳。64MB相当于10的7个int</p>
<h2 id="N的范围判断算法是什么"><a href="#N的范围判断算法是什么" class="headerlink" title="N的范围判断算法是什么"></a>N的范围判断算法是什么</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>n &lt; <span class="hljs-number">30</span>,指数级别, dfs+剪枝，状态压缩dp<br><span class="hljs-number">2.</span>n &lt; <span class="hljs-number">100</span>=&gt;<span class="hljs-number">0</span>(n)，foyd, dp<br><span class="hljs-number">3.</span>n&lt;<span class="hljs-number">1000</span>=&gt;<span class="hljs-number">0</span>(n2)，<span class="hljs-number">0</span>(n?logn)，dp，二分<br><span class="hljs-number">4.</span>n ≤ <span class="hljs-number">10000</span> =&gt;<span class="hljs-number">0</span>(n* √n)，块状链表<br><span class="hljs-number">5.</span>&lt; <span class="hljs-number">100000</span>=&gt;<span class="hljs-number">0</span>(nlogn)=&gt;各种sort，线段树、树状数组、<span class="hljs-built_in">set</span>/<span class="hljs-built_in">map</span>、heap、dijkstratheap、spfa、求凸包、求半<br>平面交、二分<br><span class="hljs-number">6.</span>n&lt; <span class="hljs-number">1000000</span> =&gt; <span class="hljs-number">0</span>(m),以及常数较小的 <span class="hljs-number">0</span>(nlogn)算法=&gt;hash、双指针扫描、kmp、AC自动机，常数比较小的O(nlogn)的做法:sort、树状数组、heap、dijkstra、spfa<br><span class="hljs-number">7.</span>n &lt; <span class="hljs-number">10000000</span> =&gt;<span class="hljs-number">0</span>(n)，双指针扫描、kmp、AC自动机、线性筛素数<br><span class="hljs-number">8.</span>n ≤ <span class="hljs-number">10</span>° =&gt;O(√π)，判断质数<br><span class="hljs-number">9.</span>n&lt; <span class="hljs-number">1018</span> =&gt;<span class="hljs-number">0</span>(logn)，最大公约数<br></code></pre></td></tr></table></figure>

<h2 id="最基础的部分："><a href="#最基础的部分：" class="headerlink" title="最基础的部分："></a>最基础的部分：</h2><p>顺序，选择，循环，数组，函数，字符串，结构体(类)的语法(必会)，高精度 ，组合数的思想，概率论与期望常见公式，找规律能力，进制转换</p>
<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p>一维前缀和差分与二维前缀和差分(必会，思想很简单)</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>链表，队列，栈(模拟)，优先列队&#x2F;堆，哈希表，单调栈，单调队列，二维单调队列(求解子矩阵最值，尽量会)，并查集，树状数组(解决单点修改，区间求和问题，尽量会，一般考就压轴)，线段树</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>dfs(回溯),bfs(必会，比较简单，解决等权值最小路径问题),二进制枚举(必会，近三年填空题考的多，用二进制位01表示选和不选)</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记忆化搜索(尽可能会，因为基本上所有dp题都可以用记搜)</p>
<p>线性dp(必会，考的非常多与频繁，前几年基本上一场会出现至少二题线性dp，去年没考)</p>
<p>背包问题与背包计数(必会，01，完全，多重，还有个整数划分问题)</p>
<p>区间dp,树形dp,数位dp,状压dp</p>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p>最大公约数，最小公倍数，唯一分解定理(必会)<br>素数，素数筛法 (必会)<br>快速幂，费马小定理求逆元(必会)<br>排列组合，第二类斯特林数(必会)<br>概率论与期望公式(尽量会，去年第一次考，然后每年都会考均值期望)<br>矩阵乘法(尽量会，近几年没考过)<br>数论分块(尽量会，近几年没考过)</p>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>单起点多终点正权最短路(必会，dijikstra)<br>单起点多终点负权最短路(必会，Bellmanford，spfa)<br>多起点多终点最短路(必会，Floy 记住循环kij就好）<br>最小瓶颈路<br>最小生成树<br>最近公共祖光(Ica)尽量会)</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串哈希(必会，尤其是与二分结合的思想以及回文半径回文中心的思想)<br>kmp(必会，会求周期)<br>manacher(求回文串，尽可能会)<br>字典树(尽可能会)</p>
<p>切记：小心变量覆盖的问题</p>
<hr>
<h1 id="C-算法详细内容"><a href="#C-算法详细内容" class="headerlink" title="C++算法详细内容"></a>C++算法详细内容</h1><h2 id="基础数据结构和算法"><a href="#基础数据结构和算法" class="headerlink" title="基础数据结构和算法"></a><strong>基础数据结构和算法</strong></h2><h3 id="1-基础语法与数据类型"><a href="#1-基础语法与数据类型" class="headerlink" title="1. 基础语法与数据类型"></a>1. <strong>基础语法与数据类型</strong></h3><h4 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1.输入输出"></a>1.输入输出</h4><p>cin和cout</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">cin</span> &gt;&gt; a;  <span class="hljs-comment">// 从键盘输入一个整数</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出结果</span><br><br><span class="hljs-type">char</span> ch;<br><span class="hljs-built_in">cin</span> &gt;&gt; ch;  <span class="hljs-comment">// 输入一个字符</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Character: &quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出字符</span><br><br><br><span class="hljs-built_in">string</span> str;<br><span class="hljs-built_in">cin</span> &gt;&gt; str;  <span class="hljs-comment">// 只会读取一个单词，遇到空格会停止</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">string</span> str;<br>getline(<span class="hljs-built_in">cin</span>, str);  <span class="hljs-comment">// 读取一整行，包括空格，用之前确认是否有空字符，用getchar处理</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>



<p>scanf和printf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%f%lf%s%c&quot;</span>, &amp;a, &amp;b, &amp;c, str,ch);<span class="hljs-comment">// Double: %lf， 默认保留6位小数,Char: %c, 回车也是一个字符，用’\n’表示 ,%s读取一个字符串（遇到空格会停止）</span><br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">100000</span>];  <span class="hljs-comment">// 假设最大输入量是100000</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>  <br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);  <span class="hljs-comment">// 读取一个字符串（直到遇到空格）</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你输入的字符串是: %s\n&quot;</span>, str);<br><br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%[^\n]&quot;</span>, str);  <span class="hljs-comment">// 读取一整行，直到换行符,包含空格的字符串</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <span class="hljs-comment">// 读取整数</span><br>    getchar();         <span class="hljs-comment">// 清除输入缓冲区中的换行符,每读取一行就getchar()</span><br>    <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%[^\n]&quot;</span>, str);  <span class="hljs-comment">// 读取一行字符串</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你输入的字符串是: %s\n&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的整数是: %d\n&quot;</span>, a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的浮点数是: %.2f\n&quot;</span>, b);  <span class="hljs-comment">// 控制浮点数输出保留两位小数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的双精度浮点数是: %.3lf\n&quot;</span>, c);  <span class="hljs-comment">// 控制双精度浮点数输出保留三位小数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的字符串是: %s\n&quot;</span>, str);<span class="hljs-comment">//直到&#x27;\0&#x27;才结束也就是可以带空格</span><br><br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]); ++i) &#123;   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>&#125;<br><br><span class="hljs-comment">// 使用 scanf 输入 vector 中的每个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;vec[i]);  <span class="hljs-comment">// 逐个读取元素</span><br>&#125;<br><span class="hljs-comment">// 输出读取到的元素</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Vector elements: &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.size(); ++i) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, vec[i]);  <span class="hljs-comment">// 输出每个元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果带空格,用cin&#x2F;scanf之后不能<strong>盲目用</strong>getchar&#x2F;getline&#x2F;get，如果要用，<strong>就要在cin后吃字符</strong></p>
<p>用getchar&#x2F;getline&#x2F;get之后可以用cin&#x2F;scanf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//getline/getchar/get可以接受空格，读取时遇到换行符结束</span><br><span class="hljs-built_in">string</span> str;<br>getline(<span class="hljs-built_in">cin</span>, str);<br><span class="hljs-built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="hljs-built_in">endl</span>;    <br></code></pre></td></tr></table></figure>

<p>可能输入的场景总结</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*输入多个整数 </span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">5 3 8 1</span><br><span class="hljs-comment">*/</span>      <br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <span class="hljs-comment">// 输入整数的个数</span><br><span class="hljs-type">int</span> arr[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);  <span class="hljs-comment">// 输入每个整数</span><br>&#125;<br><br><br><br><span class="hljs-comment">/*输入一个二维数组（矩阵）</span><br><span class="hljs-comment">1 2 3</span><br><span class="hljs-comment">4 5 6</span><br><span class="hljs-comment">7 8 9</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// 输入行数和列数</span><br><span class="hljs-type">int</span> mat[n][m];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mat[i][j]);  <span class="hljs-comment">// 输入矩阵的每个元素</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输入矩阵元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; matrix[i][j];  <span class="hljs-comment">// 使用 cin 读取每个元素</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出矩阵元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; matrix[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出矩阵的元素</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出完一行后换行</span><br>&#125;<br><br><br><br><span class="hljs-comment">/*输入单行字符串（没有空格）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);  <span class="hljs-comment">// 输入不包含空格的单行字符串</span><br><br><br><span class="hljs-comment">/*入整行字符串（包括空格）</span><br><span class="hljs-comment">Hello world! Welcome to BlueBridge.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">string</span> line;<br><span class="hljs-comment">// 使用 getline 读取一整行输入，包括空格</span><br>getline(<span class="hljs-built_in">cin</span>, line);<br><span class="hljs-comment">// 输出输入的字符串</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><br><br><span class="hljs-comment">/* 输入多行字符串</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">Hello</span><br><span class="hljs-comment">world</span><br><span class="hljs-comment">BlueBridge</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*输入多个空格分隔的字符串，逐个处理</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">apple banana cherry</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;  <span class="hljs-comment">// 读取输入的行数</span><br><span class="hljs-built_in">cin</span>.ignore();  <span class="hljs-comment">// 忽略掉输入行数后的换行符</span><br><span class="hljs-built_in">string</span> line;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    getline(<span class="hljs-built_in">cin</span>, line);  <span class="hljs-comment">// 逐行读取字符串</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出每行</span><br>&#125;<br><br><br><br><span class="hljs-comment">/*输入一个二维字符数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">char</span> mat[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// 输入行数和列数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;mat[i][j]);  <span class="hljs-comment">// 输入字符矩阵的每个字符</span><br>    &#125;<br>&#125;<br><br><br><br><br><br> <span class="hljs-comment">/*输入带有特殊符号的字符串*/</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>getchar();  <span class="hljs-comment">// 清除换行符</span><br>fgets(str, <span class="hljs-keyword">sizeof</span>(str), <span class="hljs-built_in">stdin</span>);  <span class="hljs-comment">// 输入带特殊符号的字符串</span><br><br><br><span class="hljs-comment">/*输入多个有特定关系的数据（如边和节点）</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">1 2</span><br><span class="hljs-comment">2 3</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// 输入节点数和边数</span><br><span class="hljs-type">int</span> edges[m][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;edges[i][<span class="hljs-number">0</span>], &amp;edges[i][<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 输入每条边的两个端点</span><br>&#125;<br><br><br><span class="hljs-comment">/*输入多个日期和时间格式的数据</span><br><span class="hljs-comment">2022-02-18 12:30:00</span><br><span class="hljs-comment">2023-03-19 14:45:00</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">t</span>;</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d-%d %d:%d:%d&quot;</span>, &amp;t.tm_year, &amp;t.tm_mon, &amp;t.tm_mday, &amp;t.tm_hour, &amp;t.tm_min, &amp;t.tm_sec) != EOF) &#123;<br>    t.tm_year -= <span class="hljs-number">1900</span>;  <span class="hljs-comment">// 日期格式调整</span><br>    t.tm_mon -= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 月份从0开始</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, t.tm_year + <span class="hljs-number">1900</span>, t.tm_mon + <span class="hljs-number">1</span>, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec);<br>&#125;<br><br><br><br><br><br></code></pre></td></tr></table></figure>





<h4 id="2-基本数学函数"><a href="#2-基本数学函数" class="headerlink" title="2.基本数学函数"></a>2.<strong>基本数学函数</strong></h4><ul>
<li><strong><code>abs(int x)</code></strong>: 返回整数 <code>x</code> 的绝对值。</li>
<li><strong><code>fabs(double x)</code></strong>: 返回浮点数 <code>x</code> 的绝对值。</li>
<li><strong><code>sqrt(double x)</code></strong>: 返回 <code>x</code> 的平方根。</li>
<li><strong><code>pow(double base, double exp)</code></strong>: 返回 <code>base</code> 的 <code>exp</code> 次方。</li>
<li><strong><code>exp(double x)</code></strong>: 返回 <code>e</code> 的 <code>x</code> 次方。</li>
<li><strong><code>log(double x)</code></strong>: 返回 <code>x</code> 的自然对数。</li>
<li><strong><code>log10(double x)</code></strong>: 返回 <code>x</code> 的以 10 为底的对数。</li>
<li><strong><code>ceil(double x)</code></strong>: 返回大于或等于 <code>x</code> 的最小整数。</li>
<li><strong><code>floor(double x)</code></strong>: 返回小于或等于 <code>x</code> 的最大整数。</li>
<li><strong><code>round(double x)</code></strong>: 返回最接近 <code>x</code> 的整数。</li>
</ul>
<p><strong>三角函数</strong></p>
<ul>
<li><strong><code>sin(double x)</code></strong>: 返回 <code>x</code> 的正弦值。</li>
<li><strong><code>cos(double x)</code></strong>: 返回 <code>x</code> 的余弦值。</li>
<li><strong><code>tan(double x)</code></strong>: 返回 <code>x</code> 的正切值。</li>
<li><strong><code>asin(double x)</code></strong>: 返回 <code>x</code> 的反正弦值。</li>
<li><strong><code>acos(double x)</code></strong>: 返回 <code>x</code> 的反余弦值。</li>
<li><strong><code>atan(double x)</code></strong>: 返回 <code>x</code> 的反正切值。</li>
<li><strong><code>atan2(double y, double x)</code></strong>: 计算 <code>y/x</code> 的反正切值，考虑象限。</li>
</ul>
<p><strong>常数</strong></p>
<ul>
<li><strong><code>M_PI</code></strong>: <code>π</code> 的值。</li>
<li><strong><code>M_E</code></strong>: <code>e</code> 的值。</li>
</ul>
<p><strong>其他函数</strong></p>
<ul>
<li><strong><code>modf(double x, double\* intpart)</code></strong>: 拆分 <code>x</code> 为整数部分和小数部分。</li>
<li><strong><code>fmod(double x, double y)</code></strong>: 返回 <code>x</code> 除 <code>y</code> 的余数。</li>
<li><strong><code>hypot(double x, double y)</code></strong>: 返回 <code>sqrt(x^2 + y^2)</code>。</li>
</ul>
<p><strong>随机数</strong></p>
<ul>
<li><strong><code>rand()</code></strong>: 返回一个随机整数。</li>
<li><strong><code>srand(unsigned int seed)</code></strong>: 设置随机数种子。</li>
</ul>
<p><strong>特殊值判断</strong></p>
<ul>
<li><code>isnan(double x)</code>: 判断 <code>x</code> 是否为 NaN。</li>
<li><strong><code>isfinite(double x)</code></strong>: 判断 <code>x</code> 是否为有限值。</li>
<li><strong><code>isinf(double x)</code></strong>: 判断 <code>x</code> 是否为无穷大。</li>
</ul>
<hr>
<h3 id="2-字符"><a href="#2-字符" class="headerlink" title="2.字符"></a>2.字符</h3><p>C++ 中，每个常用字符对应一个整数值，通常称为 ASCII 值。可以通过字符与对应的整数值相互转化。</p>
<ul>
<li><h4 id="字符与-ASCII-码："><a href="#字符与-ASCII-码：" class="headerlink" title="字符与 ASCII 码："></a><strong>字符与 ASCII 码：</strong></h4><ul>
<li>‘A’ - ‘Z’ 对应的 ASCII 值是 65 ~ 90</li>
<li>‘a’ - ‘z’ 对应的 ASCII 值是 97 ~ 122</li>
<li>‘0’ - ‘9’ 对应的 ASCII 值是 48 ~ 57</li>
</ul>
</li>
<li><p><strong>字符可以参与运算：</strong></p>
<ul>
<li>运算时，字符会被当做整数处理，使用其对应的 ASCII 值。</li>
</ul>
</li>
</ul>
<p>字符串在 C++ 中本质上是一个字符数组，数组的末尾有一个特殊的结束符 <code>&#39;\0&#39;</code>。所以输出字符串就直接输出arr这个就行 char arr[]&#x3D;”hello world”;</p>
<h4 id="字符数组的常用操作"><a href="#字符数组的常用操作" class="headerlink" title="字符数组的常用操作"></a><strong>字符数组的常用操作</strong></h4><ol>
<li><code>strlen(str)</code>：计算字符串长度。</li>
<li><code>strcmp(a, b)</code>：比较两个字符串，按字典序比较。</li>
<li><code>strcpy(a, b)</code>：将字符串 <code>b</code> 复制到 <code>a</code>。</li>
</ol>
<hr>
<h4 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 <code>string</code></h4><p><code>string</code> 是一个动态的字符序列 等同于char arr[]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">string</span> <span class="hljs-title function_">s2</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span>;  <span class="hljs-comment">// 初始化为 &quot;ccccc&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong><code>string</code> 上的常见操作</strong></p>
<p>读取单个单词</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str;<br><span class="hljs-built_in">cin</span> &gt;&gt; str;<br></code></pre></td></tr></table></figure>

<p><strong><code>getline</code> 读取一整行</strong>:使用时记得检查之前的scanf如果有就getchar();清除一下缓存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">getline(<span class="hljs-built_in">cin</span>, str);  <span class="hljs-comment">// 读取一整行输入</span><br></code></pre></td></tr></table></figure>

<p><strong><code>empty</code> 和 <code>size</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;字符串是否为空: &quot;</span> &lt;&lt; str.empty() <br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;字符串的长度: &quot;</span> &lt;&lt; str.size() <br></code></pre></td></tr></table></figure>

<p><strong><code>string</code> 的比较：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> (s1 &lt; s2) &#123;<br>     <span class="hljs-built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot; 小于 &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>string</code> 赋值与拼接</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> s3 = s1 + <span class="hljs-string">&quot;, &quot;</span> + s2;<br></code></pre></td></tr></table></figure>

<p><strong>find查询子串</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (pos != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) &#123;       <span class="hljs-comment">//如果没找到，返回std::string::npos</span><br>    :<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Found at position &quot;</span> &lt;&lt; pos &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>substr()</code></strong></p>
<p>从字符串中提取子串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-built_in">string</span> sub = str.substr(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 从索引 7 开始，提取 5 个字符</span><br><span class="hljs-built_in">cout</span> &lt;&lt; sub;  <span class="hljs-comment">// 输出 &quot;world&quot;</span><br></code></pre></td></tr></table></figure>

<p> <strong><code>c_str()</code></strong></p>
<p>将 <code>std::string</code> 转换为 C 风格字符串（即以 <code>&#39;\0&#39;</code> 结尾的字符数组）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = str.c_str();<br><span class="hljs-built_in">cout</span> &lt;&lt; cstr;  <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>c_str()</code> 返回一个指向字符串的常量指针（<code>const char*</code>）。</li>
</ul>
<p><strong><code>append()</code></strong></p>
<p>将另一个字符串或字符附加到当前字符串的末尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>str.append(<span class="hljs-string">&quot;, world!&quot;</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>push_back()</code></strong></p>
<p>向字符串末尾添加一个字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>str.push_back(<span class="hljs-string">&#x27;!&#x27;</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>insert()</code></strong></p>
<p>在指定位置插入字符或子字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>str.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;, beautiful&quot;</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;Hello, beautiful world!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>insert(pos, str)</code>：在位置 <code>pos</code> 插入字符串 <code>str</code>。</li>
<li><code>insert(pos, n, c)</code>：在位置 <code>pos</code> 插入 <code>n</code> 个字符 <code>c</code>。</li>
</ul>
<p> <strong><code>erase()</code></strong></p>
<p>删除指定位置的字符或子字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>str.erase(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>);  <span class="hljs-comment">// 从索引 5 开始，删除 7 个字符</span><br><span class="hljs-built_in">cout</span> &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>erase(pos, len)</code>：删除从 <code>pos</code> 开始，长度为 <code>len</code> 的子串。</li>
</ul>
<p><strong><code>replace()</code></strong></p>
<p>替换指定位置的字符或子字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>str.replace(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;C++&quot;</span>);<br>:<span class="hljs-built_in">cout</span> &lt;&lt; str;  <span class="hljs-comment">// 输出 &quot;Hello, C++!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>replace(pos, len, str)</code>：从 <code>pos</code> 开始，删除 <code>len</code> 个字符并用 <code>str</code> 替换它们。</li>
</ul>
<p><strong><code>compare()</code></strong></p>
<p>比较两个字符串的大小（按字典序比较）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;apple&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;banana&quot;</span>;<br><span class="hljs-type">int</span> result = str1.compare(str2);  <span class="hljs-comment">// 返回负值，因为 &quot;apple&quot; 小于 &quot;banana&quot;</span><br><span class="hljs-built_in">cout</span> &lt;&lt; result;  <span class="hljs-comment">// 输出负数</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>compare()</code>：返回值是 <code>0</code> 表示两个字符串相等，负值表示当前字符串小于比较字符串，正值表示当前字符串大于比较字符串。</li>
</ul>
<p><strong><code>find_first_of()</code></strong></p>
<p>查找字符串中第一个包含指定字符或字符集的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">size_t</span> pos = str.find_first_of(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找第一个元音字母的位置</span><br><span class="hljs-built_in">cout</span> &lt;&lt; pos;  <span class="hljs-comment">// 输出 1，表示 &#x27;e&#x27; 是第一个元音</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>find_first_of(str)</code>：返回第一次出现字符集中任意字符的索引位置。</li>
</ul>
<p> <strong><code>find_last_of()</code></strong></p>
<p>查找字符串中最后一个包含指定字符或字符集的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">size_t</span> pos = str.find_last_of(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找最后一个元音字母的位置</span><br><span class="hljs-built_in">cout</span> &lt;&lt; pos;  <span class="hljs-comment">// 输出 8，表示 &#x27;o&#x27; 是最后一个元音</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>find_last_of(str)</code>：返回最后一次出现字符集中的任意字符的位置。</li>
</ul>
<p><strong><code>rfind()</code></strong></p>
<p>从字符串的尾部开始查找指定子串的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, world! world!&quot;</span>;<br><span class="hljs-type">size_t</span> pos = str.rfind(<span class="hljs-string">&quot;world&quot;</span>);  <span class="hljs-comment">// 查找最后一次出现 &quot;world&quot; 的位置</span><br><span class="hljs-built_in">cout</span> &lt;&lt; pos;  <span class="hljs-comment">// 输出 13</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>rfind(str)</code>：返回从尾部开始查找子串的位置。</li>
</ul>
<p> <strong><code>to_string()</code></strong></p>
<p>将数字类型转换为字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str = <span class="hljs-built_in">std</span>::to_string(num);  <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-built_in">cout</span> &lt;&lt; str;<br></code></pre></td></tr></table></figure>

<p><strong><code>stoi()</code>, <code>stol()</code>, <code>stof()</code>, <code>stod()</code> 等</strong></p>
<p>将字符串转换为整数、长整型、浮点数等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">std</span>::stoi(str);  <span class="hljs-comment">// 将字符串转换为整数</span><br><span class="hljs-built_in">cout</span> &lt;&lt; num;  <span class="hljs-comment">// 输出 12345</span><br></code></pre></td></tr></table></figure>

<p> <strong><code>trim()</code> (自定义实现)</strong></p>
<p>C++ 标准库并没有直接提供 <code>trim</code> 函数来去除字符串两端的空白字符，但你可以通过自定义函数来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">:<span class="hljs-built_in">string</span> <span class="hljs-title function_">trim</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; str)</span> &#123;<br>    <span class="hljs-keyword">auto</span> start = str.find_first_not_of(<span class="hljs-string">&quot; \t\n\r&quot;</span>);<br>    <span class="hljs-keyword">auto</span> end = str.find_last_not_of(<span class="hljs-string">&quot; \t\n\r&quot;</span>);<br>    <span class="hljs-keyword">return</span> (start == <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos || end == <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) ? <span class="hljs-string">&quot;&quot;</span> : str.substr(start, end - start + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;   Hello, world!   &quot;</span>;<br>   <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; trim(str) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出 &quot;|Hello, world!|&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>++++</p>
<h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。当函数的形参为引用类型时，对形参的修改会影响实参的值。使用引用的作用：避免拷贝、让函数返回额外信息。</p>
<p>++++</p>
<h3 id="4-STL"><a href="#4-STL" class="headerlink" title="4.STL"></a>4.STL</h3><h4 id="一-STL-的主要组成部分"><a href="#一-STL-的主要组成部分" class="headerlink" title="一.STL 的主要组成部分"></a>一.STL 的主要组成部分</h4><ol>
<li>容器 ：用来存储和管理数据的集合。</li>
<li>算法 ：用于对数据进行操作，如排序、查找、修改等。</li>
<li>迭代器：用于遍历容器中的元素，提供统一的访问接口。</li>
</ol>
<h4 id="二、容器-Containers"><a href="#二、容器-Containers" class="headerlink" title="二、容器 (Containers)"></a>二、容器 (Containers)</h4><p>STL 容器分为三类：<strong>顺序容器</strong>、<strong>关联容器</strong>和<strong>无序关联容器</strong>。</p>
<h5 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1.顺序容器"></a>1.顺序容器</h5><p>顺序容器存储数据时，元素按插入顺序排列，常见的顺序容器有：</p>
<ul>
<li><code>vector</code>：动态数组，支持快速随机访问。</li>
<li><code>deque</code>：双端队列，支持两端快速插入和删除。</li>
<li><code>list</code>：双向链表，支持双向遍历，插入和删除操作效率较高。</li>
<li><code>array</code>：定长数组（C++11 引入），存储固定大小的数据。</li>
<li><code>forward_list</code>：单向链表（C++11 引入），支持单向遍历。</li>
</ul>
<p><strong><code>vector</code></strong> 动态数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 创建一个大小为 5，值为 0 的 vector</span><br><br><br><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 尾部添加元素</span><br><span class="hljs-type">bool</span> isEmpty = vec.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 返回 true 如果 vector 为空</span><br><span class="hljs-type">int</span> n = vec.<span class="hljs-built_in">size</span>();<br>vec.<span class="hljs-built_in">pop_back</span>();<br>vec.<span class="hljs-built_in">clear</span>();<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<br>matrix.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;);  <span class="hljs-comment">// 添加新的一行</span><br><br>vec.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 改变 `vec` 的大小为 10，新增的元素初始化为 0</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 在第三个位置插入 3，变为 &#123;1, 2, 3, 4, 5&#125;</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>vec.<span class="hljs-built_in">erase</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>);  <span class="hljs-comment">// 删除第三个元素，变为 &#123;1, 2, 4, 5&#125;</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found 3 at index: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(vec.<span class="hljs-built_in">begin</span>(), it) &lt;&lt; std::endl;<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 升序排序</span><br><span class="hljs-built_in">reverse</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 变为 &#123;5, 4, 3, 2, 1&#125;</span><br><span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 计算和，结果是 15</span><br><br>vec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 预分配空间，避免扩容</span><br></code></pre></td></tr></table></figure>

<p><strong><code>deque</code></strong> 双端队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-type">int</span>&gt; dq = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>dq.push_front(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入元素</span><br>dq.push_back(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入元素</span><br>dq.pop_front();    <span class="hljs-comment">// 移除头部元素</span><br>dq.pop_back();     <span class="hljs-comment">// 移除尾部元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : dq) &#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：2 3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>list</code></strong> 双向链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">list</span>&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>lst.push_front(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入</span><br>lst.push_back(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入</span><br>lst.remove(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 移除值为2的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : lst) &#123;<br>	<span class="hljs-built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：0 1 3 4</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2. 关联容器"></a>2. <strong>关联容器</strong></h5><p>关联容器基于平衡二叉树（通常是红黑树）实现，元素按键值排序，支持快速查找、插入和删除操作。常见的关联容器有：</p>
<ul>
<li><code>set</code>：存储唯一的元素，自动按元素的键值排序。</li>
<li><code>map</code>：键值对（key-value）形式存储元素，按键排序。</li>
<li><code>multiset</code>：存储允许重复的元素，按键排序。</li>
<li><code>multimap</code>：存储允许重复的键值对，按键排序。</li>
</ul>
<p><strong><code>set</code></strong> 存储唯一元素，自动排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动排序，重复元素被忽略</span><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><br><span class="hljs-comment">// 输出 set 中的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp; x : s) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x);<br>&#125;<br><span class="hljs-comment">//迭代器写法</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(); it != s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *it);<br>&#125;<br><br><span class="hljs-comment">//查找元素</span><br><span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 查找元素 3</span><br><span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Found: %d\n&quot;</span>, *it);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not found\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//检查元素是否存在，count 要么返回 0（不存在），要么返回 1（存在）。</span><br>std::set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3 is in the set\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3 is not in the set\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//获取 set 的大小</span><br>set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size: %zu\n&quot;</span>, s.<span class="hljs-built_in">size</span>());<br><br><br></code></pre></td></tr></table></figure>

<p><strong><code>map</code></strong> 键值对形式存储，按键排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m = &#123;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;&#125;; <span class="hljs-comment">// 自动排序，重复键的值会被覆盖</span><br>map&lt;string, <span class="hljs-type">int</span>&gt; m;<br>m.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">10</span>&#125;);<br><span class="hljs-comment">// 插入一个重复的键，不会成功</span><br>m.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-number">40</span>&#125;);  <span class="hljs-comment">// 键 3 已存在，不会插入</span><br><br><span class="hljs-comment">//查找元素</span><br><span class="hljs-keyword">auto</span> it = m.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 查找键为 2 的元素</span><br><span class="hljs-keyword">if</span> (it != m.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Found: %d -&gt; %d\n&quot;</span>, it-&gt;first, it-&gt;second);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not found\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//删除元素</span><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 删除键为 2 的元素</span><br><br><span class="hljs-comment">//获取 map 的大小</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size: %zu\n&quot;</span>, m.<span class="hljs-built_in">size</span>());<span class="hljs-comment">//Size: 3</span><br><br><br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>m[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>m[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : m) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>, pair.first.<span class="hljs-built_in">c_str</span>(), pair.second);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-无序关联容器"><a href="#3-无序关联容器" class="headerlink" title="3. 无序关联容器"></a>3. <strong>无序关联容器</strong></h5><p>无序关联容器是基于哈希表实现的容器，元素无序排列，但支持常数时间复杂度的查找、插入和删除操作。常见的无序关联容器有：</p>
<ul>
<li><code>unordered_set</code>：无序集合，元素唯一。</li>
<li><code>unordered_map</code>：无序键值对，基于哈希表存储。</li>
</ul>
<p><strong><code>unordered_set</code></strong> 无序集合，元素唯一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt; uset = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">// 重复的1被忽略</span><br>uset.insert(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : uset) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出顺序不固定，例如：3 1 2 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>unordered_map</code></strong> 无序键值对，基于哈希表存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map&lt;string, <span class="hljs-type">int</span>&gt; umap;<br>umap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>umap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>umap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : umap) &#123;<br>    cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">// 输出顺序不固定，例如：</span><br>banana: <span class="hljs-number">2</span> apple: <span class="hljs-number">3</span> orange: <span class="hljs-number">4</span><br> &#125;<br><br></code></pre></td></tr></table></figure>





<h4 id="三、算法-Algorithms"><a href="#三、算法-Algorithms" class="headerlink" title="三、算法 (Algorithms)"></a>三、算法 (Algorithms)</h4><p>STL 提供了一系列的算法来操作容器，如排序、查找、修改等。这些算法定义在头文件 <code>&lt;algorithm&gt;</code> 中，并且可以通过迭代器访问容器的元素。</p>
<h5 id="1-常用算法"><a href="#1-常用算法" class="headerlink" title="1. 常用算法"></a>1. <strong>常用算法</strong></h5><ul>
<li><code>sort</code>：对容器进行排序。</li>
<li><code>find</code>：查找某个元素。</li>
<li><code>binary_search</code>：二分查找，要求容器是有序的。</li>
<li><code>reverse</code>：将容器中的元素反转。</li>
<li><code>accumulate</code>：计算容器中元素的累加和。</li>
<li><code>count</code>：统计容器中某个元素的出现次数。</li>
</ul>
<p><strong><code>sort</code></strong> 对容器进行排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 升序排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>    cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>find</code></strong> 查找某个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found: 3</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>binary_search</code></strong> 二分查找（要求容器是有序的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">bool</span> found = <span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (found) &#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>reverse</code></strong> 将容器中的元素反转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">reverse</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>   cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>accumulate</code></strong> 计算容器中元素的累加和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 初始值为0</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：Sum: 15</span><br></code></pre></td></tr></table></figure>

<p><strong><code>count</code></strong> 统计容器中某个元素的出现次数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> cnt = <span class="hljs-built_in">count</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;Count of 2: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：Count of 2: 3</span><br></code></pre></td></tr></table></figure>



<h5 id="2-自定义比较函数"><a href="#2-自定义比较函数" class="headerlink" title="2. 自定义比较函数"></a>2. <strong>自定义比较函数</strong></h5><p><strong><code>sort</code></strong> 使用自定义比较函数</p>
<p>默认情况下，<code>sort</code> 会进行升序排序。我们可以通过传递一个自定义比较函数来控制排序方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义比较函数，实现降序排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), descending);  <span class="hljs-comment">// 使用自定义比较函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>      cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-comment">// 使用 Lambda 表达式作为自定义比较函数，按降序排序</span><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;);<br>    <span class="hljs-comment">// 输出排序后的结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : v) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//对结构体数组排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-comment">// 自定义比较函数，按年龄升序排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareByAge</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; a, <span class="hljs-type">const</span> Person&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;Person&gt; people = &#123;&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>&#125;, &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>&#125;, &#123;<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span>&#125;&#125;;<br>    <span class="hljs-comment">// 使用自定义比较函数按年龄升序排序</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), compareByAge);<br>    <span class="hljs-comment">// 使用 Lambda 表达式按年龄升序排序</span><br>    std::<span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Person&amp; a, <span class="hljs-type">const</span> Person&amp; b) &#123;<span class="hljs-keyword">return</span> a.age &lt; b.age;&#125;);<br>    <span class="hljs-comment">// 输出排序后的结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Person&amp; p : people) &#123;<br>        cout &lt;&lt; p.name &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>find_if</code></strong> 使用自定义条件</p>
<p><code>find_if</code> 可根据自定义的 <strong>谓词函数</strong> 查找符合条件的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>&#125;;<br><span class="hljs-comment">// 使用 lambda 表达式查找第一个大于 10 且是偶数的元素</span><br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">10</span> &amp;&amp; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><br>map&lt;string, <span class="hljs-type">int</span>&gt; m = &#123;&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-comment">// 查找第一个键大于 &quot;banana&quot; 的元素</span><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(m.<span class="hljs-built_in">begin</span>(), m.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> pair&lt;string, <span class="hljs-type">int</span>&gt;&amp; p) &#123;<span class="hljs-keyword">return</span> p.first &gt; <span class="hljs-string">&quot;banana&quot;</span>;  <span class="hljs-comment">// 按照键的字典顺序&#125;);</span><br><span class="hljs-keyword">if</span> (it != m.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>binary_search</code></strong> 自定义比较函数</p>
<p><code>binary_search</code> 也可以接受自定义的比较函数，但要求容器中的元素按该规则预先排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义比较函数，进行降序比较</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), descending);  <span class="hljs-comment">// 降序排序</span><br><span class="hljs-type">bool</span> found = <span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, descending);<br>  <span class="hljs-type">bool</span> found = std::<span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &lt; <span class="hljs-built_in">abs</span>(b); &#125;);<br><span class="hljs-keyword">if</span> (found) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>set</code></strong> 自定义比较函数（按降序存储）</p>
<p>C++ 中的 <strong><code>set</code></strong> 默认是升序排序。我们可以自定义一个比较函数来改变排序顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义比较函数，按降序排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Descending</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br>set&lt;<span class="hljs-type">int</span>, Descending&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>set&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>([](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;)&gt; <span class="hljs-built_in">s</span>([](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : s) &#123;<br>     cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>priority_queue</code></strong> 自定义比较函数（实现小顶堆）</p>
<p><code>priority_queue</code> 默认是大顶堆，我们可以通过自定义比较函数创建小顶堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义比较函数，实现小顶堆</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 使较小的元素拥有更高优先级</span><br>    &#125;<br>&#125;;<br><br>priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, Compare&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 3 5</span><br>    pq.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="四、迭代器-Iterators"><a href="#四、迭代器-Iterators" class="headerlink" title="四、迭代器 (Iterators)"></a>四、迭代器 (Iterators)</h4><p>迭代器提供了一种统一的方式来遍历 STL 容器。常见的迭代器类型有：</p>
<ul>
<li><code>begin()</code> 和 <code>end()</code>：返回指向容器第一个元素和尾后元素的迭代器。</li>
<li><code>rbegin()</code> 和 <code>rend()</code>：返回逆序迭代器，分别指向最后一个元素和第一个元素之前的位置。</li>
<li><code>cbegin()</code> 和 <code>cend()</code>：返回常量迭代器，不能用于修改元素。</li>
</ul>
<p>迭代器可以通过 <code>*it</code> 解引用访问元素，通过 <code>++it</code> 或 <code>--it</code> 移动到下一个或上一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">int</span> age;<br>    string name;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, string name) : <span class="hljs-built_in">age</span>(age), <span class="hljs-built_in">name</span>(name) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareAge</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p1, <span class="hljs-type">const</span> Person&amp; p2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> p<span class="hljs-number">1.</span>age &gt; p<span class="hljs-number">2.</span>age;  <span class="hljs-comment">// 按照年龄升序排列（最小堆）</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义比较函数 CompareAge（最小堆）</span><br>    priority_queue&lt;Person, vector&lt;Person&gt;, CompareAge&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;Alice&quot;</span>));<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-number">30</span>, <span class="hljs-string">&quot;Bob&quot;</span>));<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-number">20</span>, <span class="hljs-string">&quot;Charlie&quot;</span>));<br>    <span class="hljs-comment">// 输出堆顶元素（最小年龄）</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Top person: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().age &lt;&lt; endl;  <span class="hljs-comment">// 输出 Charlie, 20</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="五-辅助工具类（Utility-Components）"><a href="#五-辅助工具类（Utility-Components）" class="headerlink" title="五.辅助工具类（Utility Components）"></a>五.辅助工具类（Utility Components）</h4><ul>
<li><strong>数据结构</strong>：<code>pair</code>、<code>tuple</code>、<code>make_pair</code>、<code>make_tuple</code></li>
<li><strong>交换和引用</strong>：<code>swap</code></li>
</ul>
<p><strong><code>pair</code> 的基本使用</strong></p>
<p><code>pair</code> 的定义在 <code>&lt;utility&gt;</code> 头文件中，通常用 <code>std::make_pair</code> 函数来创建一个 <code>pair</code>，也可以直接使用构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用 make_pair 函数创建一个 pair</span><br>pair&lt;std::string, <span class="hljs-type">int</span>&gt; student = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-comment">// 访问 pair 中的元素</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; student.first &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; student.second &lt;&lt; endl;<br><span class="hljs-comment">// 也可以直接使用构造函数初始化 pair</span><br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">score</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">98.5</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Rank: &quot;</span> &lt;&lt; score.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; score.second &lt;&lt;endl;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>pair</code> 的成员</strong></p>
<ul>
<li><code>first</code>: 表示 <code>pair</code> 中的第一个元素。</li>
<li><code>second</code>: 表示 <code>pair</code> 中的第二个元素。</li>
</ul>
<p>可以通过 <code>pair.first</code> 和 <code>pair.second</code> 分别访问两个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>)</span></span>;  <span class="hljs-comment">// 初始化pair，第一个元素是int，第二个是char</span><br>cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p.first &lt;&lt; endl;  <span class="hljs-comment">// 输出10</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Second: &quot;</span> &lt;&lt; p.second &lt;&lt; endl;  <span class="hljs-comment">// 输出&#x27;A&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>与容器结合使用</strong></p>
<p><code>pair</code> 在 STL 容器中非常常用，特别是在关联容器（如 <code>map</code> 和 <code>set</code>）中，<code>pair</code> 用于表示键值对。在 <code>map</code> 中，键值对的每个元素实际上是一个 <code>pair</code>，其中 <code>first</code> 是键，<code>second</code> 是值。</p>
<p>在 <code>map</code> 中使用 <code>pair</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建一个 map 来存储学生姓名和分数</span><br>map&lt;string, <span class="hljs-type">int</span>&gt; studentScores;<br><span class="hljs-comment">// 插入键值对，使用 make_pair 函数</span><br>studentScores.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90</span>));<br>studentScores.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">85</span>));<br><span class="hljs-comment">// 访问 map 中的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : studentScores) &#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; entry.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; entry.second &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 也可以通过 [] 操作符直接访问键值对</span><br>studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] = <span class="hljs-number">88</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Charlie&#x27;s Score: &quot;</span> &lt;&lt; studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p><strong>比较 <code>pair</code></strong></p>
<p><code>pair</code> 支持比较操作（如 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等）。比较规则是先比较 <code>first</code> 元素，如果 <code>first</code> 相等，则比较 <code>second</code> 元素。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1 is less than p2&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">// 比较的是 first，若相等，则比较 second</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>p1</code> 和 <code>p2</code> 的 <code>first</code> 部分相同，比较结果取决于 <code>second</code> 部分。</p>
<p><strong><code>pair</code> 的常见用法</strong></p>
<p><strong>作为函数的返回值</strong>：当你需要从函数中返回多个值时，<code>pair</code> 可以作为方便的结构体来返回两个值，而不需要创建专门的结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">getMinMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(a, b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(b, a);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getMinMax</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;Min: &quot;</span> &lt;&lt; result.first &lt;&lt; <span class="hljs-string">&quot;, Max: &quot;</span> &lt;&lt; result.second &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p><strong><code>tuple</code> 作为扩展</strong></p>
<p><code>pair</code> 只能存储两个相关联的值。如果你需要存储更多的值，可以使用 C++11 引入的 <code>tuple</code>，它是 <code>pair</code> 的扩展版，可以存储任意多个元素。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title function_">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90.5</span>)</span>;<br><span class="hljs-comment">// 访问 tuple 中的元素</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ID: &quot;</span> &lt;&lt; get&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; get&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Score: &quot;</span> &lt;&lt;get&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; <span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>

<p><code>tuple</code> 可以通过 <code>get&lt;index&gt;</code> 来访问每个元素，并且可以存储任意数量和类型的元素。</p>
<p><strong><code>pair</code>：一对数据存储</strong></p>
<p><strong>功能：</strong> 存储两个不同类型的数据对，常用于 <strong><code>map</code></strong> 中的键值对存储。</p>
<p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">string</span>&gt; p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：1, apple</span><br></code></pre></td></tr></table></figure>

<p><code>tuple</code>：多数据存储</p>
<p><strong>功能：</strong> 可存储任意数量、任意类型的元素，比 <code>pair</code> 更灵活。</p>
<p><strong>头文件：</strong> <code>&lt;tuple&gt;</code></p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> t = make_tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; get&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; get&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-comment">// 输出：1, apple, 3.14</span><br></code></pre></td></tr></table></figure>

<p><strong><code>make_pair</code> 和 <code>make_tuple</code>：简化对象创建</strong></p>
<p><strong>功能：</strong> 分别用于创建 <code>pair</code> 和 <code>tuple</code>，自动推导类型，简化代码。</p>
<p><strong>头文件：</strong> <code>&lt;utility&gt;</code>, <code>&lt;tuple&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br><span class="hljs-keyword">auto</span> t = make_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><code>swap</code>：交换两个对象的值</p>
<p><strong>功能：</strong> 用于交换两个对象的内容。</p>
<p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>swap(a, b);  <span class="hljs-comment">// a 变为 20，b 变为 10</span><br></code></pre></td></tr></table></figure>









<hr>
<h3 id="5-优化技巧"><a href="#5-优化技巧" class="headerlink" title="5.优化技巧"></a>5.优化技巧</h3><p>在算法竞赛中，为了编写简洁高效的代码，争取时间并减少输入输出的繁琐步骤，常见的简便操作可以帮助你在紧张的比赛环境中提高编写和执行代码的效率。以下是一些常见的简便操作和优化技巧：</p>
<h4 id="1-快速输入输出"><a href="#1-快速输入输出" class="headerlink" title="1. 快速输入输出"></a>1. <strong>快速输入输出</strong></h4><p>最好每个都写上</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br><span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">cout</span>.tie(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>



<h4 id="2-使用宏定义减少代码量"><a href="#2-使用宏定义减少代码量" class="headerlink" title="2.使用宏定义减少代码量"></a>2.<strong>使用宏定义减少代码量</strong></h4><p>宏可以用于减少输入输出、常用算法或者常用数据结构的代码量。虽然宏定义过多可能影响代码的可读性，但在竞赛中可以帮助你快速编写代码。</p>
<h4 id="3-使用-STL-简化操作"><a href="#3-使用-STL-简化操作" class="headerlink" title="3. 使用 STL 简化操作"></a>3. <strong>使用 STL 简化操作</strong></h4><p>C++ 标准模板库（STL）提供了丰富的容器和算法，可以大幅减少代码量和开发时间。在竞赛中常用的有：</p>
<p><strong><code>std::vector</code> 和 <code>std::pair</code></strong></p>
<ul>
<li><code>vector</code> 是动态数组，非常适合存储大规模数据。</li>
<li><code>pair</code> 用于存储两个相关联的值，常用于排序和存储坐标、键值对等。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;&#125;;<br>    <br>    <span class="hljs-comment">// 使用sort对pair进行排序，按照first排序</span><br>    sort(vp.begin(), vp.end());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : vp) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>常用 STL 函数：<code>sort</code>、<code>max_element</code>、<code>min_element</code></strong></p>
<p>使用 STL 提供的算法库，如 <code>sort</code>、<code>max_element</code> 等，可以快速实现排序和最大最小值的查找，避免手动实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;vector&gt;</span><br><span class="hljs-meta">#include &lt;algorithm&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; v = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 快速排序</span><br>    sort(v.begin(), v.end());<br><br>    <span class="hljs-comment">// 查找最大值和最小值</span><br>    <span class="hljs-built_in">int</span> maxVal = *max_element(v.begin(), v.end());<br>    <span class="hljs-built_in">int</span> minVal = *min_element(v.begin(), v.end());<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Max: &quot;</span> &lt;&lt; maxVal &lt;&lt; <span class="hljs-string">&quot;, Min: &quot;</span> &lt;&lt; minVal &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-使用-auto-减少冗长的类型声明"><a href="#4-使用-auto-减少冗长的类型声明" class="headerlink" title="4. 使用 auto 减少冗长的类型声明"></a>4. <strong>使用 <code>auto</code> 减少冗长的类型声明</strong></h4><p><code>auto</code> 关键字允许编译器自动推导变量类型，特别是在使用复杂的 STL 容器时，它可以显著减少代码的长度和复杂性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vec = vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动推导类型</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : vec) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出 1 2 3</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-位操作优化"><a href="#5-位操作优化" class="headerlink" title="5. 位操作优化"></a>5. <strong>位操作优化</strong></h4><p>位操作是非常高效的操作，它能让很多算法在常数时间内完成操作。常见的应用包括判断奇偶性、交换数值、位掩码操作等。</p>
<p><strong>常见的位操作技巧</strong>：</p>
<ul>
<li><p><strong>判断奇偶</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &amp; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果 n 的最低位是 1 则为奇数，否则为偶数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>交换两个数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<br>    a = a ^ b;<br>    b = a ^ b;<br>    a = a ^ b;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>快速计算 2 的幂</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;  <span class="hljs-comment">// n 是 2 的幂时，其二进制中只有一个 1</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="一-二分"><a href="#一-二分" class="headerlink" title="一.二分"></a>一.二分</h2><h3 id="二分查找的基本实现："><a href="#二分查找的基本实现：" class="headerlink" title="二分查找的基本实现："></a><strong>二分查找的基本实现</strong>：</h3><p>二分查找用于在有序数组中查找目标值 <code>target</code>，其时间复杂度为 O(log n)。</p>
<p>要求需要有序的数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] == target)<br>        <span class="hljs-keyword">return</span> mid;  <span class="hljs-comment">// 找到目标，返回索引</span><br>    <span class="hljs-keyword">if</span> (array[mid] &lt; target)<br>        left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 目标在右边</span><br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 目标在左边</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 没有找到目标，返回 -1</span><br></code></pre></td></tr></table></figure>

<p>适用更广的前驱型——找最后一个 &lt;&#x3D; <code>target</code> 的元素的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>, right = n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//向上取整</span><br>    <span class="hljs-keyword">if</span> (array[mid] &lt;= target)  <span class="hljs-comment">// array[mid] &gt; target此外也可以写别的条件也就是我们要的答案的基本性质</span><br>        left = mid;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 不安全返回n</span><br></code></pre></td></tr></table></figure>

<p>适用更广的后继型———找第一个 &gt;&#x3D; target 的数不存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (array[mid] &gt;= target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 如果大于等于目标值，返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search_upper_bound</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n;  <br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))  <br>            right = mid;  <br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> left;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>二分查找的“三步走”</strong>：</p>
<ul>
<li><strong>步骤 1</strong>：写出二分的条件，通常是一个“不等式”条件。例如，对于 <code>upper_bound</code> 查找，可以用“<code>val</code> 的数中最小的”这种不等式条件。</li>
<li><strong>步骤 2</strong>：将条件放到 <code>if</code> 中，并确定满足条件时需要缩小哪一半（<code>right = mid</code> 还是 <code>left = mid</code>）。</li>
<li><strong>步骤 3</strong>：另一半条件放在 <code>else</code> 中。通常可以是 <code>left = mid + 1</code> 或 <code>right = mid - 1</code>。对于向上取整或其他情况可以调整 <code>mid</code> 计算方式。</li>
</ul>
<p><strong>边界处理</strong>：</p>
<ul>
<li>如果题目存在无解情况，可以在返回值上调整，比如上界增加 1 或下界减少 1，以表示没有找到符合条件的值。</li>
</ul>
<hr>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[right])<br>            right = mid;<br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[right];<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= target)  <span class="hljs-comment">// 查找位置第一个 &gt;= target 的数</span><br>        right = mid;<br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(right);<br><br>left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)  <span class="hljs-comment">// 查找位置最后一个 &lt;= target 的数</span><br>        left = mid;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(right);<br><br><span class="hljs-keyword">if</span> (ans[<span class="hljs-number">0</span>] == ans[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>

<h4 id="实数平方根"><a href="#实数平方根" class="headerlink" title="实数平方根"></a>实数平方根</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myRealSqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-type">double</span> left = <span class="hljs-number">0</span>, right = x;<br>    <span class="hljs-keyword">while</span> (right - left &gt; <span class="hljs-number">1e-7</span>) &#123; <span class="hljs-comment">//要求比保留小数多2，这里就是5位小数</span><br>        <span class="hljs-type">double</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt;= x) &#123;<br>            left = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h3><p><strong>算法步骤</strong>：</p>
<ul>
<li><strong>比较两点</strong> <code>lmid</code> 和 <code>rmid</code> 的函数值：<ul>
<li>如果 <code>f(lmid) &lt; f(rmid)</code>，则极值位于 <code>lmid</code> 的右边（排除 <code>lmid</code> 左侧区间），所以更新左边界 <code>left = lmid + 1</code>。</li>
<li>否则，极值位于 <code>rmid</code> 的左边（排除 <code>rmid</code> 右侧区间），更新右边界 <code>right = rmid - 1</code>。</li>
</ul>
</li>
<li>不断重复上述过程，直到区间收缩到极值点。</li>
</ul>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> lmid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> rmid = (lmid + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[lmid] &lt;= nums[rmid]) <br>        left = lmid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>        right = rmid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br><br></code></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>该算法通过三分查找，逐渐缩小区间直到找到数组的峰值位置。</li>
<li>在单峰函数中，这种方法能有效找到极值点。</li>
</ul>
<hr>
<h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>二分答案的本质啊，就是去通过题目给的限制条件。建立一个单调分段，建立一个单调分段，零一函数啊，这个函数的。定义域是解空间，就答案值域是零或者一就是数，那么这个函数本身其实是。对这个限制的一个验证啊，一个判定。那么，通过这个函数，我们就可以在整个解上，对吧？这个。空间里边去二分查找这个分线点在什么地方，这就是我们要的答案。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><h5 id="分割数组问题"><a href="#分割数组问题" class="headerlink" title="分割数组问题"></a>分割数组问题</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数组中的最大值</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 数组所有元素的和</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canSplit</span>(nums, mid, m))<br>            right = mid;  <span class="hljs-comment">// 尝试减小最大值</span><br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 增大最大值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canSplit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> maxSum, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        <span class="hljs-keyword">if</span> (sum &gt; maxSum) &#123;  <span class="hljs-comment">// 如果当前子数组的和超过了允许的最大值</span><br>            sum = num;<br>            count++;  <span class="hljs-comment">// 划分出新的子数组</span><br>            <span class="hljs-keyword">if</span> (count &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高精度问题"><a href="#高精度问题" class="headerlink" title="高精度问题"></a>高精度问题</h3><h4 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h4><p>长度很长的情况下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt; 0</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.size()) t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0，r是余数不用赋值直接传入就行</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.push_back(r / b);<br>        r %= b;<br>    &#125;<br>    reverse(C.begin(), C.end());<br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>+++++</p>
<h2 id="二-排序"><a href="#二-排序" class="headerlink" title="二.排序"></a>二.排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li><p>时间复杂度：O(n log n)</p>
</li>
<li><p>空间复杂度：O(log n)</p>
</li>
<li><p>稳定性：不稳定</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过分治法将数组划分为较小的子数组，递归排序。</p>
<p>荷兰旗问题————划分两个区域</p>
<p>流程1——划分&gt;&lt;两个区域：当前数&lt;&#x3D;目标：先和&lt;&#x3D;区下一个位置交换，然后&lt;&#x3D;区向右扩，指针后移</p>
<p>​		  							 当前数&gt;目标：指针直接后移</p>
<p>流程2——划分&gt;&#x3D;&lt;三个区域：当前数&lt;目标：先和&lt;区下一个位置交换，然后&lt;区向右扩，指针后移</p>
<p>​		 								 当前数&#x3D;&#x3D;目标：指针直接后移</p>
<p>​										  当前数&gt;目标：先和&gt;区的前一个数交换，然后&gt;区向左扩， 指针不要动											</p>
<p>​		</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆就是 <code>完全二叉树</code>+<code>满足大根或小根的结构</code>(一代不如一代，越来越强的一代)</p>
<p>我们由数组脑补出完全二叉树的结构，堆只有向上调整和向下调整两种算法</p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// 将所有元素压入堆中，形成一个最大堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        q.<span class="hljs-built_in">push</span>(-a[i]);  <span class="hljs-comment">// 使用负值来模拟最小堆</span><br>    &#125;<br>    <span class="hljs-comment">// 将堆中的元素依次弹出，得到有序序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        a[i] = -q.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 取出最小值并存入数组</span><br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：利用堆结构维护最大或最小堆。</p>
<p>最大线段重合问题</p>
<p>给定很多线段，每个线段都有两个数[start,end]表示线段开始位置和结束位置，左右都是闭区间规定：<br>1)线段的开始和结束位置一定都是整数值<br>2)线段重合区域的长度必须&gt;&#x3D;1<br>返回线段最多重合区域中，包含了几条线段</p>
<p>流程准备一个小根堆，将所有线段以第一个数的大小从小到大排序这些线段，开始执行：第一个线段将二位置放入堆中，当小根堆里有小于等于此线段第一个数时，把他取出，然后将线段第二个数push进堆里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LineSegment</span> &#123;</span><br>    <span class="hljs-type">int</span> start;<br>    <span class="hljs-type">int</span> end;<br>&#125;;<br><br><span class="hljs-comment">// 比较函数：按 start 升序排列</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">compareByStart</span><span class="hljs-params">(<span class="hljs-type">const</span> LineSegment&amp; a, <span class="hljs-type">const</span> LineSegment&amp; b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a.start &lt; b.start;  <span class="hljs-comment">// 返回 true 表示 a 排在前面</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxOverlapSegments</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;LineSegment&gt;&amp; segments)</span> &#123;<br>    <span class="hljs-keyword">if</span> (segments.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 1. 将所有线段按 start 排序</span><br>    sort(segments.begin(), segments.end(), compareByStart);<br>    <span class="hljs-comment">// 2. 小根堆用于存储线段的结束位置（end）</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    <span class="hljs-comment">// 3. 初始化最大重叠数</span><br>    <span class="hljs-type">int</span> maxOverlap = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 4. 遍历所有线段</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; segment : segments) &#123;<br>        <span class="hljs-comment">// 取出所有结束位置小于等于当前线段起始位置的线段</span><br>        <span class="hljs-keyword">while</span> (!pq.empty() &amp;&amp; pq.top() &lt;= segment.start) &#123;<br>            pq.pop();  <span class="hljs-comment">// 这些线段不再重叠</span><br>        &#125;<br>        <span class="hljs-comment">// 将当前线段的结束位置加入堆</span><br>        pq.push(segment.end);<br>        <span class="hljs-comment">// 记录堆中当前的线段数，即当前重叠的线段数</span><br>        maxOverlap = max(maxOverlap, (<span class="hljs-type">int</span>)pq.size());<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxOverlap;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;LineSegment&gt; segments = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">8</span>&#125; &#125;;<br>    <span class="hljs-type">int</span> result = maxOverlapSegments(segments);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最大重叠的线段数: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>







<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在合并的过程中，我们不仅可以 <strong>排序</strong>，还可以 <strong>统计</strong> 数组中元素之间的关系,在每层merge前统计关系</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h5><p>统计左面有多少数比本身小累加起来</p>
<p>merge过程中设置一个ans，当左组拷贝时ans+右组指针到结尾的数的个数*拷贝的数，相等时先拷贝右边</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    res += merge_sort(q, l, mid);<br>    res += merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j])&#123;     <br>            tmp[k ++ ] = q[i ++ ];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <br>            tmp[k ++ ] = q[j ++ ];<br>        &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 归并排序计算逆序对</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];  <span class="hljs-comment">// 临时数组</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 递归的终止条件</span><br>    <br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 找到中点</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 统计逆序对的结果</span><br>    <br>    <span class="hljs-comment">// 递归调用归并排序，处理左右两部分</span><br>    res += merge_sort(q, l, mid);<br>    res += merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-comment">// 合并过程中，统计符合条件的逆序对</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">tmp</span><span class="hljs-params">(r - l + <span class="hljs-number">1</span>)</span>;  <span class="hljs-comment">// 临时数组，大小为归并后数组的大小</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 统计符合条件的数 (逆序对)</span><br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= mid; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt;= r &amp;&amp; q[i] &gt; q[j]) &#123;  <span class="hljs-comment">// 比较左右两部分的元素</span><br>            j++;  <span class="hljs-comment">// 找到所有满足条件的右侧元素</span><br>        &#125;<br>        res += (j - (mid + <span class="hljs-number">1</span>));  <span class="hljs-comment">// 累加逆序对</span><br>    &#125;<br><br>    <span class="hljs-comment">// 合并过程</span><br>    i = l;  <span class="hljs-comment">// 重置 i 和 j 用于合并操作</span><br>    j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) &#123;<br>            tmp[k++] = q[i++];  <span class="hljs-comment">// 左边的元素较小</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = q[j++];  <span class="hljs-comment">// 右边的元素较小</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br><br><br>    <span class="hljs-comment">// 将临时数组的元素拷贝回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>        q[i] = tmp[j];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回当前统计的结果</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h5 id="自定义问题"><a href="#自定义问题" class="headerlink" title="自定义问题"></a>自定义问题</h5><p>num的右边有多少个数*2之后依然&lt;num 这个方案设计了R来让其滑动窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 归并排序计算逆序对</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];  <span class="hljs-comment">// 临时数组</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 递归的终止条件</span><br>    <br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 找到中点</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 统计逆序对的结果</span><br>    <br>    <span class="hljs-comment">// 递归调用归并排序，处理左右两部分</span><br>    res += merge_sort(q, l, mid);<br>    res += merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-comment">// 合并过程中，统计符合条件的逆序对</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">tmp</span><span class="hljs-params">(r - l + <span class="hljs-number">1</span>)</span>;  <span class="hljs-comment">// 临时数组，大小为归并后数组的大小</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 统计符合条件的数 (逆序对)</span><br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= mid; i++) &#123;<br>        <span class="hljs-comment">// 对于每个 q[i]，寻找右侧所有 q[j] 满足 q[i] &gt; 2 * q[j]</span><br>        <span class="hljs-comment">// 这里我们实现了一个滑动窗口，j 从 mid+1 开始，并向右滑动</span><br>        <span class="hljs-keyword">while</span> (j &lt;= r &amp;&amp; (<span class="hljs-type">long</span>)q[i] &gt; (<span class="hljs-type">long</span>)q[j] * <span class="hljs-number">2</span>) &#123;<br>            j++;  <span class="hljs-comment">// 右侧元素大于 q[i] * 2 的个数</span><br>        &#125;<br>        res += (j - (mid + <span class="hljs-number">1</span>));  <span class="hljs-comment">// 累加逆序对的个数</span><br>    &#125;<br><br>    <span class="hljs-comment">// 合并过程</span><br>    i = l;  <span class="hljs-comment">// 重置 i 和 j 用于合并操作</span><br>    j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) &#123;<br>            tmp[k++] = q[i++];  <span class="hljs-comment">// 左边的元素较小</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = q[j++];  <span class="hljs-comment">// 右边的元素较小</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br><br>    <span class="hljs-comment">// 将临时数组的元素拷贝回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>        q[i] = tmp[j];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回当前统计的结果</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="比较一个区间的问题"><a href="#比较一个区间的问题" class="headerlink" title="比较一个区间的问题"></a>比较一个区间的问题</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 合并排序计算区间和在 [lower, upper] 范围内的数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 递归调用归并排序，统计左半部分和右半部分</span><br>    res += merge_sort(nums, l, mid, lower, upper);<br>    res += merge_sort(nums, mid + <span class="hljs-number">1</span>, r, lower, upper);<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">tmp</span><span class="hljs-params">(r - l + <span class="hljs-number">1</span>)</span>;<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 统计符合条件的数 (区间和在 lower, upper 范围内)</span><br>    <span class="hljs-type">int</span> windowL = l;<br>    <span class="hljs-type">int</span> windowR = l;<br>    <br>    <span class="hljs-keyword">for</span> (i = j; i &lt;= r; i++) &#123;<br>        <span class="hljs-type">long</span> min_val = nums[i] - upper;<br>        <span class="hljs-type">long</span> max_val = nums[i] - lower;<br><br>        <span class="hljs-keyword">while</span> (windowR &lt;= mid &amp;&amp; nums[windowR] &lt;= max_val) &#123;<br>            windowR++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (windowL &lt;= mid &amp;&amp; nums[windowL] &lt; min_val) &#123;<br>            windowL++;<br>        &#125;<br><br>        res += windowR - windowL;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并过程</span><br>    i = l;<br>    j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>            tmp[k++] = nums[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = nums[j++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = nums[j++];<br><br>    <span class="hljs-comment">// 将临时数组的元素拷贝回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l, k = <span class="hljs-number">0</span>; i &lt;= r; i++, k++) &#123;<br>        nums[i] = tmp[k];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回当前统计的结果</span><br>&#125;<br></code></pre></td></tr></table></figure>









<h4 id="查找第-k-大元素"><a href="#查找第-k-大元素" class="headerlink" title="查找第 k 大元素"></a>查找第 <code>k</code> 大元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// quickSort 函数：用于查找在排序后位置为 index 的元素的值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> arr[l];<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(arr, l, r);<br>        <span class="hljs-keyword">if</span> (index == pivot) <span class="hljs-keyword">return</span> arr[pivot];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; pivot) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(arr, l, pivot - <span class="hljs-number">1</span>, index);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(arr, pivot + <span class="hljs-number">1</span>, r, index);<br>    &#125;<br><br>    <span class="hljs-comment">// partition 函数：分区操作，返回分区位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = l + <span class="hljs-built_in">rand</span>() % (r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> pivotVal = a[pivot];<br><br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">while</span> (a[l] &lt; pivotVal) l++;<br>            <span class="hljs-keyword">while</span> (a[r] &gt; pivotVal) r--;<br>            <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> temp = a[l];<br>                a[l] = a[r];<br>                a[r] = temp;<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="翻转对"><a href="#翻转对" class="headerlink" title="翻转对"></a>翻转对</h4><p>题目要求在一个数组中找到满足条件 <code>nums[i] &gt; 2 * nums[j]</code> 的所有下标对 <code>(i, j)</code>，其中 <code>i &lt; j</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ans;  <span class="hljs-comment">// 全局变量，记录翻转对数量</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr, l, mid);<br>        <span class="hljs-built_in">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">calculate</span>(arr, l, mid, r);<br>        <span class="hljs-built_in">merge</span>(arr, l, mid, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= mid; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt;= right &amp;&amp; arr[i] &gt; <span class="hljs-number">2LL</span> * arr[j]) j++;<br>            ans += j - (mid + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 累加符合条件的对数</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) temp[k++] = arr[i++];<br>            <span class="hljs-keyword">else</span> temp[k++] = arr[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temp.<span class="hljs-built_in">size</span>(); i++) arr[left + i] = temp[i];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="三-前缀和"><a href="#三-前缀和" class="headerlink" title="三.前缀和"></a>三.前缀和</h2><p>一维前缀和<br>S[i] &#x3D; a[1] + a[2] + … a[i]<br>a[l] + … + a[r] &#x3D; S[r] - S[l - 1]</p>
<p>一维差分<br>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</p>
<p>二维前缀和<br>S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>二维差分<br>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c</p>
<h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>定义：前缀和数组是用于快速计算数组任意区间和的辅助数组。<code>S[i]</code> 表示从数组开头到第 <code>i</code> 个元素的累加和。</p>
<p>公式：</p>
<ul>
<li>基本公式：<code>S[i] = S[i-1] + A[i]</code></li>
<li>区间和公式：要计算原数组 <code>A</code> 中 <code>[i, j]</code> 区间的和，可以使用前缀和数组：<code>sum(i, j) = S[j] - S[i-1]</code>  用x,y模拟s[x]-s[y]此时只需要遍历x的位置。</li>
</ul>
<p>[3, 1, 4, 5, 2]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//维护前缀和的写法[3, 4, 8, 13, 15]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sums</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>; <br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>    s[i] = s[i<span class="hljs-number">-1</span>] + sums[i<span class="hljs-number">-1</span>]; <br>&#125;<br><br><br><span class="hljs-comment">//preMin写法，从左往右遍历，preMin[] = [3, 1, 1, 1, 1]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preMin</span><span class="hljs-params">(n)</span></span>;<br>preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>];  <span class="hljs-comment">//这里的s指的是前缀和数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    preMin[i] = <span class="hljs-built_in">min</span>(preMin[i<span class="hljs-number">-1</span>], s[i]);   <br>&#125;<br><br><br><span class="hljs-comment">//preMax写法，从左往右遍历，preMax[] = [3, 3, 4, 5, 5]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preMax</span><span class="hljs-params">(n)</span></span>;<br>preMax[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>];  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    preMax[i] = <span class="hljs-built_in">max</span>(preMax[i<span class="hljs-number">-1</span>], s[i]);  <br>&#125;<br><br><span class="hljs-comment">//sufMin 的写法，从右往左遍历，sufMin[] = [1, 1, 2, 2, 2]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sufMin</span><span class="hljs-params">(n)</span></span>;<br>sufMin[n<span class="hljs-number">-1</span>] = s[n<span class="hljs-number">-1</span>]; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    sufMin[i] = <span class="hljs-built_in">min</span>(sufMin[i + <span class="hljs-number">1</span>], s[i]);  <br>&#125;<br><br><span class="hljs-comment">//sufMax 的写法，从右往左遍历，sufMax[] = [5, 5, 5, 5, 2]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sufMax</span><span class="hljs-params">(n)</span></span>;<br>sufMax[n<span class="hljs-number">-1</span>] = s[n<span class="hljs-number">-1</span>];  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    sufMax[i] = <span class="hljs-built_in">max</span>(sufMax[i + <span class="hljs-number">1</span>], s[i]); <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>思路</strong>：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。所以只需用一个计数数组或 hash map 维护S中每个值的个数，枚举右端点 i，看一下等于S[i]-k 的值有几个就行了</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><h5 id="优美子数组和问题"><a href="#优美子数组和问题" class="headerlink" title="优美子数组和问题"></a>优美子数组和问题</h5><p>子数组中的奇数个数等于给定的整数 <code>k</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;vector&gt;<br>#include &lt;unordered_map&gt;<br><br>using namespace std;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>; <span class="hljs-comment">// 前缀和数组 s(0-n)，初始化为0</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; count; <span class="hljs-comment">// 用于记录前缀和出现的次数</span><br>    count[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始前缀和为0时，计数为1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算前缀和 s[i]，其中 nums[i-1] 是当前元素，nums[i-1] % 2 用于判断奇偶性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>; <span class="hljs-comment">// 前缀和的奇偶性计算</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] - k &gt;= <span class="hljs-number">0</span>) &#123;<br>            ans += count[s[i] - k]; <span class="hljs-comment">// 如果满足条件，累加出现的次数</span><br>        &#125;<br>        count[s[i]]++; <span class="hljs-comment">// 更新当前前缀和出现的次数</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>解析：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。所以只需用一个计数数组或 hash map 维护S中每个值的个数，枚举右端点 i，看一下等于S[i]-k 的值有几个就行了</p>
<h5 id="最大子数组和问题"><a href="#最大子数组和问题" class="headerlink" title="最大子数组和问题"></a>最大子数组和问题</h5><p>问题描述：给定一个整数数组，要求找到其最大子数组的和。子数组的定义是数组中连续的一部分元素。</p>
<p><strong>思路</strong>：</p>
<p>可以通过前缀和的方式来求解最大子数组和问题。</p>
<p>同时我们需要一个 <code>preMin</code> 数组来记录当前子数组的前缀和中的最小值，以便在当前区间进行减法操作时，获得可能的最大子数组和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-type">int</span>[] preMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀最小值数组</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算前缀和</span><br>    &#125;<br>    preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>]; <span class="hljs-comment">//preMin书写模版</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        preMin[i] = Math.min(preMin[i-<span class="hljs-number">1</span>], s[i]); <span class="hljs-comment">// 维护前缀最小值</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>; <span class="hljs-comment">// 初始化答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = Math.max(ans, s[i] - preMin[i-<span class="hljs-number">1</span>]); <span class="hljs-comment">// 计算最大子数组和 从一开始</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="一维差分数组"><a href="#一维差分数组" class="headerlink" title="一维差分数组"></a>一维差分数组</h3><p>总结：把 A的第!个数到第r个数加 d，B 的变化为:B;加 d，B,+ 减d，它比较适用于我们想把一段儿-个子段都加一个值的时候。比如我们想把a的dl到底I个数啊啊|到r这个字段都加一个数d。</p>
<ul>
<li><p><strong>差分数组</strong>的引入则为高效区间更新提供了一种新的方法。在解决大规模区间更新问题时，如果直接对原数组进行操作，时间复杂度会比较高，而差分数组通过记录相邻元素之间的差值，在常数时间内更新区间，最后通过前缀和恢复原数组。</p>
</li>
<li><p>例如，在航班预定问题中，差分数组 <code>id</code> 被用来记录每个区间的变化量，最终通过前缀和恢复预定后的航班乘客数量。</p>
</li>
<li><p>差分数组的本质是通过对局部变化的记录和累积，使得区间更新可以在 O(1) 时间内完成，极大优化了需要频繁进行更新操作的场景。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">宇航票预定<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">book</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bookings, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; booking : bookings) &#123;<br>            <span class="hljs-type">int</span> a = booking[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> b = booking[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> c = booking[<span class="hljs-number">2</span>];<br>            id[a] += c;<br>            id[b + <span class="hljs-number">1</span>] -= c;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + id[i];<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            answer[i - <span class="hljs-number">1</span>] = sum[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><ul>
<li><p>在本部分的笔记中，前缀和的概念被推广到了二维情况。二维前缀和 <code>S[i][j]</code> 表示的是从矩阵左上角 <code>(1, 1)</code> 到当前坐标 <code>(i, j)</code> 的所有元素的累加和，这一概念让我们能够快速计算任意矩形区域内的元素和。</p>
</li>
<li><p>类似于一维前缀和的区间和公式，二维前缀和的矩形区域和通过前缀和数组快速求解，避免了重复计算。计算区域 <code>(p, q)</code> 到 <code>(i, j)</code> 的矩形区域和的公式为：</p>
<ul>
<li><code>sum(p, q, i, j) = S[i][j] - S[i][q-1] - S[p-1][j] + S[p-1][q-1]</code></li>
</ul>
</li>
<li><p>这种方式不仅能快速处理问题，还能提升算法的时间复杂度，尤其适合处理较大规模的矩阵求和问题。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">二维区域的和<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.length;<br>    <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].length;<br>    sum = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            sum[i][j] = sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>    row1 += <span class="hljs-number">1</span>;<br>    col1 += <span class="hljs-number">1</span>;<br>    row2 += <span class="hljs-number">1</span>;<br>    col2 += <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> sum[row2][col2] - sum[row1 - <span class="hljs-number">1</span>][col2] - sum[row2][col1 - <span class="hljs-number">1</span>] + sum[row1 - <span class="hljs-number">1</span>][col1 - <span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="二维差分数组"><a href="#二维差分数组" class="headerlink" title="二维差分数组"></a>二维差分数组</h3><hr>
<h2 id="四-进制转换"><a href="#四-进制转换" class="headerlink" title="四.进制转换"></a>四.进制转换</h2><hr>
<h2 id="五-找规律能力"><a href="#五-找规律能力" class="headerlink" title="五.找规律能力"></a>五.找规律能力</h2><hr>
<h2 id="六-链表"><a href="#六-链表" class="headerlink" title="六.链表"></a>六.链表</h2><p>直接链表实现过于浪费，我们一般通过数组来模拟链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;<br>    head = ne[head];<br>&#125;<br><span class="hljs-comment">// 在第k个位置插入一个数a (k是从1开始的)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertAt</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>        insert(a);  <span class="hljs-comment">// 如果是插入头部，直接调用插入头部的函数</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-comment">// 找到第k-1个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k - <span class="hljs-number">1</span> &amp;&amp; cur != <span class="hljs-number">-1</span>; i++) &#123;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果k超出了链表的范围</span><br>    e[idx] = a;<br>    ne[idx] = ne[cur];  <span class="hljs-comment">// 新节点的next指向第k个节点</span><br>    ne[cur] = idx;      <span class="hljs-comment">// 第k-1个节点的next指向新节点</span><br>    idx++;<br>&#125;<br><span class="hljs-comment">// 删除第k个位置的元素 (k是从1开始的)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">removeAt</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>        remove();  <span class="hljs-comment">// 如果删除的是头结点，直接调用删除头结点的函数</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-comment">// 找到第k-1个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k - <span class="hljs-number">1</span> &amp;&amp; cur != <span class="hljs-number">-1</span>; i++) &#123;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">-1</span> || ne[cur] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// k超出范围</span><br>    <span class="hljs-comment">// 删除第k个节点</span><br>    <span class="hljs-type">int</span> temp = ne[cur];<br>    ne[cur] = ne[temp];  <span class="hljs-comment">// 第k-1个节点的next指向第k+1个节点</span><br>&#125;<br><span class="hljs-comment">// 查找第k个位置的元素 (k是从1开始的)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getAt</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-comment">// 遍历到第k个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k &amp;&amp; cur != <span class="hljs-number">-1</span>; i++) &#123;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果k超出了链表的范围</span><br>    <span class="hljs-keyword">return</span> e[cur];<br>&#125;<br><span class="hljs-comment">// 输出链表所有元素</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; e[cur] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure>



<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl">head  head 是一个指针，指向链表的第一个节点，因此它表示整个链表的起始<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;null(补充的<span class="hljs-keyword">last</span>)<br><br> struct ListNode &#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* <span class="hljs-keyword">next</span>;<br>    ListNode(<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>) : val(<span class="hljs-keyword">x</span>), <span class="hljs-keyword">next</span>(nullptr) &#123;&#125;<br>&#125;;<br><br>ListNode* reverseList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-keyword">last</span> = nullptr;<br>    <span class="hljs-keyword">while</span> (head != nullptr) &#123;<br>        ListNode* nextHead = head-&gt;<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span> 暂存下一个节点<br>        head-&gt;<span class="hljs-keyword">next</span> = <span class="hljs-keyword">last</span>;                <span class="hljs-regexp">//</span> 反转当前节点的指针<br>        <span class="hljs-keyword">last</span> = head;                      <span class="hljs-regexp">//</span> 更新<span class="hljs-keyword">last</span>为当前节点<br>        head = nextHead;                  <span class="hljs-regexp">//</span> 继续处理下一个节点<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">last</span>;                          <span class="hljs-regexp">//</span> 返回新头节点<br>&#125;<br><br></code></pre></td></tr></table></figure>





<p>+++++</p>
<h2 id="七-栈"><a href="#七-栈" class="headerlink" title="七.栈"></a>七.栈</h2><h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>经验</p>
<p>当新h小于之前的h,进行累加长度更新答案,pop上一个被推的栈,推累长加一的h栈</p>
<p>核心思想:单调栈考虑前面不影响后面<br>套路模版: </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//int一个答案要全局</span><br>heights.push_back(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果需要弹空就写</span><br><span class="hljs-keyword">for</span>()&#123;<br>	<span class="hljs-keyword">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(栈顶与新元素不满足单调栈)&#123;<br>	 	累加长度<br>	 	更新答案<br>	 	<span class="hljs-keyword">pop</span>弹栈<br>	 	....... <span class="hljs-comment">//期间可以思考增加限制</span><br>	&#125;<br>	s.<span class="hljs-keyword">push</span>(&#123;accmulatedWidth+<span class="hljs-number">1</span>,height&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><h4 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">heighs=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br>private:<br>	stuct UERT&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	<span class="hljs-built_in">stack</span> &lt;UERT&gt; s;<br>public:<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>    	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    	heights.push_back(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 便于最后清空栈</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>    		<span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度小于栈顶柱子的高度，则计算面积</span><br>            <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top().height &gt;= height) &#123;<br>                accmulatedWidth += s.top().width;<br>                res = max(ans,s.top().width*accmulatedWidth);            <br>                s.pop();            <br>        	&#125;<br>        	s.push(&#123;accmulatedWidth+<span class="hljs-number">1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>   		&#125;<br>    	<span class="hljs-keyword">return</span> res;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>private:<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UERT</span>&#123;</span><br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	<span class="hljs-built_in">stack</span> &lt;UERT&gt; s;<br>public:<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>            <span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度大于栈顶柱子，计算能存储的雨水</span><br>            <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top().height &lt;= height) &#123;<br>                <span class="hljs-type">int</span> bottom = s.top().height;<br>                accmulatedWidth += s.top().width;<br>                s.pop();<br>                <span class="hljs-keyword">if</span> (s.empty()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果栈为空，跳过,水从左边溜走了</span><br>                <span class="hljs-type">int</span> up = min(height,s.top().height);<br>                ans += accmulatedWidth*(up-bottom);<br>            &#125;<br>            s.push(&#123;accmulatedWidth+<span class="hljs-number">1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>        &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;	<br>	<br>前缀和思想<br><span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>    <span class="hljs-type">int</span> n = heights.size();<br>    preMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    sufMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    <br>    <span class="hljs-comment">// 预处理preMax数组</span><br>    preMax[<span class="hljs-number">0</span>] = heights[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        preMax[i] = max(preMax[i - <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 预处理sufMax数组</span><br>    sufMax[n - <span class="hljs-number">1</span>] = heights[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        sufMax[i] = max(sufMax[i + <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> up = min(preMax[i - <span class="hljs-number">1</span>], sufMax[i + <span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> bottom = heights[i];<br>        <span class="hljs-keyword">if</span> (up &gt; bottom) &#123;<br>            ans += up - bottom;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>preMax[]：记录当前位置左侧的最大高度。<br>sufMax[]：记录当前位置右侧的最大高度。<br></code></pre></td></tr></table></figure>







<p>+++++</p>
<h2 id="八-队列和双指针"><a href="#八-队列和双指针" class="headerlink" title="八.队列和双指针"></a>八.队列和双指针</h2><p>模拟队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>我们就希望去维护一个这样的候选,集合里边的元素，它们的值是递减的。所以当I它大于等于k-1时，我已经攒够了。q的值是递减的呀，可能成为一个答案的选项，那么此时就对头最好，我就取对头作为答案。这就是我们要干三件事情。</p>
<p>单调队列维护的是一个候选集合，前面的比较旧，后面的比较新(时间有单调性</p>
<p>候选项的某个属性也具有单调性</p>
<p>确定递增递减的方法–考虑任意两个候选顶j&lt;j2，写出j比优的条件</p>
<p>排除冗余的关键:若j比j差，j的生命周期还比了短，那了 就没卵用了</p>
<p>单调队列题目代码套路:<br>·for 每个元素<br>    (1)while(队头过期)队头出队<br>    (2)取队头为最佳选项，计算答案                                                                                                                                            	(3)while(队尾与新元素不满足单调性)队尾出队                                                                                                                                                                                                                                                        	(3)新元素入队</p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="找到滑动窗口最大值"><a href="#找到滑动窗口最大值" class="headerlink" title="找到滑动窗口最大值"></a>找到滑动窗口最大值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">maxSlidingWindow</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; ans; <span class="hljs-comment">// 存储结果</span><br>        <span class="hljs-built_in">deque</span>&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 用于维护滑动窗口的双端队列</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-comment">// 删除过期元素：如果队首元素不在当前窗口范围内，则弹出队首</span><br>            <span class="hljs-keyword">while</span> (!q.empty() &amp;&amp; q.front() &lt;= i - k) &#123;<br>                q.pop_front();<br>            &#125;<br><br>            <span class="hljs-comment">// 插入新元素：移除队列中所有小于当前元素的值，以保持递减顺序</span><br>            <span class="hljs-keyword">while</span> (!q.empty() &amp;&amp; nums[q.back()] &lt;= nums[i]) &#123;<br>                q.pop_back();<br>            &#125;<br><br>            <span class="hljs-comment">// 将当前元素的索引加入到队列中</span><br>            q.push_back(i);<br><br>            <span class="hljs-comment">// 记录当前窗口的最大值：队首元素即为窗口内的最大值</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                ans.push_back(nums[q.front()]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="二维单调队列"><a href="#二维单调队列" class="headerlink" title="二维单调队列"></a>二维单调队列</h3><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><strong>定义</strong>：通过一左一右或一前一后两个指针逼近来找到符合条件的解</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for<span class="hljs-comment">(i=0,j=0;i&lt;n;i++)</span>&#123;<br>	<span class="hljs-keyword">while</span> <span class="hljs-comment">(j&lt;i&amp;&amp;check(i,j)</span>)j++;<br>	<span class="hljs-comment">//每道题目的具体逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><h5 id="两数之和："><a href="#两数之和：" class="headerlink" title="两数之和："></a>两数之和：</h5><p>给定一个有序数组，找到两个数，使得它们的和等于目标值 <code>target</code>。返回这两个数的下标，假定数组内没有重复解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入有序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 两个指针从数组两端开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; numbers[i]+numbers[j]&gt;target)	j--;<br>        <span class="hljs-keyword">if</span> (i&lt;j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>            reture &#123;i<span class="hljs-number">+1</span>,j<span class="hljs-number">+1</span>&#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;<br><br>输入无序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; pairs;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        pairs.<span class="hljs-built_in">push</span>(&#123;num[i],i&#125;);  <br>    &#125;<br>    <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(),pairs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> j = pairs.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;pairs.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first&gt;target)	j--;<br>        <span class="hljs-keyword">if</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first==target)&#123;<br>            <span class="hljs-keyword">return</span> &#123;pairs[i],second , pairs[j].second&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;  <br></code></pre></td></tr></table></figure>



<h5 id="三数之和："><a href="#三数之和：" class="headerlink" title="三数之和："></a>三数之和：</h5><p>给定一个数组 <code>nums</code>，找出其中的三个数，使得它们的和为 0。可以假设数组中没有重复解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; jks = <span class="hljs-built_in">twoSum</span>(nums, i + <span class="hljs-number">1</span>, -nums[i]);<br>            <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; jk : jks) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], jk[<span class="hljs-number">0</span>], jk[<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--;<br>            <span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;numbers[i], numbers[j]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>优化与细节</strong>：</p>
<ul>
<li><strong>去重处理</strong>：为了避免重复解，固定数和双指针都需要跳过重复的元素。例如，固定数 <code>nums[i]</code> 相同的情况不再处理，双指针的 <code>nums[j]</code> 和 <code>nums[k]</code> 也需要处理重复的情况。</li>
<li><strong>时间复杂度</strong>：排序时间复杂度为 O(nlogn)，之后遍历和双指针查找的时间复杂度是 O(n²)，总体复杂度为 O(n²)。</li>
</ul>
<h5 id="盛水最多的容器："><a href="#盛水最多的容器：" class="headerlink" title="盛水最多的容器："></a>盛水最多的容器：</h5><p>给定一个数组 <code>height</code>，其中每个元素代表容器壁的高度，找到两个容器壁，使得它们与 X 轴构成的容器能盛最多的水。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>        <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) i++;<br>        <span class="hljs-keyword">else</span> j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="离散化问题"><a href="#离散化问题" class="headerlink" title="离散化问题"></a>离散化问题</h3><p>将一个区间内的连续的、可能是非常大的数值范围（例如整数或浮点数）映射到一个较小的、连续的整数区间   数据范围在十的九次方左右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br>sort(alls.begin(), alls.end()); <span class="hljs-comment">// 将所有值排序</span><br>alls.erase(unique(alls.begin(), alls.end()), alls.end());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span><br>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br><br>find调用后返回新数组的下标<br></code></pre></td></tr></table></figure>

<h3 id="区间合并问题"><a href="#区间合并问题" class="headerlink" title="区间合并问题"></a>区间合并问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)&#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况"><a href="#比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况" class="headerlink" title="比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况"></a>比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况</h3><ol>
<li>前缀和（Prefix Sum）<br>适用情况：<br>快速计算数组某个子区间的和：适用于需要多次计算数组某个区间和的场景。<br>区间查询和更新较少：适合静态数组或查询操作远多于更新操作的情况。</li>
<li>差分（Difference Array）<br>适用情况：<br>快速进行区间修改：适用于需要频繁对数组某个区间进行加减操作的场景。<br>需要高效进行批量更新：适合大规模区间更新操作。</li>
<li>双指针（Two Pointers）<br>适用情况：<br>处理有序数组：适用于需要在有序数组或链表中查找、遍历等操作。<br>解决滑动窗口问题：适合在数组或字符串上维护动态区间的问题。</li>
<li>滑动窗口（Sliding Window）<br>适用情况：<br>子数组问题：适用于需要找到数组中满足特定条件的子数组或子字符串的问题。<br>连续子区间：适合处理需要计算连续子区间的问题。</li>
<li>单调栈（Monotonic Stack）<br>适用情况：<br>找到数组中每个元素的下一个更大（或更小）元素：适用于需要在数组中找到特定方向上的极值问题。<br>维护区间单调性：适合处理需要保持区间单调性的问题。</li>
</ol>
<hr>
<h2 id="九-优先列队-堆"><a href="#九-优先列队-堆" class="headerlink" title="九.优先列队&#x2F;堆"></a>九.优先列队&#x2F;堆</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><br>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        heap_swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        heap_swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) down(i);<br><br></code></pre></td></tr></table></figure>







<hr>
<h2 id="十-哈希表"><a href="#十-哈希表" class="headerlink" title="十. 哈希表"></a>十. 哈希表</h2><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="找到两数之和"><a href="#找到两数之和" class="headerlink" title="找到两数之和"></a>找到两数之和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> nums[<span class="hljs-number">100005</span>]; <span class="hljs-comment">// 假设最多10^5个元素</span><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; h;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">find</span>(target - nums[i]) != h.<span class="hljs-built_in">end</span>()) &#123;<br>            cout &lt;&lt; h[target - nums[i]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        h[nums[i]] = i;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;-1 -1\n&quot;</span>; <span class="hljs-comment">// 未找到匹配项</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, target;<br>    cin &gt;&gt; n &gt;&gt; target;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-built_in">twoSum</span>(n, target);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="模拟行走机器人"><a href="#模拟行走机器人" class="headerlink" title="模拟行走机器人"></a>模拟行走机器人</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> dirs[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 方向数组</span><br><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">60010</span> + y; <span class="hljs-comment">// 映射函数</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">robotSim</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> commands[], <span class="hljs-type">int</span> obstacles[][<span class="hljs-number">2</span>])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        s.insert(f(obstacles[i][<span class="hljs-number">0</span>], obstacles[i][<span class="hljs-number">1</span>]));<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> c = commands[i];<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-2</span>) &#123;<br>            k = (k + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>; <span class="hljs-comment">// 左转</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-1</span>) &#123;<br>            k = (k + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>; <span class="hljs-comment">// 右转</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (c-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> nx = x + dirs[k], ny = y + dirs[k + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (s.count(f(nx, ny))) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 遇到障碍物</span><br>                x = nx;<br>                y = ny;<br>                ans = max(ans, x * x + y * y);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> commands[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; commands[i];<br>    <span class="hljs-type">int</span> obstacles[m][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) <span class="hljs-built_in">cin</span> &gt;&gt; obstacles[i][<span class="hljs-number">0</span>] &gt;&gt; obstacles[i][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; robotSim(n, m, commands, obstacles) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; groupAnagrams(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; strs) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; h;  <span class="hljs-comment">// 哈希表，键是排序后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strs) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> key = str;<br>            <span class="hljs-built_in">std</span>::sort(key.begin(), key.end());  <span class="hljs-comment">// 将字符串排序</span><br>            h[key].push_back(str);  <span class="hljs-comment">// 将原始字符串加入哈希表</span><br>        &#125;<br>        <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : h) &#123;<br>            result.push_back(p.second);  <span class="hljs-comment">// 收集结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<p>++++</p>
<h2 id="十一-并查集"><a href="#十一-并查集" class="headerlink" title="十一.并查集"></a>十一.并查集</h2><p>1.返回两个集合是否相同：查上游是否是一个节点，最后一个节点指向自己</p>
<p>2.取并集：小挂大上</p>
<h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">U 1 2 将节点 1 和 2 合并到同一个集合</span><br><span class="hljs-comment">U 3 4</span><br><span class="hljs-comment">F 1 3</span><br><span class="hljs-comment">U 2 3</span><br><span class="hljs-comment">F 1 3</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 假设节点数的最大值</span><br><span class="hljs-type">int</span> p[N];  <span class="hljs-comment">// 存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的大祖宗节点</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) &#123; <span class="hljs-comment">//自己不是祖宗</span><br>        p[x] = find(p[x]);  <span class="hljs-comment">// 路径压缩，向上找祖宗</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;  <span class="hljs-comment">// n:节点数, m:操作数</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        p[i] = i;  <span class="hljs-comment">// 每个节点的祖宗节点是自己</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op;  <span class="hljs-comment">// 操作类型，&#x27;U&#x27; 表示 Union，&#x27;F&#x27; 表示 Find</span><br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op &gt;&gt; a &gt;&gt; b;<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 合并操作</span><br>            p[find(a)] = find(b); <span class="hljs-comment">//a的大祖宗的上一个祖宗变成b的大祖宗，p[]指上一个祖宗</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;F&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 查询操作，输出a和b是否属于同一个集合</span><br>            <span class="hljs-keyword">if</span> (find(a) == find(b)) &#123;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// a 和 b 在同一集合</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// a 和 b 不在同一集合</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="维护size的并查集："><a href="#维护size的并查集：" class="headerlink" title="维护size的并查集："></a>维护size的并查集：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">//  p = [2, 2, 3, 4, 5]   // 1 挂到 2 下  size = [1, 2, 1, 1, 1] // 2 变成祖宗，大小变为 2</span><br><br><br><br><span class="hljs-type">int</span> p[N], size[N];<span class="hljs-comment">//以i为节点的家庭有多少人（包括自己）</span><br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[find(a)] = find(b);<br>size[b] += size[a];<br></code></pre></td></tr></table></figure>

<h3 id="维护到祖宗节点距离的并查集："><a href="#维护到祖宗节点距离的并查集：" class="headerlink" title="维护到祖宗节点距离的并查集："></a>维护到祖宗节点距离的并查集：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//p = [2, 2, 3, 4, 5]   // 1 → 2   d = [3, 0, 0, 0, 0]   // d[1] = 3（1 到 2 的偏移量）</span><br><br><span class="hljs-type">int</span> p[N], d[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 x到上个祖宗的距离</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-type">int</span> u = find(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    d[I] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[find(a)] = find(b);<br>d[find(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure>

<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h4 id="朋友圈问题"><a href="#朋友圈问题" class="headerlink" title="朋友圈问题"></a>朋友圈问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">205</span>; <span class="hljs-comment">// 假设最多有 200 个城市</span><br><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 记录每个城市的祖宗节点</span><br><span class="hljs-comment">// 查找 x 的祖宗节点（带路径压缩）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]); <span class="hljs-comment">// 让 x 直接指向根，优化查询速度</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 合并 a 和 b 所在的集合</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    p[find(a)] = find(b); <span class="hljs-comment">// 让 a 的祖宗指向 b 的祖宗，合并两个集合</span><br>&#125;<br><span class="hljs-comment">// 计算省份数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> &#123;<br>    <span class="hljs-type">int</span> n = isConnected.size(); <span class="hljs-comment">// 城市数量</span><br>    <span class="hljs-comment">// 初始化并查集，每个城市的祖宗是自己</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) p[i] = i;<br>    <span class="hljs-comment">// 遍历上三角矩阵，合并相连的城市</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j]) &#123;<br>                unite(i, j); <span class="hljs-comment">// 直接连接的城市合并到同一集合</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 统计不同的祖宗节点数量</span><br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt; provinces;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        provinces.insert(find(i)); <span class="hljs-comment">// 找到 i 的祖宗节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> provinces.size(); <span class="hljs-comment">// 祖宗节点的个数就是省份数</span><br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; isConnected = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; findCircleNum(isConnected) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出省份数量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> p[N], size[N];  <span class="hljs-comment">// p[] 记录父节点, size[] 记录集合大小</span><br><span class="hljs-type">int</span> count;  <span class="hljs-comment">// 记录当前岛屿数量</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);  <span class="hljs-comment">// 路径压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">int</span> fx = find(x), fy = find(y);<br>    <span class="hljs-keyword">if</span> (fx != fy) &#123;<br>        p[fx] = fy;<br>        count--;  <span class="hljs-comment">// 合并后岛屿数减少</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> &#123;<br>    <span class="hljs-keyword">if</span> (grid.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rows = grid.size(), cols = grid[<span class="hljs-number">0</span>].size();<br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows * cols; i++) p[i] = i;<br>    <span class="hljs-comment">// 遍历矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                count++;  <span class="hljs-comment">// 发现一个新的岛屿</span><br>                <span class="hljs-type">int</span> idx = i * cols + j;<br>                <span class="hljs-comment">// 向右合并</span><br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; cols &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) unite(idx, idx + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 向下合并</span><br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; rows &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) unite(idx, idx + cols);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&gt; grid = &#123;<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;<br>    &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; numIslands(grid) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<hr>
<h2 id="十二-树状数组"><a href="#十二-树状数组" class="headerlink" title="十二.树状数组"></a>十二.树状数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FenwickTree</span> &#123;</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; t;<br>    <br>    FenwickTree(<span class="hljs-type">int</span> n) : t(n + <span class="hljs-number">1</span>) &#123;&#125; <span class="hljs-comment">// 初始化大小为 n+1 的树状数组</span><br>    <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> d)</span> &#123; <span class="hljs-comment">// 单点更新，将索引 i 增加 d</span><br>        <span class="hljs-keyword">for</span> (++i; i &lt; t.size(); i += i &amp; -i) t[i] += d;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123; <span class="hljs-comment">// 查询前 i 项的前缀和</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (++i; i &gt; <span class="hljs-number">0</span>; i -= i &amp; -i) s += t[i];<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123; <span class="hljs-comment">// 查询区间 [l, r] 的区间和</span><br>        <span class="hljs-keyword">return</span> qry(r) - qry(l - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, q;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; q;<br>    FenwickTree <span class="hljs-title function_">t</span><span class="hljs-params">(n)</span>;<br>    <br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> op;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 操作 1: 单点更新</span><br>            <span class="hljs-type">int</span> i, d;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; i &gt;&gt; d;<br>            t.upd(i, d);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 操作 2: 查询区间和</span><br>            <span class="hljs-type">int</span> l, r;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; t.qry(l, r) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="统计逆序对"><a href="#统计逆序对" class="headerlink" title="统计逆序对"></a>统计逆序对</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">500001</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FenwickTree</span> &#123;</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; t;<br>    FenwickTree(<span class="hljs-type">int</span> n) : t(n + <span class="hljs-number">1</span>) &#123;&#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-keyword">for</span> (++i; i &lt; t.size(); i += i &amp; -i) &#123;<br>            t[i] += v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">long</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (++i; i &gt; <span class="hljs-number">0</span>; i -= i &amp; -i) &#123;<br>            s += t[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, alls;  <span class="hljs-comment">// 用来存储所有待离散化的值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br>        alls.push_back(arr[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 离散化的处理</span><br>    sort(alls.begin(), alls.end());<br>    alls.erase(unique(alls.begin(), alls.end()), alls.end()); <span class="hljs-comment">// 去重</span><br><br>    <span class="hljs-comment">// 二分查找找第一个大于等于x的位置，映射到1, 2, ..., n</span><br>    <span class="hljs-keyword">auto</span> find = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回新的下标映射</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 将原数组中的值离散化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        arr[i] = find(arr[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// Fenwick Tree 用于求解逆序对</span><br>    FenwickTree <span class="hljs-title function_">fenwick</span><span class="hljs-params">(alls.size())</span>;<br>    <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        ans += fenwick.sum(arr[i] - <span class="hljs-number">1</span>);<br>        fenwick.add(arr[i], <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="升序三元组"><a href="#升序三元组" class="headerlink" title="升序三元组"></a>升序三元组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">30001</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FenwickTree</span> &#123;</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt; tree1, tree2;<br>    <span class="hljs-type">int</span> m;<br><br>    FenwickTree(<span class="hljs-type">int</span> size) : tree1(size + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), tree2(size + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), m(size) &#123;&#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> i &amp; -i;<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;&amp; tree, <span class="hljs-type">int</span> i, <span class="hljs-type">long</span> c)</span> &#123;<br>        <span class="hljs-keyword">while</span> (i &lt;= m) &#123;<br>            tree[i] += c;<br>            i += lowbit(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;&amp; tree, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            ans += tree[i];<br>            i -= lowbit(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(MAXN)</span>, <span class="hljs-title function_">sorted_arr</span><span class="hljs-params">(MAXN)</span>, alls; <span class="hljs-comment">// `alls` 用来存储所有待离散化的值</span><br><br><span class="hljs-comment">// 二分查找并返回离散化后的下标</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到 1, 2, ..., n</span><br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 收集所有待离散化的值</span><br>    alls.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        alls.push_back(arr[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 离散化：排序并去重</span><br>    sort(alls.begin(), alls.end());<br>    alls.erase(unique(alls.begin(), alls.end()), alls.end());<br><br>    <span class="hljs-comment">// 离散化原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        arr[i] = find(arr[i]); <span class="hljs-comment">// 使用 `find` 函数获取离散化的值</span><br>    &#125;<br><br>    FenwickTree <span class="hljs-title function_">fenwick</span><span class="hljs-params">(alls.size())</span>; <span class="hljs-comment">// 使用新的离散化大小</span><br>    <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">long</span> right_count = fenwick.sum(fenwick.tree2, arr[i] - <span class="hljs-number">1</span>);<br>        ans += right_count;<br><br>        fenwick.add(fenwick.tree1, arr[i], <span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> one_count = fenwick.sum(fenwick.tree1, arr[i] - <span class="hljs-number">1</span>);<br>        fenwick.add(fenwick.tree2, arr[i], one_count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(nullptr);<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br>    &#125;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; compute() &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="hh的项链"><a href="#hh的项链" class="headerlink" title="hh的项链"></a>hh的项链</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1000001</span>;<br><br><span class="hljs-type">int</span> arr[MAXN];       <span class="hljs-comment">// 存储原数组</span><br><span class="hljs-type">int</span> query[MAXN][<span class="hljs-number">3</span>];  <span class="hljs-comment">// 存储查询 [l, r, index]</span><br><span class="hljs-type">int</span> ans[MAXN];       <span class="hljs-comment">// 存储每个查询的结果</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">map</span>[MAXN];       <span class="hljs-comment">// 存储每个颜色最后出现的位置</span><br><span class="hljs-type">int</span> tree[MAXN];      <span class="hljs-comment">// 树状数组</span><br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-comment">// 树状数组的 lowbit 函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> i &amp; -i;<br>&#125;<br><br><span class="hljs-comment">// 更新树状数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> v)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i &lt;= n) &#123;<br>        tree[i] += v;<br>        i += lowbit(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查询 1~i 的区间和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>        ans += tree[i];<br>        i -= lowbit(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 计算查询区间的和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">range</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">return</span> sum(r) - sum(l - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 处理所有查询</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 按照查询的右端点排序</span><br>    sort(query + <span class="hljs-number">1</span>, query + m + <span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> a[], <span class="hljs-type">const</span> <span class="hljs-type">int</span> b[]) &#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;);<br><br>    <span class="hljs-comment">// 维护从1到当前右端点的区间</span><br>    <span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q = <span class="hljs-number">1</span>; q &lt;= m; q++) &#123;<br>        <span class="hljs-type">int</span> l = query[q][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> r = query[q][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> i = query[q][<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 更新树状数组，将 [s, r] 范围内的元素加到树状数组中</span><br>        <span class="hljs-keyword">while</span> (s &lt;= r) &#123;<br>            <span class="hljs-type">int</span> color = arr[s];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[color] != <span class="hljs-number">0</span>) &#123;<br>                add(<span class="hljs-built_in">map</span>[color], <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 移除之前出现的颜色的影响</span><br>            &#125;<br>            add(s, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 添加当前值到树状数组</span><br>            <span class="hljs-built_in">map</span>[color] = s;  <span class="hljs-comment">// 更新颜色的最后出现位置</span><br>            s++;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算当前查询区间 [l, r] 的答案</span><br>        ans[i] = range(l, r);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>    <span class="hljs-comment">// 输入数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br>    &#125;<br><br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br><br>    <span class="hljs-comment">// 输入查询</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; query[i][<span class="hljs-number">0</span>] &gt;&gt; query[i][<span class="hljs-number">1</span>];<br>        query[i][<span class="hljs-number">2</span>] = i;  <span class="hljs-comment">// 存储查询的原始位置</span><br>    &#125;<br><br>    compute();<br><br>    <span class="hljs-comment">// 输出所有查询的答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<hr>
<h2 id="十三-线段树"><a href="#十三-线段树" class="headerlink" title="十三.线段树"></a>十三.线段树</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentTree</span> &#123;</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; tr, lz;<br>    <br>    SegmentTree(<span class="hljs-type">int</span> _n) : n(_n), tr(<span class="hljs-number">4</span> * n), lz(<span class="hljs-number">4</span> * n) &#123;&#125; <span class="hljs-comment">// 初始化线段树</span><br>    <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> &#123; <span class="hljs-comment">// 进行区间更新</span><br>        tr[u] += val * (r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (l != r) lz[u] += val;<br>    &#125;<br>    <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span> &#123; <span class="hljs-comment">// 进行懒标记下传</span><br>        <span class="hljs-keyword">if</span> (lz[u]) &#123;<br>            apply(<span class="hljs-number">2</span> * u, l, m, lz[u]);<br>            apply(<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r, lz[u]);<br>            lz[u] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> &#123; <span class="hljs-comment">// 建树</span><br>        <span class="hljs-keyword">if</span> (l == r) tr[u] = a[l];<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>            build(<span class="hljs-number">2</span> * u, l, m, a);<br>            build(<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r, a);<br>            tr[u] = tr[<span class="hljs-number">2</span> * u] + tr[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> ul, <span class="hljs-type">int</span> ur, <span class="hljs-type">int</span> val)</span> &#123; upd(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, ul, ur, val); &#125; <span class="hljs-comment">// 更新区间 [ul, ur]</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ul, <span class="hljs-type">int</span> ur, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) apply(u, l, r, val);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>            push(u, l, m, r);<br>            <span class="hljs-keyword">if</span> (ul &lt;= m) upd(<span class="hljs-number">2</span> * u, l, m, ul, ur, val);<br>            <span class="hljs-keyword">if</span> (ur &gt; m) upd(<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r, ul, ur, val);<br>            tr[u] = tr[<span class="hljs-number">2</span> * u] + tr[<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> &#123; <span class="hljs-keyword">return</span> qry(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, ql, qr); &#125; <span class="hljs-comment">// 查询区间 [ql, qr] 的和</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ql, <span class="hljs-type">int</span> qr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="hljs-keyword">return</span> tr[u];<br>        <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>        push(u, l, m, r);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (ql &lt;= m) res += qry(<span class="hljs-number">2</span> * u, l, m, ql, qr);<br>        <span class="hljs-keyword">if</span> (qr &gt; m) res += qry(<span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, r, ql, qr);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, q;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">a</span><span class="hljs-params">(n)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; a[i];<br>    SegmentTree <span class="hljs-title function_">st</span><span class="hljs-params">(n)</span>;<br>    st.build(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, a);<br>    <br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> op;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 操作 1: 区间更新</span><br>            <span class="hljs-type">int</span> l, r, d;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; d;<br>            st.upd(l, r, d);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 操作 2: 查询区间和</span><br>            <span class="hljs-type">int</span> l, r;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; st.qry(l, r) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<hr>
<h2 id="十四-递归"><a href="#十四-递归" class="headerlink" title="十四.递归"></a>十四.递归</h2><p>汉罗塔问题</p>
<p>只要将主过程想好，也就是</p>
<p>一.12从左到中   二.3从左到右   三.12从中到右    如果是n个数呢，就简化为1——n-1从左到中，n从左到右，1——n-1从中到右就如此简化下去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">f（x）&#123;<br>    <span class="hljs-type">int</span> x;      <span class="hljs-comment">//这里是局部变量，还会再开一次int x。所以就是由每个f各自都有一	f(n-1) 份儿  ，所以这些就是如果说非局部的变量。  你不能说某一次f把它改了之后算别的f的时候诶, 它们需要注意保护跟还原这                                                      </span><br>&#125;                                                                                            <br></code></pre></td></tr></table></figure>

<p>基本框架：</p>
<ul>
<li>设计一个黑盒,即这个函数解决的问题,这些代码在当前进程的操作,调用函数相当于开了一个新进程（树）,数学上就像数列f（x），每一个小块即fx都要做什么</li>
<li>定义递归的边界</li>
<li>保护还原现场</li>
</ul>
<h3 id="三个模版"><a href="#三个模版" class="headerlink" title="三个模版"></a>三个模版</h3><h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><p>给定一个数组 <code>nums</code>，要求生成所有的子集。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == n) &#123; <span class="hljs-comment">// 递归终止条件</span><br>        ans.<span class="hljs-built_in">push_back</span>(chosen);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 递归不选当前元素</span><br>    <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 递归选择当前元素</span><br>    chosen.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 撤销选择，还原现场，这里的chosen属于非局部变量</span><br>    chosen.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">recur</span>(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) cin &gt;&gt; nums[i];<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result = <span class="hljs-built_in">subsets</span>(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; subset : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : subset) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>





<hr>
<h4 id="组合问题："><a href="#组合问题：" class="headerlink" title="组合问题："></a>组合问题：</h4><p>给定整数 <code>n</code> 和 <code>k</code>，从 <code>[1, 2, ..., n]</code> 中选择 <code>k</code> 个数的所有组合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, k;<br>vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">// 剪枝条件</span><br>    <span class="hljs-keyword">if</span> (chosen.<span class="hljs-built_in">size</span>() + (n - i + <span class="hljs-number">1</span>) &lt; k) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (i == n + <span class="hljs-number">1</span>) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(chosen);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不选当前元素</span><br>    <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 选择当前元素</span><br>    chosen.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 撤销选择</span><br>    chosen.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> _n, <span class="hljs-type">int</span> _k) &#123;<br>    n = _n;<br>    k = _k;<br>    ans.<span class="hljs-built_in">clear</span>();<br>    chosen.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">recur</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result = <span class="hljs-built_in">combine</span>(n, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; combination : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : combination) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h4 id="全排列问题："><a href="#全排列问题：" class="headerlink" title="全排列问题："></a><strong>全排列问题</strong>：</h4><p>给定一个不包含重复数字的数组 <code>nums</code>，要求生成所有可能的全排列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos == n) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(a);  <span class="hljs-comment">// 找到一个排列</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!used[i]) &#123; <span class="hljs-comment">// 过滤已使用的元素</span><br>            a.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为使用</span><br>            <span class="hljs-built_in">recur</span>(nums, pos + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 递归下一层</span><br>            used[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 还原状态</span><br>            a.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    used = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>    a.<span class="hljs-built_in">clear</span>();<br>    ans.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">recur</span>(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; nums[i];<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result = <span class="hljs-built_in">permute</span>(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; permutation : result) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : permutation) cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>以上三个问题都是递归实现的“暴力搜索”(或者叫枚举、回溯等)可以总结为以下三种基本形式<br>递归形式<br>指数型	排列型	组合型<br>时间复杂度规模:kn	n!	n!&#x2F;m!(n-m)!<br>子集、大体积背包	全排列、旅行商、N 皇后找顺序的题目	组合选数</p>
<h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><h4 id="反转二叉树："><a href="#反转二叉树：" class="headerlink" title="反转二叉树："></a><strong>反转二叉树</strong>：</h4><p>该问题要求对一个二叉树进行左右子树的交换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 空节点返回</span><br>    TreeNode* temp = root-&gt;left;  <span class="hljs-comment">// 交换左右子树</span><br>    root-&gt;left = root-&gt;right;<br>    root-&gt;right = temp;<br>    <span class="hljs-built_in">invertTree</span>(root-&gt;left);  <span class="hljs-comment">// 递归反转左子树</span><br>    <span class="hljs-built_in">invertTree</span>(root-&gt;right);  <span class="hljs-comment">// 递归反转右子树</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="翻转一棵二叉树"><a href="#翻转一棵二叉树" class="headerlink" title="翻转一棵二叉树"></a>翻转一棵二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义二叉树节点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br><br>    <span class="hljs-comment">// 构造函数：初始化节点</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 翻转二叉树的递归函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 基础条件：节点为空时直接返回</span><br><br>        <span class="hljs-comment">// 交换左右子树</span><br>        TreeNode* temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br><br>        <span class="hljs-comment">// 递归处理左右子树</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> root;  <span class="hljs-comment">// 返回翻转后的根节点</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 辅助函数：先序遍历输出二叉树的节点值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>思路一 (自底向上统计信息，分治思想) 最大深度 &#x3D;max(左子树最大深度，右子树最大深度)+1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 递归计算二叉树的最大深度</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果节点为空，深度为0</span><br>        <span class="hljs-comment">// 递归计算左右子树的深度，并返回较大的深度加1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>思路二(自顶向下维护信息)<br>把“深度”作为一个全局变量–一个跟随结点移动而动态变化的信息递归一层，变量+1，在叶子处更新答案这种写法需要注意保护和还原现场</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() : <span class="hljs-built_in">depth</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">ans</span>(<span class="hljs-number">0</span>) &#123;&#125;  <span class="hljs-comment">// 构造函数初始化</span><br>    <span class="hljs-comment">// 计算二叉树最大深度的主函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">calc</span>(root);  <span class="hljs-comment">// 调用递归函数</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> depth;  <span class="hljs-comment">// 当前递归深度</span><br>    <span class="hljs-type">int</span> ans;    <span class="hljs-comment">// 存储最大深度</span><br><br>    <span class="hljs-comment">// 递归计算深度的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 空节点返回</span><br>        <span class="hljs-comment">// 更新最大深度</span><br>        ans = <span class="hljs-built_in">max</span>(ans, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 深度增加，递归遍历左子树和右子树</span><br>        depth++;<br>        <span class="hljs-built_in">calc</span>(root-&gt;left);<br>        <span class="hljs-built_in">calc</span>(root-&gt;right);<br>        <span class="hljs-comment">// 回溯时减少深度</span><br>        depth--;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="递归实现-pow-x-n-问题："><a href="#递归实现-pow-x-n-问题：" class="headerlink" title="递归实现 pow(x, n) 问题："></a><strong>递归实现 <code>pow(x, n)</code> 问题</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 任何数的 0 次方都等于 1</span><br>    <span class="hljs-keyword">if</span> (n == INT_MIN) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">myPow</span>(x, -(n<span class="hljs-number">+1</span>)) * x);  <span class="hljs-comment">// 处理 n 为最小负数的特殊情况</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-built_in">myPow</span>(x, -n);  <span class="hljs-comment">// 负数次幂</span><br>    <span class="hljs-type">double</span> temp = <span class="hljs-built_in">myPow</span>(x, n / <span class="hljs-number">2</span>);  <span class="hljs-comment">// 递归计算</span><br>    <span class="hljs-type">double</span> ans = temp * temp;  <span class="hljs-comment">// 平方</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ans *= x;  <span class="hljs-comment">// 处理奇数次幂</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(log n)，递归每次将 <code>n</code> 减半。</li>
<li><strong>空间复杂度</strong>：O(log n)，递归调用栈的深度。</li>
</ul>
<hr>
<h4 id="括号生成问题："><a href="#括号生成问题：" class="headerlink" title="括号生成问题："></a><strong>括号生成问题</strong>：</h4><p>给定整数 <code>n</code>，生成所有可能的包含 <code>n</code> 对括号的有效组合。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li>使用递归生成所有括号组合，依次生成 <code>k</code> 对括号与 <code>n-k</code> 对括号的组合，再将它们合并。</li>
<li><strong>递归优化</strong>：通过 <code>unordered_map</code> 缓存中间结果，避免重复计算（记忆化搜索）。</li>
<li>设生成的括号组合可以看作 <code>S = (A)B</code>其中 <code>A</code> 是在 <code>k-1</code> 对括号的基础上生成的组合，<code>B</code> 是在 <code>n-k</code> 对括号的基础上生成的组合。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;  <span class="hljs-comment">// 基本情况，n=0时返回空字符串</span><br>    <span class="hljs-keyword">if</span> (store.<span class="hljs-built_in">find</span>(n) != store.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> store[n];  <span class="hljs-comment">// 如果已经计算过，直接返回缓存的结果</span><br>    <br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;  <span class="hljs-comment">// 遍历所有可能的 k 值(A)B</span><br>        vector&lt;string&gt; A = <span class="hljs-built_in">generateParenthesis</span>(k - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 生成 k-1 对括号</span><br>        vector&lt;string&gt; B = <span class="hljs-built_in">generateParenthesis</span>(n - k);  <span class="hljs-comment">// 生成 n-k 对括号</span><br>        <span class="hljs-keyword">for</span> (string&amp; a : A) &#123;<br>            <span class="hljs-keyword">for</span> (string&amp; b : B) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;(&quot;</span> + a + <span class="hljs-string">&quot;)&quot;</span> + b);  <span class="hljs-comment">// 将两部分组合</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    store[n] = ans;  <span class="hljs-comment">// 缓存当前 n 对括号的所有组合</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;string&gt;&gt; store;  <span class="hljs-comment">// 用于记忆化搜索，避免重复计算</span><br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>记忆化搜索</strong>：通过 <code>unordered_map</code> 缓存递归中间结果，避免重复计算，提升效率。</li>
<li><strong>时间复杂度</strong>：理论上为 O(4^n &#x2F; sqrt(n))，因为每次递归生成所有可能的括号组合。</li>
</ul>
<hr>
<h2 id="十五-二叉树"><a href="#十五-二叉树" class="headerlink" title="十五.二叉树"></a>十五.二叉树</h2><p>二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。</p>
<p><strong>遍历方式</strong>：</p>
<ul>
<li><strong>前序遍历</strong>（Pre-order Traversal）：按根节点 -&gt; 左子树 -&gt; 右子树的顺序遍历。</li>
<li><strong>中序遍历</strong>（In-order Traversal）：按左子树 -&gt; 根节点 -&gt; 右子树的顺序遍历。</li>
<li><strong>后序遍历</strong>（Post-order Traversal）：按左子树 -&gt; 右子树 -&gt; 根节点的顺序遍历。</li>
<li><strong>层次遍历</strong>（Level-order Traversal）：按层从上到下、从左到右的顺序遍历树节点。</li>
</ul>
<h4 id="遍历方式总结："><a href="#遍历方式总结：" class="headerlink" title="遍历方式总结："></a><strong>遍历方式总结</strong>：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 二叉树节点定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 前序遍历 (根-左-右)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preorder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 中序遍历 (左-根-右)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 后序遍历 (左-右-根)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postorder</span>(root-&gt;right);<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 层序遍历 (广度优先遍历)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>&#125;<br>              a<br>            /  \<br>           b      c<br>         / \    / \<br>        d   e   f   g<br>                 <br>递归序：  a b d d d b e e e b a c f f f c g g g c a   这是计算机解决的流程即左右和本身               <br>前中后序就是挑哪个是：第一二三次出现排序            <br>规律：先序:abdec | fg <br>        后序:debf | gca     任意选一个字母例如f，先序前和后序后的交集ca就是它全部的祖先<br></code></pre></td></tr></table></figure>

<h3 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h3><p>树形dp——从左树底端开始左右孩子都要info信息然后整合成一个信息成为孩子给父信息</p>
<p>step1.想以x为头（答案）怎么实现，不是x头又怎么实现，把这些实现需要的状态空间info列出求全集</p>
<p>step2.这些信息初始化在 Info process ，将这些信息在Info process这个函数里实现，如果这个信息涉及之前的分类讨论，就分多条件讨论</p>
<h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><h4 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断是否为完全二叉树，第一，此题不用区分是不是头，判断需要看左右孩子是否是平衡二叉树，做到这里需要知道左右孩子的高度，所以info信息里需要知道是不是平衡二叉树和高度是几就行。然后就是如何判断是否为二叉树的算法，如何得到高度的算法Info process写在这个函数里,要么穷举出所有可能，要么写算法判断</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span>   <span class="hljs-comment">//每个节点需要的信息收集</span><br>    <span class="hljs-type">bool</span> isCBT;<br>    <span class="hljs-type">int</span> height;<br>    Info(<span class="hljs-type">bool</span> cbt, <span class="hljs-type">int</span> h) : isCBT(cbt), height(h) &#123;&#125;<br>&#125;;<br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* X)</span> &#123;   <span class="hljs-comment">//判断逻辑返回信息</span><br>    <span class="hljs-keyword">if</span> (!X) <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);<br>    Info leftInfo = process(X-&gt;left);<br>    Info rightInfo = process(X-&gt;right);<br>    <span class="hljs-type">int</span> height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> isCBT = leftInfo.isCBT &amp;&amp; rightInfo.isCBT &amp;&amp;<br>                 (leftInfo.height == rightInfo.height || leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> Info(isCBT, height);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isCBT</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process(head).isCBT : <span class="hljs-literal">true</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="是否是二叉搜索树"><a href="#是否是二叉搜索树" class="headerlink" title="是否是二叉搜索树"></a>是否是二叉搜索树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//是否是二叉搜索树</span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 定义宏将 int 替换为 long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MIN LLONG_MIN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MAX LLONG_MAX</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">bool</span> isBST;<br>    INT max;  <span class="hljs-comment">// 使用 long long 类型</span><br>    INT min;  <span class="hljs-comment">// 使用 long long 类型</span><br>    Info(<span class="hljs-type">bool</span> i, INT ma, INT mi) : isBST(i), max(ma), min(mi) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">true</span>, INT_MIN, INT_MAX);  <span class="hljs-comment">// 空节点是合法的 BST</span><br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br>    <br>    INT max = x-&gt;value;  <span class="hljs-comment">// 使用 long long 类型</span><br>    <span class="hljs-keyword">if</span> (leftInfo.isBST) max = max(max, leftInfo.max);<br>    <span class="hljs-keyword">if</span> (rightInfo.isBST) max = max(max, rightInfo.max);<br><br>    INT min = x-&gt;value;  <span class="hljs-comment">// 使用 long long 类型</span><br>    <span class="hljs-keyword">if</span> (leftInfo.isBST) min = min(min, leftInfo.min);<br>    <span class="hljs-keyword">if</span> (rightInfo.isBST) min = min(min, rightInfo.min);<br><br>    <span class="hljs-type">bool</span> isBST = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!leftInfo.isBST || !rightInfo.isBST) isBST = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (leftInfo.isBST &amp;&amp; leftInfo.max &gt;= x-&gt;value) isBST = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (rightInfo.isBST &amp;&amp; rightInfo.min &lt;= x-&gt;value) isBST = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> Info(isBST, maxVal, minVal);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isBST</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process(head).isBST : <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 处理空树的情况</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="判断是否为平衡二叉树"><a href="#判断是否为平衡二叉树" class="headerlink" title="判断是否为平衡二叉树"></a>判断是否为平衡二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">bool</span> isBalanced;<br>    INT height;<br>    Info(<span class="hljs-type">bool</span> i, INT h) : isBalanced(i), height(h) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 空节点是平衡的，高度为 0</span><br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br>    <span class="hljs-comment">// 计算当前节点的高度</span><br>    INT height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;  <br>   <br>    <span class="hljs-type">bool</span> isBalanced = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!leftInfo.isBalanced || !rightInfo.isBalanced) &#123;<br>        isBalanced = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果左子树或右子树不平衡，当前节点也不平衡</span><br>    &#125;   <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftInfo.height - rightInfo.height) &gt; <span class="hljs-number">1</span>) &#123;<br>        isBalanced = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果左右子树高度差大于 1，当前节点不平衡</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> Info(isBalanced, height);  <span class="hljs-comment">// 返回当前节点是否平衡和它的高度</span><br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process(head).isBalanced : <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 处理空树的情况</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="判断是否为满二叉树"><a href="#判断是否为满二叉树" class="headerlink" title="判断是否为满二叉树"></a>判断是否为满二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 左树满 &amp;&amp; 右树满 &amp;&amp; 左右树高度一样 -&gt; 整棵树是满的</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 定义宏将 int 替换为 long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MIN LLONG_MIN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MAX LLONG_MAX</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info2</span> &#123;</span><br>    <span class="hljs-type">bool</span> isFull;<br>    INT height;<br>    Info2(<span class="hljs-type">bool</span> f, INT h) : isFull(f), height(h) &#123;&#125;<br>&#125;;<br><br>Info2 <span class="hljs-title function_">process2</span><span class="hljs-params">(Node* h)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!h) <span class="hljs-keyword">return</span> Info2(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 空节点是满的，高度为 0</span><br>    Info2 leftInfo = process2(h-&gt;left);<br>    Info2 rightInfo = process2(h-&gt;right);<br>    <br>    <span class="hljs-type">bool</span> isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;<br>    INT height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点的高度</span><br>    <span class="hljs-keyword">return</span> Info2(isFull, height);  <span class="hljs-comment">// 返回当前节点是否满和它的高度</span><br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process2(head).isFull : <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 处理空树的情况，空树为满树</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="找最大二叉搜索子树"><a href="#找最大二叉搜索子树" class="headerlink" title="找最大二叉搜索子树"></a>找最大二叉搜索子树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//最大二叉搜索子树，当x不做头时要统计左右孩子最大二叉搜索子树的大小，当x做头时，左右是不是搜索二叉树，左右maxmin，左右树大小size，</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-type">int</span> x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">int</span> maxBSTSubtreeSize; <br>    <span class="hljs-type">int</span> allSize;  <span class="hljs-comment">//原本应该有isBST但是当allSize==maxBSTSubtreeSize，isBST就是true所以省略</span><br>    <span class="hljs-type">int</span> max;<br>    <span class="hljs-type">int</span> min;<br>    Info(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> ma, <span class="hljs-type">int</span> mi) : maxBSTSubtreeSize(m), allSize(a), max(ma), min(mi) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(TreeNode* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) &#123;<br>        <span class="hljs-keyword">return</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, INT_MIN, INT_MAX);  <span class="hljs-comment">// 空节点，大小为0，最大值最小值分别为 INT_MIN 和 INT_MAX</span><br>    &#125;<br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br><br>    <span class="hljs-comment">//初始值设置</span><br>    <span class="hljs-type">int</span> max = x-&gt;val;<br>    <span class="hljs-type">int</span> min = x-&gt;val;  <br>    <span class="hljs-type">int</span> allSize = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点算一个</span><br>    <span class="hljs-keyword">if</span> (leftInfo != null) &#123;<br>        maxVal = max(max, leftInfo.max);<br>        minVal = min(min, leftInfo.min);<br>        allSize += leftInfo.allSize;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rightInfo != null) &#123;<br>        max = max(max, rightInfo.max);<br>        min = min(min, rightInfo.min);<br>        allSize += rightInfo.allSize;<br>    &#125;<br>	<span class="hljs-comment">//p123是三种可能性，取出最大可能</span><br>    <span class="hljs-type">int</span> <span class="hljs-type">int</span> p1 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (leftInfo != null) p1 = leftInfo.maxBSTSubtreeSize;<br>    <span class="hljs-type">int</span> p2 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (rightInfo != null) p2 = rightInfo.maxBSTSubtreeSize;<br>    <span class="hljs-type">int</span> p3 = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//接下来是一堆coding问题</span><br>    <span class="hljs-type">bool</span> leftBST = leftInfo == null ? <span class="hljs-literal">true</span> : (leftInfo.maxBSTSubtreeSize == leftInfo.allSize);<br>    <span class="hljs-type">bool</span> rightBST = rightInfo == null ? <span class="hljs-literal">true</span> : (rightInfo.maxBSTSubtreeSize == rightInfo.allSize);<br>    <span class="hljs-keyword">if</span> (leftBST &amp;&amp; rightBST) &#123;<br>        <span class="hljs-type">bool</span> leftMaxLessX = leftInfo == null ? <span class="hljs-literal">true</span> : (leftInfo.max &lt; x.val); <span class="hljs-comment">//左数小于x</span><br>        <span class="hljs-type">bool</span> rightMinMoreX = rightInfo == null ? <span class="hljs-literal">true</span> : (x.val &lt; rightInfo.min);<br>        <span class="hljs-keyword">if</span> (leftMaxLessX &amp;&amp; rightMinMoreX) &#123;<br>            <span class="hljs-type">int</span> leftSize = leftInfo == null ? <span class="hljs-number">0</span> : leftInfo.allSize;<br>            <span class="hljs-type">int</span> rightSize = rightInfo == null ? <span class="hljs-number">0</span> : rightInfo.allSize;<br>            p3 = leftSize + rightSize + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点也是BST子树的一部分</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Info(max(p1, max(p2, p3)), allSize, max, min);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">largestBSTSubtree</span><span class="hljs-params">(TreeNode* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> process(head).maxBSTSubtreeSize;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//最近公共祖先</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 定义树节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-type">int</span> x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 用于存储返回信息的结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">bool</span> findA;<br>    <span class="hljs-type">bool</span> findB;<br>    TreeNode* ans;<br><br>    Info(<span class="hljs-type">bool</span> fA, <span class="hljs-type">bool</span> fB, TreeNode* an) : findA(fA), findB(fB), ans(an) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 处理树节点的递归函数</span><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(TreeNode* x, TreeNode* a, TreeNode* b)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x == nullptr) &#123;<br>        <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, nullptr);<br>    &#125;<br><br>    <span class="hljs-comment">// 递归处理左右子树</span><br>    Info leftInfo = process(x-&gt;left, a, b);<br>    Info rightInfo = process(x-&gt;right, a, b);<br><br>    <span class="hljs-comment">// 当前节点是否是a或b</span><br>    <span class="hljs-type">bool</span> findA = (x == a) || leftInfo.findA || rightInfo.findA;<br>    <span class="hljs-type">bool</span> findB = (x == b) || leftInfo.findB || rightInfo.findB;<br><br>    TreeNode* ans = nullptr;<br><br>    <span class="hljs-comment">// 如果左子树或右子树已经找到了结果，则返回相应的结果</span><br>    <span class="hljs-keyword">if</span> (leftInfo.ans != nullptr) &#123;<br>        ans = leftInfo.ans;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightInfo.ans != nullptr) &#123;<br>        ans = rightInfo.ans;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果当前节点是a和b的共同祖先，则返回当前节点</span><br>        <span class="hljs-keyword">if</span> (findA &amp;&amp; findB) &#123;<br>            ans = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Info(findA, findB, ans);<br>&#125;<br><br><span class="hljs-comment">// 获取最低公共祖先</span><br>TreeNode* <span class="hljs-title function_">lowestAncestor</span><span class="hljs-params">(TreeNode* head, TreeNode* a, TreeNode* b)</span> &#123;<br>    <span class="hljs-keyword">return</span> process(head, a, b).ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="根据前序遍历和中序遍历重建二叉树："><a href="#根据前序遍历和中序遍历重建二叉树：" class="headerlink" title="根据前序遍历和中序遍历重建二叉树："></a>根据前序遍历和中序遍历重建二叉树：</h4><p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; preorder;<br>    vector&lt;<span class="hljs-type">int</span>&gt; inorder;<br><br>    <span class="hljs-comment">// 主函数：传入前序和中序遍历数组，开始构建二叉树</span><br>    TreeNode* buildTree(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder) &#123;<br>        <span class="hljs-built_in">this</span>-&gt;preorder = preorder;<br>        <span class="hljs-built_in">this</span>-&gt;inorder = inorder;<br>        <span class="hljs-keyword">return</span> build(<span class="hljs-number">0</span>, preorder.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 递归构建二叉树</span><br>    TreeNode* build(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2) &#123;<br>        <span class="hljs-keyword">if</span> (l1 &gt; r1) <span class="hljs-keyword">return</span> nullptr; <span class="hljs-comment">// 递归结束条件</span><br><br>        <span class="hljs-comment">// 构建当前子树的根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[l1]);<br><br>        <span class="hljs-comment">// 在中序遍历中找到根节点的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l2;<br>        <span class="hljs-keyword">while</span> (inorder[mid] != root-&gt;val) ++mid;<br><br>        <span class="hljs-comment">// 计算左子树的长度，并递归构建左右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftTreeSize</span> <span class="hljs-operator">=</span> mid - l2;<br>        root-&gt;left = build(l1 + <span class="hljs-number">1</span>, l1 + leftTreeSize, l2, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = build(l1 + leftTreeSize + <span class="hljs-number">1</span>, r1, mid + <span class="hljs-number">1</span>, r2);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//找到二叉树中最大距离</span><br><span class="hljs-comment">//x作为头节点时，要左右最大高度，x不作为头节点时，要左和右统计出来的最大距离，总结要高度和最大距离，最大距离的计算：x左右的最大距离，x高度得出来的距离取max</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">int</span> maxDistance;<br>    <span class="hljs-type">int</span> height;<br>    Info(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> h) : maxDistance(m), height(h) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) &#123;<br>        <span class="hljs-keyword">return</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果是空节点，最大距离为0，高度为0</span><br>    &#125;<br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br>    <br>    <span class="hljs-type">int</span> height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 计算三种情况的最大值</span><br>    <span class="hljs-type">int</span> p1 = leftInfo.maxDistance;<br>    <span class="hljs-type">int</span> p2 = rightInfo.maxDistance;<br>    <span class="hljs-type">int</span> p3 = leftInfo.height + rightInfo.height + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点的最大距离为左子树高度 + 右子树高度 + 1</span><br><br>    <span class="hljs-type">int</span> maxDistance = max(&#123;p1, p2, p3&#125;);<br>    <span class="hljs-keyword">return</span> Info(maxDistance, height);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxDistance</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> process(head).maxDistance;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>- </p>
<ul>
<li><strong>分析</strong>：<ul>
<li>前序遍历的第一个元素是当前子树的根节点。</li>
<li>在中序遍历中找到根节点，划分出左子树和右子树。</li>
<li>递归地对左右子树进行同样的处理。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h4 id="找到两个节点的最近公共祖先："><a href="#找到两个节点的最近公共祖先：" class="headerlink" title="找到两个节点的最近公共祖先："></a><strong>找到两个节点的最近公共祖先</strong>：</h4><p><strong>问题描述</strong>：                                                                                                                                                           </p>
<p> 先求出父结点，然后用向上标记法<br>p 向上一直到 root 标红色<br>q向上，第一次遇到红色时，就找到了LCA</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;iostream&gt;<br>using namespace std;<br><br><span class="hljs-comment">// 树的节点结构</span><br>struct TreeNode &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-type">int</span> x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* p = nullptr;<br>    TreeNode* q = nullptr;<br>    TreeNode* ans = nullptr;<br><br>    <span class="hljs-comment">// 寻找二叉树中两个节点的最近公共祖先</span><br>    TreeNode* Ansestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-built_in">this</span>-&gt;p = p;<br>        <span class="hljs-built_in">this</span>-&gt;q = q;<br>        ans = nullptr;  <span class="hljs-comment">// 确保 ans 在每次调用时都为 nullptr</span><br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 深度优先搜索辅助函数，返回包含 p 和 q 的标记</span><br>    pair&lt;bool, bool&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;<br><br>        <span class="hljs-comment">// 递归查找左子树和右子树</span><br>        pair&lt;bool, bool&gt; leftResult = dfs(root-&gt;left);<br>        pair&lt;bool, bool&gt; rightResult = dfs(root-&gt;right);<br><br>        <span class="hljs-comment">// 当前节点是否包含 p 或 q 的状态</span><br>        pair&lt;bool, bool&gt; result;<br>        result.first = leftResult.first || rightResult.first || root == p;<br>        result.second = leftResult.second || rightResult.second || root == q;<br><br>        <span class="hljs-comment">// 若当前节点同时包含 p 和 q 且 ans 尚未被设置，则将当前节点设置为答案</span><br>        <span class="hljs-keyword">if</span> (result.first &amp;&amp; result.second &amp;&amp; ans == nullptr) &#123;<br>            ans = root;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="十六-图"><a href="#十六-图" class="headerlink" title="十六.图"></a>十六.图</h2><h3 id="图的写法"><a href="#图的写法" class="headerlink" title="图的写法"></a>图的写法</h3><p>其他形式的图全抽象为————出边数组实现</p>
<p>无向图版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// edges = &#123;&#123;0, 1&#125;,&#123;1, 2&#125;,&#123;2, 3&#125;,&#123;0, 2&#125;,&#123;3, 4&#125;&#125;;</span><br><span class="hljs-comment">//to = &#123; &#123;1, 2&#125;, &#123;0, 2&#125;, &#123;1, 3, 0&#125;, &#123;2, 4&#125;, &#123;3&#125; &#125;;</span><br>          <span class="hljs-number">0</span>         <span class="hljs-number">1</span>         <span class="hljs-number">2</span>        <span class="hljs-number">3</span>     <span class="hljs-number">4</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge:edges)&#123; <span class="hljs-comment">//找到最大编号</span><br>    <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>    n = <span class="hljs-built_in">max</span>(n,<span class="hljs-built_in">max</span>(x,y));<br>&#125;<br>n++;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(n);  <span class="hljs-comment">// 每个节点对应一个空的 vector&lt;int&gt;</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge:edges)&#123;<br>    <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>    to[x].<span class="hljs-built_in">push_back</span>(y);  <br>    to[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有向图带路径版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0</span>: (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)      matrix<br><span class="hljs-number">1</span>: (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <br><span class="hljs-number">2</span>: (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <br><span class="hljs-number">3</span>: <br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; convertToAdjacencyListWithWeights(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : matrix) &#123;<br>        <span class="hljs-type">int</span> from = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 起始节点</span><br>        <span class="hljs-type">int</span> to = edge[<span class="hljs-number">2</span>];    <span class="hljs-comment">// 目标节点</span><br>        n = max(n, max(from, to));  <span class="hljs-comment">// 找到最大的节点编号</span><br>    &#125;<br>    n++; <span class="hljs-comment">// 因为节点编号是从 0 开始的，所以图的大小应该是最大编号 + 1</span><br>    <br>    <span class="hljs-comment">// 第二步：初始化邻接表，用 pair 存储目标节点和边的权重</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; adjList(n);<br>    <br>    <span class="hljs-comment">// 第三步：根据输入的矩阵填充邻接表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : matrix) &#123;<br>        <span class="hljs-type">int</span> weight = edge[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 边的权重</span><br>        <span class="hljs-type">int</span> from = edge[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 起始节点</span><br>        <span class="hljs-type">int</span> to = edge[<span class="hljs-number">2</span>];      <span class="hljs-comment">// 目标节点</span><br>        adjList[from].push_back(&#123;to, weight&#125;);  <span class="hljs-comment">// 将边加入邻接表</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> adjList;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p><strong>DFS</strong>：判断</p>
<p>DFS 是一种图或树的遍历算法，它沿着一条路径尽可能深入，然后回溯，继续探索其他路径。</p>
<p>DFS 的实现方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//记得初始化</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to; <span class="hljs-comment">//构建出边数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n,<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    visited[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>        <span class="hljs-keyword">if</span>(y == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!visited[y]) &#123;<br>            <span class="hljs-built_in">dfs</span>(y,x);  <span class="hljs-comment">// 递归访问未访问的邻居</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            hasClcye = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>BFS</strong>：</p>
<p>BFS 的实现方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);  <span class="hljs-comment">// 将起点加入队列</span><br>    depth[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 标记起点已访问</span><br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 从队列中取出一个节点</span><br><br>        <span class="hljs-comment">// 访问该节点的所有邻居</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>            <span class="hljs-keyword">if</span>(depth[y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            depth[y] = depth[x] + <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>BFS 有向图————拓扑排序 </p>
<p>来验证是否能正确排序版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(n);  <span class="hljs-comment">// 这里是已经构建好的to</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDeg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// 创建并初始化 inDeg</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123; <br>    <span class="hljs-type">int</span> from = edge[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> toNode = edge[<span class="hljs-number">0</span>];<br>    to[from].<span class="hljs-built_in">push_back</span>(toNode);<br>    inDeg[toNode]++;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; sortOrder;  <span class="hljs-comment">// 修改为正确的变量名</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();  <br>    sortOrder.<span class="hljs-built_in">push_back</span>(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>        inDeg[y]--;<br>        <span class="hljs-keyword">if</span> (inDeg[y] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> sortOrder.<span class="hljs-built_in">size</span>() == n;<br><span class="hljs-comment">// 输出最终的排序结果</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : sortOrder) &#123;<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>cout &lt;&lt; endl;  <span class="hljs-comment">// 换行，输出结束</span><br><br></code></pre></td></tr></table></figure>

<p>输出所有拓扑排序版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">// 回溯生成所有拓扑排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">allTopologicalSorts</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; inDeg, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; sortOrder)</span> &#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 用来检查是否有入度为 0 的节点</span><br><br>    <span class="hljs-comment">// 遍历所有节点，查找入度为 0 且未访问的节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span> &amp;&amp; !visited[i]) &#123;<br>            <span class="hljs-comment">// 标记该节点已访问</span><br>            visited[i] = <span class="hljs-literal">true</span>;<br>            sortOrder.push_back(i);  <span class="hljs-comment">// 将该节点加入拓扑排序</span><br>            <span class="hljs-comment">// 将该节点的邻接节点的入度减 1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[i]) &#123;<br>                inDeg[y]--;<br>            &#125;<br>            <span class="hljs-comment">// 递归调用生成后续的拓扑排序</span><br>            allTopologicalSorts(n, to, inDeg, visited, sortOrder);<br>            <span class="hljs-comment">// 回溯过程：恢复状态</span><br>            visited[i] = <span class="hljs-literal">false</span>;<br>            sortOrder.pop_back();  <span class="hljs-comment">// 移除当前节点</span><br>            <span class="hljs-comment">// 恢复该节点邻接节点的入度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[i]) &#123;<br>                inDeg[y]++;<br>            &#125;<br>            flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记已经处理了一个入度为 0 的节点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有更多节点可以选择，说明已经生成了一个完整的拓扑排序</span><br>    <span class="hljs-keyword">if</span> (!flag) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : sortOrder) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前的拓扑排序</span><br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 主函数：执行拓扑排序</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">generateAllTopologicalSorts</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; to(n);  <br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">inDeg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>;    <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title function_">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span>;  <span class="hljs-comment">// 访问标记数组</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; sortOrder;      <span class="hljs-comment">// 存储当前拓扑排序</span><br>    <span class="hljs-comment">// 构建图的邻接表和入度数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>        <span class="hljs-type">int</span> from = edge[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 边的起点</span><br>        <span class="hljs-type">int</span> toNode = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 边的终点</span><br>        to[from].push_back(toNode);  <span class="hljs-comment">// 添加边到邻接表</span><br>        inDeg[toNode]++;  <span class="hljs-comment">// 终点的入度加1</span><br>    &#125;<br>    <span class="hljs-comment">// 调用回溯函数生成所有拓扑排序</span><br>    allTopologicalSorts(n, to, inDeg, visited, sortOrder);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 返回成功</span><br>&#125;<br><span class="hljs-type">signed</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;  <span class="hljs-comment">// 节点数</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; edges = &#123;<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;  <span class="hljs-comment">// 边列表</span><br>    &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;All Topological Sorts: &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    generateAllTopologicalSorts(n, edges);  <span class="hljs-comment">// 生成并输出所有拓扑排序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="Kruskal-算法：生成最小生成树"><a href="#Kruskal-算法：生成最小生成树" class="headerlink" title="Kruskal 算法：生成最小生成树"></a>Kruskal 算法：生成最小生成树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> p[N];  <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-comment">// 存储图的边 &#123;权重, &#123;节点a, 节点b&#125;&#125;</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; edges;<br><br><span class="hljs-comment">// 并查集的核心操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> p[x] == x ? x : (p[x] = find(p[x]));<br>&#125;<br><br><span class="hljs-comment">// Kruskal 算法：生成最小生成树</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;  <span class="hljs-comment">// 初始化并查集</span><br><br>    sort(edges.begin(), edges.end());  <span class="hljs-comment">// 按权重排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>        <span class="hljs-type">int</span> w = edge.first, a = edge.second.first, b = edge.second.second;<br>        a = find(a), b = find(b);<br><br>        <span class="hljs-keyword">if</span> (a != b) &#123;  <span class="hljs-comment">// 如果不在同一连通块</span><br>            p[a] = b;  <span class="hljs-comment">// 合并</span><br>            res += w;<br>            <span class="hljs-keyword">if</span> (++cnt == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 已经形成最小生成树</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt == n - <span class="hljs-number">1</span> ? res : <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果不连通，返回 -1</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 输入边</span><br>    edges.resize(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        edges[i] = &#123;w, &#123;a, b&#125;&#125;;<br>    &#125;<br><br>    <span class="hljs-type">int</span> result = kruskal(n, m);<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无法生成最小生成树&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最小生成树的权重是: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>单起点多终点正权最短路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long  <span class="hljs-comment">// 定义为 long long 方便处理大数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;  <span class="hljs-comment">// 预设最大节点数</span><br><span class="hljs-type">int</span> n, m;                <span class="hljs-comment">// 节点数和边数</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; to;  <span class="hljs-comment">// 用邻接表存储图（出边数组）</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; dist;        <span class="hljs-comment">// 存储最短路径</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; st;         <span class="hljs-comment">// 存储每个点是否已经确定最短路径</span><br><br><span class="hljs-comment">// 图的构建函数：添加一条边</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> weight)</span> &#123;<br>    to[a].push_back(b); <span class="hljs-comment">// 有向图只添加 a -&gt; b</span><br>&#125;<br><br><span class="hljs-comment">// Dijkstra 算法：求 1 号点到 n 号点的最短路径</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">()</span> &#123;<br>    dist.assign(n, LLONG_MAX);  <span class="hljs-comment">// 初始化 dist 数组为无穷大</span><br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点 0 的距离为 0</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  <span class="hljs-comment">// 最小堆</span><br>    heap.push(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);  <span class="hljs-comment">// 起点加入堆，&#123;距离, 节点&#125;</span><br><br>    <span class="hljs-keyword">while</span> (!heap.empty()) &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.top();<br>        heap.pop();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果已经访问过，则跳过</span><br>        st[ver] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点已访问</span><br><br>        <span class="hljs-comment">// 遍历当前节点的所有邻接点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : to[ver]) &#123;  <span class="hljs-comment">// 直接遍历出边数组</span><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 假设所有边权为 1</span><br>                dist[j] = distance + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 更新最短距离</span><br>                heap.push(&#123;dist[j], j&#125;);  <span class="hljs-comment">// 将更新后的邻接点加入堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回从 0 号点到 n-1 号点的最短距离</span><br>    <span class="hljs-keyword">if</span> (dist[n<span class="hljs-number">-1</span>] == LLONG_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果无法到达，返回 -1</span><br>    <span class="hljs-keyword">return</span> dist[n<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    to.resize(n);  <span class="hljs-comment">// 初始化邻接表</span><br><br>    <span class="hljs-comment">// 输入边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, weight;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; weight;<br>        add_edge(a, b, weight);  <span class="hljs-comment">// 添加边 a -&gt; b</span><br>    &#125;<br><br>    <span class="hljs-comment">// 执行 Dijkstra 算法</span><br>    <span class="hljs-type">int</span> result = dijkstra();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>单起点多终点负权最短路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>     // 边，<span class="hljs-title">a</span>表示出点，<span class="hljs-title">b</span>表示入点，<span class="hljs-title">w</span>表示边的权重</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bellman_ford</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="spfa-算法"><a href="#spfa-算法" class="headerlink" title="spfa 算法"></a>spfa 算法</h3><p>队列优化的Bellman-Ford算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">spfa</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.push(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.size())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.front();<br>        q.pop();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>spfa判断图中是否存在负环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">spfa</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.push(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.size())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.front();<br>        q.pop();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>多起点多终点最短路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">初始化：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>匈牙利算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-type">int</span> match[N];       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || find(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++ )<br>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-keyword">if</span> (find(i)) res ++ ;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>最小瓶颈路</p>
<h3 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h3><h4 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h4><p>edges &#x3D; [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5]]</p>
<p>算法实现</p>
<ol>
<li><strong>出边数组的构建</strong>：使用邻接表（出边数组）表示树的结构，方便遍历。</li>
<li>两次 BFS<ul>
<li>第一次 BFS 从任意节点出发（这里从节点 <code>0</code> 出发），找到距离最远的节点 <code>p</code>。</li>
<li>第二次 BFS 从 <code>p</code> 出发，找到距离最远的另一个节点，并返回此距离作为树的直径。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to; <span class="hljs-comment">// 出边数组</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeDiameter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>            n = <span class="hljs-built_in">max</span>(n, <span class="hljs-built_in">max</span>(x, y)); <span class="hljs-comment">// 计算最大节点编号</span><br>        &#125;<br>        n++; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++)	to.<span class="hljs-built_in">push_back</span>(&#123;&#125;); <span class="hljs-comment">//初始化</span><br>        <span class="hljs-comment">// 构建出边数组</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>            to[x].<span class="hljs-built_in">push_back</span>(y);<br>            to[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br><br>        <span class="hljs-comment">// 从任意节点 0 开始，找到最远的节点</span><br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">findFarthest</span>(<span class="hljs-number">0</span>).first;<br>        <span class="hljs-comment">// 从找到的最远节点 p 再次执行 BFS，求出树的直径</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFarthest</span>(p).second;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// &lt;点，距离&gt;</span><br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">findFarthest</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 记录每个节点的深度，初始为 -1</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        depth[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起始节点的深度为 0</span><br>        <span class="hljs-comment">// BFS</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                <span class="hljs-keyword">if</span> (depth[y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过已访问节点</span><br>                depth[y] = depth[x] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新深度</span><br>                q.<span class="hljs-built_in">push</span>(y); <span class="hljs-comment">// 将该节点加入队列</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到距离最远的节点</span><br>        <span class="hljs-type">int</span> ans = start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (depth[i] &gt; depth[ans]) ans = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;ans, depth[ans]&#125;;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><p>输入: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]<br>输出: false<br>解释: 课程 1 依赖于课程 0，课程 0 也依赖于课程 1，形成循环，无法完成所有课程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化邻接表和入度表</span><br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        inDeg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 构建图</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre : prerequisites) &#123;<br>            <span class="hljs-type">int</span> ai = pre[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> bi = pre[<span class="hljs-number">1</span>];<br>            to[bi].<span class="hljs-built_in">push_back</span>(ai);<br>            inDeg[ai]++;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>       <span class="hljs-comment">//拓扑排序第一步:从零入度点出发</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; lessons;  <span class="hljs-comment">// 保存完成的课程</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            lessons.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-comment">// 第二步:扩展一个点，周围的点入度减一</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                inDeg[y]--;<br>                <span class="hljs-keyword">if</span> (inDeg[y] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);  <span class="hljs-comment">// 第三步:入度减为0，表示可以入队了</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果所有课程都能完成，返回true</span><br>        <span class="hljs-keyword">return</span> lessons.<span class="hljs-built_in">size</span>() == numCourses;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;   <span class="hljs-comment">// 邻接表</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; inDeg;        <span class="hljs-comment">// 入度表</span><br>&#125;;<br><span class="hljs-comment">//这个bfs就不用判重了。因为你有了indeg这个东西啊减为零才会入队。如果说有环，是不是根本就减不到零,他们就不会去访问啊，不会有重复，所以说这里我就不用判重</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设输入：</span><br><span class="hljs-comment">numCourses = 2</span><br><span class="hljs-comment">prerequisites = [[1, 0]]</span><br><span class="hljs-comment">这表示有 2 门课程，编号为 0 和 1。要完成课程 1，你必须先完成课程 0。</span><br><span class="hljs-comment">步骤 1：构建图和入度表</span><br><span class="hljs-comment">邻接表 to：这是一个二维向量，其中 to[bi] 保存了所有依赖于 bi 的课程，即 bi 的后续课程。在该例中：</span><br><span class="hljs-comment">to[0] 保存了课程 1，因为课程 1 依赖于课程 0。因此，to[0] = [1]，表示从课程 0 可以走到课程 1。</span><br><span class="hljs-comment">to[1] 没有后续课程，因此 to[1] 为空。</span><br><span class="hljs-comment">入度表 inDeg：这是一个一维向量，用来存储每个课程的入度，即需要先修多少门课程。在该例中：</span><br><span class="hljs-comment">课程 0 没有任何依赖，所以 inDeg[0] = 0。</span><br><span class="hljs-comment">课程 1 需要先修课程 0，所以 inDeg[1] = 1。</span><br><span class="hljs-comment">此时，邻接表和入度表如下：</span><br><span class="hljs-comment">to = [[1], []]</span><br><span class="hljs-comment">inDeg = [0, 1]</span><br><span class="hljs-comment">步骤 2：拓扑排序准备</span><br><span class="hljs-comment">我们需要找到所有入度为 0 的课程，也就是不需要先修课程就可以直接学习的课程。在该例中，课程 0 的入度为 0，因此我们将课程 0 加入队列 q。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = [0]</span><br><span class="hljs-comment">步骤 3：广度优先搜索（BFS）拓扑排序</span><br><span class="hljs-comment">处理课程 0：</span><br><span class="hljs-comment">从队列中取出课程 0 并将其标记为已完成（加入 lessons 列表）。</span><br><span class="hljs-comment">查看课程 0 的所有后续课程（在邻接表 to[0] 中查找），可以看到课程 1 依赖于课程 0。</span><br><span class="hljs-comment">减少课程 1 的入度（inDeg[1]--），此时课程 1 的入度变为 0，表示可以学习课程 1，将其加入队列。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = [1]</span><br><span class="hljs-comment">lessons = [0]</span><br><span class="hljs-comment">inDeg = [0, 0]</span><br><span class="hljs-comment">处理课程 1：</span><br><span class="hljs-comment">从队列中取出课程 1，并将其标记为已完成（加入 lessons 列表）。</span><br><span class="hljs-comment">课程 1 没有后续课程，因此队列处理完毕。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = []</span><br><span class="hljs-comment">lessons = [0, 1]</span><br><span class="hljs-comment">步骤 4：判断结果 拓扑排序完成后，lessons 列表中包含了所有课程 [0, 1]，说明可以完成所有课程。 因此，最终返回 true。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总结： 这段代码使用的是拓扑排序算法，利用 BFS 来检测图中是否存在环： 如果所有课程都能在拓扑排序中被处理（即 lessons.size() == numCourses），说明没有循环依赖，可以完成所有课程。 如果存在环，则会有一些课程无法被处理，队列会提前结束，此时返回 false。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<h4 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化节点数</span><br>        <span class="hljs-comment">// 计算实际的最大节点编号（n）</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取当前边的两个节点</span><br>            n = <span class="hljs-built_in">max</span>(n, <span class="hljs-built_in">max</span>(x, y));  <span class="hljs-comment">// 更新最大节点编号</span><br>        &#125;<br><br>        <span class="hljs-comment">// 初始化邻接表和访问标记数组</span><br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">// 遍历所有边，构建图并检查环</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取当前边的两个节点</span><br>            <br>            <span class="hljs-comment">// 添加边到邻接表中，构建无向图，邻接表的构建</span><br>            to[x].<span class="hljs-built_in">push_back</span>(y);<br>            to[y].<span class="hljs-built_in">push_back</span>(x);<br>            hasCycle = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 重置环标记</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 从节点1开始DFS，父节点设为0（不存在）</span><br><br>            <span class="hljs-comment">// 如果检测到环，返回当前边</span><br>            <span class="hljs-keyword">if</span> (hasCycle) <span class="hljs-keyword">return</span> edge;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果没有发现冗余边，返回空数组</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 深度优先搜索 (DFS) 用于检测是否形成环,dfs模版</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>        visited[x] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点已访问</span><br>        <span class="hljs-comment">// 遍历当前节点 x 的所有邻居节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>            <span class="hljs-keyword">if</span> (y == fa) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果是父节点，则跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[y]) &#123;<br>                <span class="hljs-comment">// 如果未访问，继续递归DFS</span><br>                <span class="hljs-built_in">dfs</span>(y, x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果已经访问过，说明存在环</span><br>                hasCycle = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;  <span class="hljs-comment">// 节点总数</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;  <span class="hljs-comment">// 邻接表，存储每个节点的邻居</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited;  <span class="hljs-comment">// 标记节点是否访问过</span><br>    <span class="hljs-type">bool</span> hasCycle;  <span class="hljs-comment">// 是否存在环的标记</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">遍历边 &#123;1, 2&#125;，图中没有环，继续。</span><br><span class="hljs-comment">遍历边 &#123;1, 3&#125;，图中没有环，继续。</span><br><span class="hljs-comment">遍历边 &#123;2, 3&#125;，此时检测到环，返回 &#123;2, 3&#125;。</span><br><span class="hljs-comment">假设输入：</span><br><span class="hljs-comment">edges = &#123;&#123;1, 2&#125;, &#123;1, 3&#125;, &#123;2, 3&#125;&#125;</span><br><span class="hljs-comment">这表示有 3 条边和 3 个节点，图的结构如下：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">复制代码</span><br><span class="hljs-comment">1 - 2</span><br><span class="hljs-comment">|   |</span><br><span class="hljs-comment">3 - -</span><br><span class="hljs-comment">我们需要找到一条冗余的边，这条边的加入会导致形成环。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">模拟执行过程：</span><br><span class="hljs-comment">第一步：初始化</span><br><span class="hljs-comment">初始化 n = 0，用于存储节点的最大编号。</span><br><span class="hljs-comment">遍历 edges，更新 n 为最大节点编号，最终得到 n = 3。</span><br><span class="hljs-comment">初始化邻接表 to 和访问标记数组 visited：</span><br><span class="hljs-comment">to = [[], [], [], []]  // 邻接表初始化，4 个空列表（因为节点编号从 1 开始）</span><br><span class="hljs-comment">visited = [false, false, false, false]  // 节点访问标记，全部为 false</span><br><span class="hljs-comment">第二步：开始遍历每一条边</span><br><span class="hljs-comment">我们依次处理每一条边，将其加入邻接表，并进行 DFS 检测是否有环。</span><br><span class="hljs-comment">处理边 &#123;1, 2&#125;：</span><br><span class="hljs-comment">将边 &#123;1, 2&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2], [1], []]  // 节点 1 和 2 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, false, false]</span><br><span class="hljs-comment">遍历节点 1 的邻居节点，发现节点 2 尚未访问，因此进入节点 2 的 DFS。</span><br><span class="hljs-comment">访问节点 2，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, false]</span><br><span class="hljs-comment">节点 2 的邻居是节点 1（父节点），跳过。</span><br><span class="hljs-comment">结束 DFS，没有发现环。</span><br><span class="hljs-comment">处理边 &#123;1, 3&#125;：</span><br><span class="hljs-comment">将边 &#123;1, 3&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2, 3], [1], [1]]  // 节点 1 和 3 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, false]</span><br><span class="hljs-comment">遍历节点 1 的邻居，发现节点 2 已访问过，跳过。</span><br><span class="hljs-comment">发现节点 3 尚未访问，进入节点 3 的 DFS。</span><br><span class="hljs-comment">访问节点 3，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, true]</span><br><span class="hljs-comment">节点 3 的邻居是节点 1（父节点），跳过。</span><br><span class="hljs-comment">结束 DFS，没有发现环。</span><br><span class="hljs-comment">处理边 &#123;2, 3&#125;：</span><br><span class="hljs-comment">将边 &#123;2, 3&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2, 3], [1, 3], [1, 2]]  // 节点 2 和 3 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, true]</span><br><span class="hljs-comment">遍历节点 1 的邻居，发现节点 2 已访问过，跳过。</span><br><span class="hljs-comment">发现节点 3 已访问过，跳过。</span><br><span class="hljs-comment">然后，节点 2 继续进行 DFS，发现节点 3 已访问过，但节点 3 不是父节点，说明形成环。</span><br><span class="hljs-comment">标记 hasCycle = true。</span><br><span class="hljs-comment">结束 DFS，发现环，冗余边是 &#123;2, 3&#125;。</span><br><span class="hljs-comment">第三步：返回结果</span><br><span class="hljs-comment">因为在处理边 &#123;2, 3&#125; 时发现了环，因此该边就是冗余边，返回：</span><br><span class="hljs-comment">&#123;2, 3&#125;</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">冗余边是 &#123;2, 3&#125;，这条边导致了环的出现。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">解释：</span><br><span class="hljs-comment">边 &#123;1, 2&#125; 和 &#123;1, 3&#125; 构建了图的主体结构，但在加入 &#123;2, 3&#125; 后，形成了一个环 1 → 2 → 3 → 1，因此 &#123;2, 3&#125; 是冗余边。</span><br><span class="hljs-comment">代码通过 DFS 递归检测邻居节点，如果发现某个已访问的节点不是当前节点的父节点，则说明有环出现。    </span><br><span class="hljs-comment">*/</span><br>    <br></code></pre></td></tr></table></figure>



<h4 id="环检测"><a href="#环检测" class="headerlink" title="环检测"></a><strong>环检测</strong></h4><p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; onPath)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点为已访问</span><br>    onPath[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点位于递归路径上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, to, visited, onPath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (onPath[v]) &#123;<br>            hasCycle = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 检测到环</span><br>        &#125;<br>    &#125;<br>    onPath[u] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 递归结束后，移除路径上的节点</span><br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="十七-搜索"><a href="#十七-搜索" class="headerlink" title="十七.搜索"></a>十七.搜索</h2><h3 id="状态与状态空间搜索"><a href="#状态与状态空间搜索" class="headerlink" title="状态与状态空间搜索"></a><strong>状态与状态空间搜索</strong></h3><ul>
<li><p><strong>状态</strong>：</p>
<p>什么是状态?题面中涉及的所有数学信息，你在纸上人力计算时，关注的所有数据，一个函数访问的所有变量，例如最简单的计票问题，给n个名字，统计每个名字出现了多少次，你在纸上画“正”字统计的时候，关注了哪些数据?名字(n个字符串)，统计到哪个名字了(第1≤i≤n个名字)，画的“正”字(一个用于计数的数据结构，例如 Hash Map，就是程序维护的所有动态数据构成的集合，我们关注动态变化的变量</p>
</li>
<li><p><strong>状态空间</strong></p>
<p>所有可能状态构成的集合就是一个问题的状态空间，把状态作为点，如果从一个状态可以到达另一个状态，就连一条边这样就把整，状态空间抽象为了一张有向图，对问题的求解，就是对这张图的遍历，计票问题的状态空间由n个状态组成，可以看作一张n个点，n-1条边的有向图，整张图是一条链，自然就可以用一维循环解决了</p>
</li>
<li><p><strong>搜索算法</strong>：</p>
<ul>
<li><strong>深度优先搜索（DFS）</strong>：优先探索当前路径，深入到不能继续为止，再进行回溯。适用于需要遍历整棵搜索树或图的场景。</li>
<li><strong>广度优先搜索（BFS）</strong>：按照层次逐步扩展所有状态，适用于最短路径等需要找到最早解的场景。</li>
<li>一般来说，每个状态只遍历一次所以当状态空间是“图”而不是“树”时，要判重(记忆化)</li>
</ul>
</li>
</ul>
<h3 id="状态搜索的步骤"><a href="#状态搜索的步骤" class="headerlink" title="状态搜索的步骤"></a><strong>状态搜索的步骤</strong></h3><p>搜索题的解题步骤<br>1.纸上模拟，提取信息<br>2.定义状态<br>3.确定遍历顺序(DFS、BFS)<br>4.定义搜索框架<br>    如果是DFS，状态作为参数，确定递归边界，注意还原现场<br>    如果是BFS，状态用队列保存<br>    考虑是否需要判重<br>5.程序实现</p>
<p><strong>DFS 和 BFS 的比较</strong>：</p>
<ul>
<li><strong>深度优先搜索（DFS）</strong>：优先探索当前路径，深入到不能继续为止，再进行回溯。适用于需要遍历整棵搜索树或图的场景。</li>
<li><strong>广度优先搜索（BFS）</strong>：按照层次逐步扩展所有状态，适用于<code>最短</code>路径等需要找到<code>最早</code>解的场景。</li>
<li>状态空间为有向无环图或是求最大，最长<br>BFS拓扑排序&#x2F;DFS记忆化搜索均可,要去记一个dist路径</li>
</ul>
<hr>
<h3 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h3><h4 id="电话号码的字母组合问题："><a href="#电话号码的字母组合问题：" class="headerlink" title="电话号码的字母组合问题："></a>电话号码的字母组合问题：</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话按键一致。</p>
<p>例如：</p>
<ul>
<li>输入：”23”</li>
<li>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li>
</ul>
<p><strong>思路</strong>：</p>
<ul>
<li><strong>递归（DFS）实现</strong>：该问题可以被看作是一个递归问题，每个数字对应多个字母，每个数字的字母组合都与前一个数字的字母组合进行全排列。</li>
<li><strong>状态转移</strong>：每个状态表示当前递归到第几个数字，每次递归时选择对应数字所映射的字母，生成所有可能的字母组合。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_LEN = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 假设最多10个数字</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_RES = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 假设最多生成1000个结果</span><br><br>unordered_map&lt;<span class="hljs-type">char</span>, string&gt; alphabet;<br>string digits;<br>string ans[MAX_RES];  <span class="hljs-comment">// 用静态数组保存结果</span><br><span class="hljs-type">int</span> ans_size = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 结果的个数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, string str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">length</span>()) &#123;<br>        ans[ans_size++] = str;  <span class="hljs-comment">// 保存结果</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : alphabet[digits[index]]) &#123;<br>        <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, str + ch);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    alphabet[<span class="hljs-string">&#x27;2&#x27;</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;3&#x27;</span>] = <span class="hljs-string">&quot;def&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;4&#x27;</span>] = <span class="hljs-string">&quot;ghi&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;5&#x27;</span>] = <span class="hljs-string">&quot;jkl&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;6&#x27;</span>] = <span class="hljs-string">&quot;mno&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;7&#x27;</span>] = <span class="hljs-string">&quot;pqrs&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;8&#x27;</span>] = <span class="hljs-string">&quot;tuv&quot;</span>;<br>    alphabet[<span class="hljs-string">&#x27;9&#x27;</span>] = <span class="hljs-string">&quot;wxyz&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <br>    <span class="hljs-comment">// 输出所有结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans_size; i++) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; digits;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n 皇后问题"></a>n 皇后问题</h4><p>给你一个整数 n，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>输入：n &#x3D; 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”], [“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">15</span>;  <span class="hljs-comment">// 最大棋盘大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_ANS = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 假设最多有100种解法</span><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> ans_size = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 解法的数量</span><br><span class="hljs-type">int</span> p[MAX_N];  <span class="hljs-comment">// 存储每行皇后的列位置</span><br><span class="hljs-type">bool</span> used[MAX_N];  <span class="hljs-comment">// 标记列是否被占用</span><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; usedPlus;  <span class="hljs-comment">// 标记主对角线是否被占用</span><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; usedMinus;  <span class="hljs-comment">// 标记副对角线是否被占用</span><br>string result[MAX_ANS][MAX_N];  <span class="hljs-comment">// 存储解法，每个解法是一个棋盘的布局</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (row == n) &#123;<br>        <span class="hljs-comment">// 找到一个解法，将其保存</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;.&#x27;</span>)</span></span>;<br>            s[p[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            result[ans_size][i] = s;<br>        &#125;<br>        ans_size++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-keyword">if</span> (!used[col] &amp;&amp; !usedPlus[row + col] &amp;&amp; !usedMinus[row - col]) &#123;<br>            p[row] = col;<br>            used[col] = <span class="hljs-literal">true</span>;<br>            usedPlus[row + col] = <span class="hljs-literal">true</span>;<br>            usedMinus[row - col] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>);<br>            usedMinus[row - col] = <span class="hljs-literal">false</span>;<br>            usedPlus[row + col] = <span class="hljs-literal">false</span>;<br>            used[col] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 输出所有解法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans_size; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            cout &lt;&lt; result[i][j] &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">solveNQueens</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_M = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 最大行数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 最大列数</span><br><br><span class="hljs-type">int</span> m, n;<br><span class="hljs-type">char</span> grid[MAX_M][MAX_N];  <span class="hljs-comment">// 用静态数组表示网格</span><br><span class="hljs-type">bool</span> visited[MAX_M][MAX_N];  <span class="hljs-comment">// 用静态数组表示访问标记</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;sx, sy&#125;);<br>    visited[sx][sy] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> y = q.<span class="hljs-built_in">front</span>().second;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> nx = x + dx[i];<br>            <span class="hljs-type">int</span> ny = y + dy[i];<br>            <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= m || ny &lt; <span class="hljs-number">0</span> || ny &gt;= n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (grid[nx][ny] != <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (visited[nx][ny]) <span class="hljs-keyword">continue</span>;<br>            q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>            visited[nx][ny] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(visited, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(visited));  <span class="hljs-comment">// 初始化访问标记</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !visited[i][j]) &#123;<br>                ans++;<br>                <span class="hljs-built_in">bfs</span>(i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            cin &gt;&gt; grid[i][j];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">numIslands</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h4 id="基因突变问题"><a href="#基因突变问题" class="headerlink" title="基因突变问题"></a>基因突变问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e4</span>; <span class="hljs-comment">// 假设字典中最多有 10000个元素</span><br>unordered_set&lt;string&gt; hasBank;  <span class="hljs-comment">// 存储所有的变换字符串</span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; depth;  <span class="hljs-comment">// 记录每个字符串的最短变换次数</span><br><br><span class="hljs-comment">// 字符集对应的字符数组</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> gene[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(<span class="hljs-type">char</span> start[<span class="hljs-number">9</span>], <span class="hljs-type">char</span> end[<span class="hljs-number">9</span>], <span class="hljs-type">char</span> bank[][<span class="hljs-number">9</span>], <span class="hljs-type">int</span> bankSize)</span> </span>&#123;<br>    <span class="hljs-comment">// 将所有的基因放入字典</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bankSize; i++) &#123;<br>        hasBank.<span class="hljs-built_in">insert</span>(bank[i]);<br>    &#125;<br>    <span class="hljs-comment">// 如果目标字符串不在字典中，直接返回 -1</span><br>    <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(end) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// BFS 初始化</span><br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    depth[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        string s = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 遍历每个位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] != gene[j]) &#123;<br>                    string ns = s;<br>                    ns[i] = gene[j];<br>                    <span class="hljs-comment">// 如果新字符串在字典中，且尚未访问过</span><br>                    <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(ns) != hasBank.<span class="hljs-built_in">end</span>() &amp;&amp; depth.<span class="hljs-built_in">find</span>(ns) == depth.<span class="hljs-built_in">end</span>()) &#123;<br>                        depth[ns] = depth[s] + <span class="hljs-number">1</span>;<br>                        q.<span class="hljs-built_in">push</span>(ns);<br>                        <br>                        <span class="hljs-comment">// 找到目标字符串，返回最短变换步骤</span><br>                        <span class="hljs-keyword">if</span> (ns == end) <span class="hljs-keyword">return</span> depth[ns];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 从输入中读取数据</span><br>    <span class="hljs-type">char</span> start[<span class="hljs-number">9</span>], end[<span class="hljs-number">9</span>];<br>    cin &gt;&gt; start &gt;&gt; end;<br>    <br>    <span class="hljs-type">int</span> bankSize;<br>    cin &gt;&gt; bankSize;<br>    <br>    <span class="hljs-type">char</span> bank[bankSize][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bankSize; i++) &#123;<br>        cin &gt;&gt; bank[i];<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">minMutation</span>(start, end, bank, bankSize) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a><strong>矩阵中的最长递增路径</strong></h4><p>matrix &#x3D; [<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]</p>
<p><strong>最长路径计算</strong>：通过 BFS 遍历所有节点，记录每个节点的最长递增路径长度，最终获取最大值作为结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 假设最大矩阵为100x100</span><br><span class="hljs-type">int</span> m, n;  <span class="hljs-comment">// 矩阵的行列数</span><br><span class="hljs-type">int</span> matrix[MAX][MAX];<br>vector&lt;<span class="hljs-type">int</span>&gt; to[MAX * MAX];  <span class="hljs-comment">// 邻接表</span><br><span class="hljs-type">int</span> deg[MAX * MAX];  <span class="hljs-comment">// 节点的入度</span><br><span class="hljs-type">int</span> dist[MAX * MAX];  <span class="hljs-comment">// 从每个节点出发的最长路径</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    deg[v]++;<br>    to[u].<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i * n + j;  <span class="hljs-comment">// 将二维坐标转换为一维编号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n;  <span class="hljs-comment">// 判断是否在矩阵内</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 构建图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> ni = i + dx[k];<br>                <span class="hljs-type">int</span> nj = j + dy[k];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(ni, nj) &amp;&amp; matrix[ni][nj] &gt; matrix[i][j]) &#123;<br>                    <span class="hljs-built_in">addEdge</span>(<span class="hljs-built_in">num</span>(i, j), <span class="hljs-built_in">num</span>(ni, nj));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 进行拓扑排序</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            dist[i] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始点的路径长度是1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拓扑排序，更新每个节点的最长路径</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>            deg[y]--;<br>            dist[y] = <span class="hljs-built_in">max</span>(dist[y], dist[x] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (deg[y] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 找出最长路径</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, dist[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-comment">// 输入矩阵数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            cin &gt;&gt; matrix[i][j];<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">longestIncreasingPath</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>我们就知道了，在一张有效无环图上，不管是球最长啊。统计什么别的信息，只要这个信息需要对所有的哎入编做统计，比如取max，下求和等等，我们就可以使用。图排序来进行这样一个信息统计。</p>
<p>另一种方法：dfs记忆化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> m, n;<br><span class="hljs-type">int</span> matrix[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> dist[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>]; <span class="hljs-comment">// 用于记录最长路径的长度</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dist[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dist[x][y]; <span class="hljs-comment">// 如果已经计算过，则返回</span><br>    dist[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化当前路径长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>        <span class="hljs-type">int</span> nx = x + dx[k];<br>        <span class="hljs-type">int</span> ny = y + dy[k];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(nx, ny) &amp;&amp; matrix[nx][ny] &gt; matrix[x][y]) &#123;<br>            dist[x][y] = <span class="hljs-built_in">max</span>(dist[x][y], <span class="hljs-built_in">dfs</span>(nx, ny) + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历每个位置，进行深度优先搜索，找出最长递增路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(i, j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; m &gt;&gt; n; <span class="hljs-comment">// 输入行和列数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            cin &gt;&gt; matrix[i][j]; <span class="hljs-comment">// 输入矩阵元素</span><br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">longestIncreasingPath</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*s[11][11]：这是一个二维字符数组，用来表示数独的 9x9 网格。每个元素表示一个格子，值为 . 表示空格，1 到 9 代表已经填入的数字。</span><br><span class="hljs-comment">h[11][11]：用于记录每一行中数字是否已经被使用。h[x][i] 为 1 表示数字 i 已经在第 x 行使用。</span><br><span class="hljs-comment">l[11][11]：用于记录每一列中数字是否已经被使用。l[y][i] 为 1 表示数字 i 已经在第 y 列使用。</span><br><span class="hljs-comment">g[5][5][11]：用于记录每个 3x3 宫格中数字是否已经被使用。g[x/3][y/3][i] 为 1 表示数字 i 已经在 (x, y) 位置对应的 3x3 宫格中使用。 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">char</span> s[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br><span class="hljs-type">int</span> h[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>], l[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>], g[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>][<span class="hljs-number">11</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">if</span> (y == <span class="hljs-number">9</span>) x++, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">9</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) <span class="hljs-built_in">cout</span> &lt;&lt; s[i] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[x][y] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> dfs(x, y + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (h[x][i] || l[y][i] || g[x / <span class="hljs-number">3</span>][y / <span class="hljs-number">3</span>][i]) <span class="hljs-keyword">continue</span>;<br>        h[x][i] = l[y][i] = g[x / <span class="hljs-number">3</span>][y / <span class="hljs-number">3</span>][i] = <span class="hljs-number">1</span>;<br>        s[x][y] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (dfs(x, y + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        h[x][i] = l[y][i] = g[x / <span class="hljs-number">3</span>][y / <span class="hljs-number">3</span>][i] = <span class="hljs-number">0</span>;<br>        s[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> x = s[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            h[i][x] = l[j][x] = g[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][x] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="二进制枚举-填空题"><a href="#二进制枚举-填空题" class="headerlink" title="二进制枚举(填空题)"></a>二进制枚举(填空题)</h3><hr>
<h2 id="十八-贪心"><a href="#十八-贪心" class="headerlink" title="十八. 贪心"></a>十八. 贪心</h2><p>1)最自然智慧的算法<br>2)用一种局部最功利的标准，总是做出在当前看来是最好的选择<br>3)难点在于证明局部最功利的标准可以得到全局最优解<br>4)对于贪心算法的学习主要以增加阅历和经验为主</p>
<p>只要举出一个错误解就是无效的，我们每个人都会对局部定义一个比较好的状况，然后我们想一步一步按照我们的想法执行，那么你每一步定的那个策略，它就属属于你的贪心策略。他能够推出最终的最优解，那贪心策略就是有效的，他是贪不出来他那最最终策略就是无效的，</p>
<p>但是证明是不可能证明的，要用对数器，写一个暴力解比对贪心策略,也不用太研究，就记住以下例题就行</p>
<h3 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h3><h4 id="会议室"><a href="#会议室" class="headerlink" title="会议室"></a>会议室</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 会议结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Program</span> &#123;</span><br>    <span class="hljs-type">int</span> start, end;<br>&#125;;<br><br><span class="hljs-comment">// 自定义排序规则，按照会议的结束时间升序排序</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Program&amp; a, <span class="hljs-type">const</span> Program&amp; b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a.end &lt; b.end;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bestArrange2</span><span class="hljs-params">(Program programs[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 按照结束时间升序排序</span><br>    sort(programs, programs + n, cmp);<br>    <br>    <span class="hljs-type">int</span> timeLine = <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 贪心策略：选择结束时间最早的会议</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (timeLine &lt;= programs[i].start) &#123;<br>            result++;<br>            timeLine = programs[i].end;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    Program programs[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 预设最多100个会议</span><br>    <span class="hljs-comment">// 输入会议时间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; programs[i].start &gt;&gt; programs[i].end;<br>    &#125;<br>    <span class="hljs-comment">// 输出最多可以安排的会议数量</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; bestArrange2(programs, n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h4><p>假设你是一位很慷慨的家长，想要给孩子们一些小饼干。但是，每个孩子最多只能得到一块饼干。</p>
<ul>
<li>每个孩子都有一个胃口值 <code>g[i]</code>，代表满足这个孩子所需的饼干大小。</li>
<li>每块饼干的大小用 <code>s[j]</code> 表示。</li>
<li>只有当饼干的大小 <code>s[j] &gt;= g[i]</code> 时，这块饼干才能满足孩子的胃口。</li>
</ul>
<p><strong>示例 1</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>g = [1, 2, 3]</code>, <code>s = [1, 1]</code></li>
<li><strong>输出</strong>：<code>1</code></li>
<li><strong>解释</strong>：你有 3 个孩子，胃口值分别是 1、2、3，有 2 块饼干，大小都是 1。只能满足胃口值为 1 的孩子，所以输出 1。</li>
</ul>
<p><strong>示例 2</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>g = [1, 2]</code>, <code>s = [1, 2, 3]</code></li>
<li><strong>输出</strong>：<code>2</code></li>
<li><strong>解释</strong>：你有 2 个孩子，胃口值分别是 1、2，有 3 块饼干，大小分别是 1、2、3。可以满足所有孩子的需求，所以输出 2。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贪心策略是小饼干先喂饱小胃口</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> g[], <span class="hljs-type">int</span> s[], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sort</span>(g, g + m); <span class="hljs-comment">// 对孩子的胃口值排序</span><br>    <span class="hljs-built_in">sort</span>(s, s + n); <span class="hljs-comment">// 对饼干的大小排序</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 饼干索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; s[j] &lt; g[i]) j++; <span class="hljs-comment">// 找到满足当前孩子胃口的饼干</span><br>        <span class="hljs-keyword">if</span> (j &lt; n) &#123; <span class="hljs-comment">// 如果找到满足条件的饼干</span><br>            ans++; <span class="hljs-comment">// 满足一个孩子</span><br>            j++; <span class="hljs-comment">// 使用一块饼干</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m, n;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-type">int</span> g[m], s[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) cin &gt;&gt; g[i]; <span class="hljs-comment">// 孩子的胃口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; s[i]; <span class="hljs-comment">// 饼干的大小</span><br>    <br>    cout &lt;&lt; <span class="hljs-built_in">findContentChildren</span>(g, s, m, n) &lt;&lt; endl; <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*贪心算法成立的条件：</span><br><span class="hljs-comment">问题类型：本题属于资源分配问题，与零钱找零问题类似，目标是尽可能满足需求。贪心算法在这种情况下有效，因为我们希望通过合理分配资源来满足尽可能多的孩子。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">条件满足：在本题中，每个孩子只能得到一块饼干，并且不同饼干大小是可以互相满足的（一个大饼干既可以满足小胃口的孩子，也可以满足大胃口的孩子）。因此，通过贪心算法优先满足小胃口的孩子，就能将剩余的大饼干留给更需要的大胃口孩子，提升满足总人数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">面值分析（在本题中的对应）：</span><br><span class="hljs-comment">胃口大小与饼干大小分析：</span><br><span class="hljs-comment">孩子的胃口值数组 g 和饼干大小数组 s 都按从小到大的顺序排序。</span><br><span class="hljs-comment">如果能够用一个较小的饼干满足小胃口的孩子，那么这块饼干必然也能满足所有比该孩子胃口更小的孩子。因此，优先使用小饼干满足小胃口的孩子可以最大化满足需求，并留出更多大的饼干给大胃口的孩子。</span><br><span class="hljs-comment">决策包容性：</span><br><span class="hljs-comment">包容性分析：</span><br><span class="hljs-comment">在选择分配饼干时，优先选择满足小胃口的孩子，确保我们把最小的饼干分配给最适合的孩子。这样即使后续需求更大，我们仍然保有较大饼干以满足较高的需求。</span><br><span class="hljs-comment">这种选择包含了未来的可能性（即更大胃口的孩子仍能得到较大的饼干），确保资源利用最大化，增加整体满足的可能性。</span><br><span class="hljs-comment">贪心策略：</span><br><span class="hljs-comment">贪心策略：在分配时，优先分配小饼干给小胃口的孩子，尽可能满足最小需求，从而将较大的资源保留给更高需求的情况。这样可以提高整体满足率，实现题目目标。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><p>给定一个数组 <code>prices</code>，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格。 你可以尽可能多次买卖股票（多次买入和卖出）。但在再次买入之前，必须先卖出股票。</p>
<p>目标是设计一个算法来计算能够获得的最大利润。</p>
<p>示例</p>
<p><strong>示例 1</strong>：</p>
<ul>
<li><p><strong>输入</strong>：<code>prices = [7, 1, 5, 3, 6, 4]</code></p>
</li>
<li><p><strong>输出</strong>：<code>7</code></p>
</li>
<li><p>解释：</p>
<ul>
<li>第 2 天买入（价格 &#x3D; 1），第 3 天卖出（价格 &#x3D; 5），利润 &#x3D; 5 - 1 &#x3D; 4。</li>
<li>第 4 天买入（价格 &#x3D; 3），第 5 天卖出（价格 &#x3D; 6），利润 &#x3D; 6 - 3 &#x3D; 3。</li>
<li>总利润 &#x3D; 4 + 3 &#x3D; 7。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//贪心策略是只要股票价格上涨，就进行一次卖出，把所有上涨的利润都累加起来，每次在价格上涨的前一天买入（隐藏）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> prices[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        ans += max(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果今天价格比前一天高，累加差价</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n; <span class="hljs-comment">// 输入股票的天数</span><br>    <span class="hljs-type">int</span> prices[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; prices[i]; <span class="hljs-comment">// 输入每一天的股票价格</span><br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; maxProfit(prices, n) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出最大利润</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><p>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个位置。数组中的每个元素表示你在该位置可以跳跃的最大长度。目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例</p>
<p><strong>示例 1</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>nums = [2,3,1,1,4]</code>   </li>
<li><strong>输出</strong>：<code>2</code></li>
<li><strong>解释</strong>：跳到最后一个位置的最小跳跃数是 2。可以先从索引 0 跳到索引 1，再从索引 1 跳到最后一个位置。</li>
</ul>
<p><strong>示例 2</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>nums = [2,3,0,1,4]</code></li>
<li><strong>输出</strong>：<code>2</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贪心策略，每一次只需要跳到再一次中最远的点</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n; <span class="hljs-comment">// 输入数组的大小</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 跳跃数组</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; nums[i]; <span class="hljs-comment">// 输入跳跃数组</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 当前的位置</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 跳跃次数</span><br><br>    <span class="hljs-keyword">while</span> (now &lt; n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 当前还没到达终点</span><br>        <span class="hljs-type">int</span> right = now + nums[now]; <span class="hljs-comment">// 当前能跳到的最远范围</span><br>        <span class="hljs-keyword">if</span> (right &gt;= n - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; ans + <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 如果可以直接跳到最后，返回答案+1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> nextRight = right;<br>        <span class="hljs-type">int</span> next = now;<br><br>        <span class="hljs-comment">// 遍历当前跳跃范围内的所有位置，找到能跳到的最远位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i + nums[i] &gt; nextRight) &#123; <span class="hljs-comment">// 更新最远跳跃位置</span><br>                nextRight = i + nums[i];<br>                next = i;<br>            &#125;<br>        &#125;<br><br>        now = next; <span class="hljs-comment">// 更新当前位置</span><br>        ans++; <span class="hljs-comment">// 增加跳跃次数</span><br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">/*贪心策略：</span><br><span class="hljs-comment">在每一步跳跃中，选择当前可以跳到的范围内的最远位置，从而确保每次跳跃后可以达到更大的范围。</span><br><span class="hljs-comment">假设位置 a 可以跳到 b1、b2、b3，而这些位置 b1、b2、b3 各自的最远跳跃位置为 c1、c2、c3。此时应该从 a 跳到能够达到最远位置的那个 b，这样可以保证未来的跳跃范围最大。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">决策包容性：</span><br><span class="hljs-comment">选择从 a 跳到“能跳得更远”的 b，因为这个选择确保未来的可达集合包含了其他跳跃选择的可达位置。这种策略即使不考虑未来的所有可能情况，也能保证当前选择的合理性。</span><br><span class="hljs-comment">简单来说，这种局部最优的决策能够带来全局最优的结果。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">贪心策略</span><br><span class="hljs-comment">贪心策略：本题的贪心策略是在每一步中选择能够跳到最远的范围。通过这种逐步扩展跳跃范围的方式，每一步都接近终点，从而减少总的跳跃次数，实现最小步数。</span><br></code></pre></td></tr></table></figure>



<h4 id="哈弗曼编码下的问题"><a href="#哈弗曼编码下的问题" class="headerlink" title="哈弗曼编码下的问题"></a>哈弗曼编码下的问题</h4><p>通过每次选择最小的元素合并，确保得到最优的结果</p>
<p>1.冶金问题</p>
<p>{10, 20, 30} 我们需要这些长度的金块，总长度为数组之和，每次切割会消费这个和，怎么切割会让输出最小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lessMoney</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq(arr.begin(), arr.end()); <span class="hljs-comment">// 小根堆</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        cur = pq.top(); pq.pop();   <span class="hljs-comment">//哈夫曼编码流程</span><br>        cur += pq.top(); pq.pop();<br>        sum += cur;<br>        pq.push(cur);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; lessMoney(arr) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 90</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.最小代价合并木棍问题</p>
<p>问题描述：<br>给定 <code>n</code> 根木棍，每次可以合并两根木棍，合并两根木棍的长度之和<strong>。最终我们要把所有木棍合并成一根，求</strong>最小的总合并代价</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 假设木棍数量最大为100</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minCostToMergeSticks</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> sticks[])</span> &#123;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;  <span class="hljs-comment">// 小根堆</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将所有木棍放入小根堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        pq.push(sticks[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> a = pq.top(); pq.pop();<br>        <span class="hljs-type">int</span> b = pq.top(); pq.pop();<br>        <span class="hljs-type">int</span> cost = a + b;<br>        sum += cost;<br>        pq.push(cost);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;  <span class="hljs-comment">// 读取木棍的数量</span><br>    <span class="hljs-type">int</span> sticks[MAX_N];  <span class="hljs-comment">// 静态数组存储木棍长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; sticks[i];  <span class="hljs-comment">// 读取每根木棍的长度</span><br>    &#125;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; minCostToMergeSticks(n, sticks) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出最小合并代价</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="项目安排问题"><a href="#项目安排问题" class="headerlink" title="项目安排问题"></a>项目安排问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*选择资本需求小的项目：首先要保证你有足够的资本来投资项目。因此，优先考虑当前资本（W）小于或等于项目资本需求的项目。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">选择利润最大的项目：在满足资本条件的项目中，选择能够带来最大利润的项目进行投资。这样可以确保每次投资带来最大的资本增长。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">重复进行：重复上述两步，直到完成最多 K 次投资。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">具体流程：</span><br><span class="hljs-comment">我们使用两个堆：</span><br><span class="hljs-comment">小根堆：按照资本大小排序，保证每次从最小的资本需求开始考虑项目。</span><br><span class="hljs-comment">大根堆：按照利润大小排序，确保每次从利润最大的项目中选择。</span><br><span class="hljs-comment">贪心选择理由：</span><br><span class="hljs-comment">为什么选择资本需求小的项目？</span><br><span class="hljs-comment">因为我们需要保证每次投资都能顺利进行。我们不能跳过当前资金无法投资的项目，所以我们需要一个优先队列来逐步筛选符合条件的项目。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">为什么选择利润大的项目？</span><br><span class="hljs-comment">为了最大化资本的增长。每次选择能够带来最大利润的项目，能够在接下来的投资中获得更多的资本，从而增加后续可选的项目范围。*/</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 假设最多有100个项目</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-type">int</span> K, <span class="hljs-type">int</span> W, <span class="hljs-type">int</span> Profits[], <span class="hljs-type">int</span> Capital[], <span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-comment">// 创建一个小根堆（根据资本排序），minCostQ存储资本和对应的利润</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; minCostQ;<br>    <br>    <span class="hljs-comment">// 创建一个大根堆（根据利润排序），maxProfitQ存储利润和对应的资本</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; maxProfitQ;<br><br>    <span class="hljs-comment">// 将所有项目按照资本大小加入minCostQ</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        minCostQ.push(&#123;Capital[i], Profits[i]&#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 做K次投资，每次选择利润最大化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;<br>        <span class="hljs-comment">// 将所有资本不超过当前W的项目加入到maxProfitQ</span><br>        <span class="hljs-keyword">while</span> (!minCostQ.empty() &amp;&amp; minCostQ.top().first &lt;= W) &#123;<br>            maxProfitQ.push(minCostQ.top());<br>            minCostQ.pop(); <span class="hljs-comment">// 从minCostQ中移除已选择的项目</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果maxProfitQ为空，表示没有可以投资的项目，返回当前资本</span><br>        <span class="hljs-keyword">if</span> (maxProfitQ.empty()) &#123;<br>            <span class="hljs-keyword">return</span> W;<br>        &#125;<br><br>        <span class="hljs-comment">// 从maxProfitQ中取出利润最大的项目，更新当前资本W</span><br>        W += maxProfitQ.top().second;<br>        maxProfitQ.pop(); <span class="hljs-comment">// 移除已选择的项目</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> W; <span class="hljs-comment">// 返回经过K次投资后的最大资本</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> Profits[MAX_N] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;     <span class="hljs-comment">// 每个项目的利润</span><br>    <span class="hljs-type">int</span> Capital[MAX_N] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;     <span class="hljs-comment">// 每个项目所需的资本</span><br>    <span class="hljs-type">int</span> K = <span class="hljs-number">2</span>;                          <span class="hljs-comment">// 最多可以进行2次投资</span><br>    <span class="hljs-type">int</span> W = <span class="hljs-number">0</span>;                          <span class="hljs-comment">// 初始资本为0</span><br>    <span class="hljs-type">int</span> N = <span class="hljs-number">3</span>;                          <span class="hljs-comment">// 项目数量</span><br><br>    <span class="hljs-comment">// 调用函数获取经过K次投资后的最大资本</span><br>    <span class="hljs-type">int</span> result = findMaximizedCapital(K, W, Profits, Capital, N);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Maximized Capital: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出最大资本</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<hr>
<h2 id="十九-动态规划"><a href="#十九-动态规划" class="headerlink" title="十九.动态规划"></a>十九.动态规划</h2><h3 id="从暴力递归到动态规划"><a href="#从暴力递归到动态规划" class="headerlink" title="从暴力递归到动态规划"></a>从暴力递归到动态规划</h3><p>1，尝试运用模型解出暴力递归，原则是尽量少参，可变参数限制在int<br>    从左往右的尝试模型：要 or 不要<br>    范围尝试模型：0-index中的可能性<br>    样本对应模型：0-i 和 0-j 中判断逻辑，我们一般讨论i成为和不成为答案与j成为和不成为答案<br>    业务逻辑限制模型：</p>
<p>​	暴力尝试模型要记得把边界条件定义出来，最后完成暴力模型一定要注意设置的参数不要有负数，要在进入子过程前用if过滤掉就不用写前面了，在子过程前写</p>
<p>2，写出递归尝试后使用dp<br>    发现重复调用了子过程用dp傻缓存，主函数设都是-1的表，过程加上这个dp,直接把暴力递归抄下来，第一行写 if (dp<code>[i][j]</code> !&#x3D; -1) {return dp<code>[i][j]</code>}最后一行dp<code>[i][j]</code>&#x3D;..<br>    画出表格发现某些各种用for来计算其他格子，找出位置依赖自己尝试填充格子</p>
<p>3，分析依赖关系自己优化填表<br>    某个格子依赖下面和左面，那就往上面和右面填表<br>    路径压缩：就是一个之前算完的格子可以替代现在要算的很多格子<br>    斜率优化：</p>
<h3 id="例题-10"><a href="#例题-10" class="headerlink" title="例题"></a>例题</h3><h4 id="宇宙机器人"><a href="#宇宙机器人" class="headerlink" title="宇宙机器人"></a>宇宙机器人</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//机器人可以每步向左和右走一格，那么走k步到aim的方法数是多少</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//主过程先除掉不可能的值</span><br><span class="hljs-comment">// 机器人当前来到的位置是cur， 机器人还有rest步需要去走，最终的目标是aim， 有哪些位置？1~N 返回：机器人从cur出发，走过rest步之后，最终停在aim的方法数，是多少？</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process1</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;   <span class="hljs-comment">//只能向右</span><br>        <span class="hljs-keyword">return</span> process1(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == N) &#123;    <span class="hljs-comment">//只能向左</span><br>        <span class="hljs-keyword">return</span> process1(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>    &#125;<br>    <span class="hljs-keyword">return</span> process1(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N) + process1(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ways1</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> process1(start, K, aim, N);<br>&#125;<br><br><br><br><br><br><br><span class="hljs-comment">//傻缓存法，就是在上面的递归过程中把子过程的值抄到表里</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process2</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (dp[cur][rest] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[cur][rest];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>        ans = cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>        ans = process2(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == N) &#123;<br>        ans = process2(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans = process2(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp) + process2(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>    &#125;<br>    dp[cur][rest] = ans; <span class="hljs-comment">//把次调用的数组填到表里</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ways2</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(K + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)); <span class="hljs-comment">//0-N和0-K，记得设定为-1</span><br>    <span class="hljs-keyword">return</span> process2(start, K, aim, N, dp);<br>&#125;<br><br><br><br><br><span class="hljs-comment">//画表分析过程中的依赖关系自己填表</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ways3</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(K + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[aim][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= K; rest++) &#123;<br>        dp[<span class="hljs-number">1</span>][rest] = dp[<span class="hljs-number">2</span>][rest - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">2</span>; cur &lt; N; cur++) &#123;<br>            dp[cur][rest] = dp[cur - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>] + dp[cur + <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>        &#125;<br>        dp[N][rest] = dp[N - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[start][K];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="聪明人玩扑克"><a href="#聪明人玩扑克" class="headerlink" title="聪明人玩扑克"></a>聪明人玩扑克</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//两个聪明人玩抽牌，每次只能抽最左和最右的一张牌，返回胜这两人中最大的分数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">//先手获得的最好分数返回</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br>        <span class="hljs-keyword">return</span> arr[L];<br>    &#125;<br>    <span class="hljs-type">int</span> p1 = arr[L] + g1(arr, L + <span class="hljs-number">1</span>, R);  <span class="hljs-comment">//写p1p2代表可能性</span><br>    <span class="hljs-type">int</span> p2 = arr[R] + g1(arr, L, R - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> max(p1, p2);<br>&#125;<br><span class="hljs-comment">//后手获得的最好分数返回</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">g1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> p1 = f1(arr, L + <span class="hljs-number">1</span>, R); <span class="hljs-comment">// 对手拿走了L位置的数</span><br>    <span class="hljs-type">int</span> p2 = f1(arr, L, R - <span class="hljs-number">1</span>); <span class="hljs-comment">// 对手拿走了R位置的数</span><br>    <span class="hljs-keyword">return</span> min(p1, p2);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">win1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> first = f1(arr, <span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> second = g1(arr, <span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> max(first, second);<br>&#125;<br><br><br><br><br><br><span class="hljs-comment">//傻缓存法</span><br><span class="hljs-comment">// 先手获得的最好分数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; fmap, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; gmap)</span> &#123;<br>    <span class="hljs-keyword">if</span> (fmap[L][R] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> fmap[L][R];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br>        ans = arr[L];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> p1 = arr[L] + g2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap);<br>        <span class="hljs-type">int</span> p2 = arr[R] + g2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap);<br>        ans = max(p1, p2);<br>    &#125;<br>    fmap[L][R] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 后手获得的最好分数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">g2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; fmap, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; gmap)</span> &#123;<br>    <span class="hljs-keyword">if</span> (gmap[L][R] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> gmap[L][R];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (L != R) &#123;<br>        <span class="hljs-type">int</span> p1 = f2(arr, L + <span class="hljs-number">1</span>, R, fmap, gmap); <span class="hljs-comment">// 对手拿走了L位置的数</span><br>        <span class="hljs-type">int</span> p2 = f2(arr, L, R - <span class="hljs-number">1</span>, fmap, gmap); <span class="hljs-comment">// 对手拿走了R位置的数</span><br>        ans = min(p1, p2);<br>    &#125;<br>    gmap[L][R] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">win2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> N = arr.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; fmap(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N, <span class="hljs-number">-1</span>));<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; gmap(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N, <span class="hljs-number">-1</span>));<br>    <span class="hljs-type">int</span> first = f2(arr, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>, fmap, gmap);<br>    <span class="hljs-type">int</span> second = g2(arr, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>, fmap, gmap);<br>    <span class="hljs-keyword">return</span> max(first, second);<br>&#125;<br><br><br><br>    <br><span class="hljs-type">int</span> <span class="hljs-title function_">win3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> N = arr.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; fmap(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; gmap(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        fmap[i][i] = arr[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> startCol = <span class="hljs-number">1</span>; startCol &lt; N; startCol++) &#123;<br>        <span class="hljs-type">int</span> L = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> R = startCol;<br>        <span class="hljs-keyword">while</span> (R &lt; N) &#123;<br>            fmap[L][R] = max(arr[L] + gmap[L + <span class="hljs-number">1</span>][R], arr[R] + gmap[L][R - <span class="hljs-number">1</span>]);<br>            gmap[L][R] = min(fmap[L + <span class="hljs-number">1</span>][R], fmap[L][R - <span class="hljs-number">1</span>]);<br>            L++;<br>            R++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(fmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>], gmap[<span class="hljs-number">0</span>][N - <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;win1: &quot;</span> &lt;&lt; win1(arr) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;win2: &quot;</span> &lt;&lt; win2(arr) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;win3: &quot;</span> &lt;&lt; win3(arr) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 所有的货，重量和价值，都在w和v数组里， 为了方便，其中没有负数 bag背包容量，不能超过这个载重 返回：不超重的情况下，能够得到的最大价值</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 尝试函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; w, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> rest)</span> &#123;<br>    <span class="hljs-keyword">if</span> (rest &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index == w.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> p1 = process(w, v, index + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-type">int</span> p2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> next = process(w, v, index + <span class="hljs-number">1</span>, rest - w[index]);  <span class="hljs-comment">//这样写不好，因为傻缓存法会越界，一开始就过滤掉负数的可能</span><br>    <span class="hljs-keyword">if</span> (next != <span class="hljs-number">-1</span>) &#123;  <br>        p2 = v[index] + next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(p1, p2);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; w, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> bag)</span> &#123;<br>    <span class="hljs-keyword">if</span> (w.empty() || v.empty() || w.size() != v.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> process(w, v, <span class="hljs-number">0</span>, bag);<br>&#125;<br><br><br><br><span class="hljs-comment">// 傻缓存</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; w, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> rest, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (dp[index][rest] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[index][rest];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rest &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index == w.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不选当前物品</span><br>    <span class="hljs-type">int</span> p1 = process(w, v, index + <span class="hljs-number">1</span>, rest, dp);<br>	<span class="hljs-type">int</span> p2 = <span class="hljs-number">-1</span> ; <br>    <span class="hljs-comment">// 选择当前物品</span><br>  	<span class="hljs-keyword">if</span> (rest &gt;= w[index]) &#123; <span class="hljs-comment">//注意这里，因为参数作为数组下标一开始就不要让它越界</span><br>        p2 = v[index] + process(w, v, index + <span class="hljs-number">1</span>, rest - w[index], dp);<br>	&#125;<br>    dp[index][rest] = max(p1, p2);<br>    <span class="hljs-keyword">return</span> dp[index][rest];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; w, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> bag)</span> &#123;<br>    <span class="hljs-keyword">if</span> (w.empty() || v.empty() || w.size() != v.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 用 -1 初始化 dp 数组</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(w.size() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bag + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br><br>    <span class="hljs-comment">// 调用 process 函数计算最大价值</span><br>    <span class="hljs-keyword">return</span> process(w, v, <span class="hljs-number">0</span>, bag, dp);<br>&#125; <br><br><br><br><br><br><span class="hljs-comment">// 动态规划解法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; w, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> bag)</span> &#123;<br>    <span class="hljs-keyword">if</span> (w.empty() || v.empty() || w.size() != v.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> N = w.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bag + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= bag; rest++) &#123;<br>            <span class="hljs-type">int</span> p1 = dp[index + <span class="hljs-number">1</span>][rest];<br>            <span class="hljs-type">int</span> p2 = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> next = (rest - w[index] &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">-1</span> : dp[index + <span class="hljs-number">1</span>][rest - w[index]];<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-number">-1</span>) &#123;<br>                p2 = v[index] + next;<br>            &#125;<br>            dp[index][rest] = max(p1, p2);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][bag];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; weights = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; values = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">19</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> bag = <span class="hljs-number">15</span>;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Max Value (Recursive): &quot;</span> &lt;&lt; maxValue(weights, values, bag) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Max Value (DP): &quot;</span> &lt;&lt; dp(weights, values, bag) &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="数字转成字母的所有方法"><a href="#数字转成字母的所有方法" class="headerlink" title="数字转成字母的所有方法"></a>数字转成字母的所有方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 递归解法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; str, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == str.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ways = process(str, i + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; str.size() &amp;&amp; (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (str[i + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt; <span class="hljs-number">27</span>) &#123;<br>        ways += process(str, i + <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ways;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">number</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; str)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">strArr</span><span class="hljs-params">(str.begin(), str.end())</span>;<br>    <span class="hljs-keyword">return</span> process(strArr, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 从右往左的动态规划</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> N = s.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>    dp[N] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> ways = dp[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N &amp;&amp; (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[i + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt; <span class="hljs-number">27</span>) &#123;<br>                ways += dp[i + <span class="hljs-number">2</span>];<br>            &#125;<br>            dp[i] = ways;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// 从左往右的动态规划</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> N = s.size();<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(N, <span class="hljs-number">0</span>)</span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || s[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-string">&#x27;2&#x27;</span> || (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - <span class="hljs-number">2</span>] == <span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span>) ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>) &#123;<br>                dp[i] += (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span>) ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 随机生成测试字符串</span><br><span class="hljs-built_in">string</span> <span class="hljs-title function_">randomString</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-built_in">string</span> str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        str += (<span class="hljs-type">char</span>)(rand() % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 设置随机种子</span><br><br>    <span class="hljs-type">int</span> N = <span class="hljs-number">30</span>;<br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">1000000</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-type">int</span> len = rand() % N;<br>        <span class="hljs-built_in">string</span> s = randomString(len);<br>        <span class="hljs-type">int</span> ans0 = number(s);<br>        <span class="hljs-type">int</span> ans1 = dp1(s);<br>        <span class="hljs-type">int</span> ans2 = dp2(s);<br>        <span class="hljs-keyword">if</span> (ans0 != ans1 || ans0 != ans2) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;number: &quot;</span> &lt;&lt; ans0 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;dp1: &quot;</span> &lt;&lt; ans1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;dp2: &quot;</span> &lt;&lt; ans2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Oops!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试结束&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="贴纸组组成目标最小数量"><a href="#贴纸组组成目标最小数量" class="headerlink" title="贴纸组组成目标最小数量"></a>贴纸组组成目标最小数量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从stickers选择贴纸组组成目标最小数量并且每个贴纸的数量是无限的</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 递归解法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; stickers, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (target.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> minCount = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; sticker : stickers) &#123;<br>        <span class="hljs-built_in">string</span> rest = target;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : sticker) &#123;<br>            <span class="hljs-type">size_t</span> pos = rest.find(c);<br>            <span class="hljs-keyword">if</span> (pos != <span class="hljs-built_in">string</span>::npos) &#123;<br>                rest.erase(pos, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rest.length() != target.length()) &#123;<br>            minCount = min(minCount, process1(stickers, rest));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCount == INT_MAX ? INT_MAX : minCount + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minStickers1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; stickers, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; target)</span> &#123;<br>    <span class="hljs-type">int</span> result = process1(stickers, target);<br>    <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">-1</span> : result;<br>&#125;<br><br><br><br><br><span class="hljs-comment">// 使用词频统计的动态规划方法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; stickers, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (target.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">targetCounts</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : target) &#123;<br>        targetCounts[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> minCount = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; sticker : stickers) &#123;<br>        <span class="hljs-keyword">if</span> (sticker[target[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">string</span> rest;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (targetCounts[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> remaining = targetCounts[i] - sticker[i];<br>                    <span class="hljs-keyword">if</span> (remaining &gt; <span class="hljs-number">0</span>) rest.append(remaining, <span class="hljs-string">&#x27;a&#x27;</span> + i); <span class="hljs-comment">//记得防止越界</span><br>                &#125;<br>            &#125;<br>            minCount = min(minCount, process2(stickers, rest));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCount == INT_MAX ? INT_MAX : minCount + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minStickers2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; stickers, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; target)</span> &#123;<br>    <span class="hljs-type">int</span> N = stickers.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; counts(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : stickers[i]) &#123;<br>            counts[i][c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> result = process2(counts, target);<br>    <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">-1</span> : result;<br>&#125;<br><br><br><br><br><span class="hljs-comment">// 使用记忆化的动态规划</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; stickers, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; target, <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-type">int</span>&gt;&amp; dp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (dp.find(target) != dp.end()) &#123;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">targetCounts</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : target) &#123;<br>        targetCounts[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> minCount = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; sticker : stickers) &#123;<br>        <span class="hljs-keyword">if</span> (sticker[target[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">string</span> rest;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (targetCounts[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> remaining = targetCounts[i] - sticker[i];<br>                    <span class="hljs-keyword">if</span> (remaining &gt; <span class="hljs-number">0</span>) rest.append(remaining, <span class="hljs-string">&#x27;a&#x27;</span> + i);<br>                &#125;<br>            &#125;<br>            minCount = min(minCount, process3(stickers, rest, dp));<br>        &#125;<br>    &#125;<br><br>    dp[target] = minCount == INT_MAX ? INT_MAX : minCount + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> dp[target];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minStickers3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; stickers, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; target)</span> &#123;<br>    <span class="hljs-type">int</span> N = stickers.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; counts(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : stickers[i]) &#123;<br>            counts[i][c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-type">int</span>&gt; dp;<br>    dp[<span class="hljs-string">&quot;&quot;</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> result = process3(counts, target, dp);<br>    <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">-1</span> : result;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; stickers = &#123;<span class="hljs-string">&quot;with&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;science&quot;</span>&#125;;<br>    <span class="hljs-built_in">string</span> target = <span class="hljs-string">&quot;thehat&quot;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; minStickers1(stickers, target) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; minStickers2(stickers, target) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; minStickers3(stickers, target) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//样本对应模型，从结尾处讨论</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 递归解法，str1在0-i上和str2在0-j上的最长公共子序列</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; str1, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; str2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// str1[0..0]和str2[0..0]，都只剩一个字符了，样本对应模型讨论结尾也就是i能作为和不作为答案的与j作为答案和不作为答案的情况</span><br>        <span class="hljs-keyword">return</span> str1[i] == str2[j] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (str1[i] == str2[j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> process1(str1, str2, i, j - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (str1[i] == str2[j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> process1(str1, str2, i - <span class="hljs-number">1</span>, j);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// i != 0 &amp;&amp; j != 0</span><br>        <span class="hljs-type">int</span> p1 = process1(str1, str2, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-type">int</span> p2 = process1(str1, str2, i, j - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> p3 = (str1[i] == str2[j]) ? (<span class="hljs-number">1</span> + process1(str1, str2, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> max(p1, max(p2, p3));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s1.empty() || s2.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">str1</span><span class="hljs-params">(s1.begin(), s1.end())</span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">str2</span><span class="hljs-params">(s2.begin(), s2.end())</span>;<br>    <span class="hljs-keyword">return</span> process1(str1, str2, str1.size() - <span class="hljs-number">1</span>, str2.size() - <span class="hljs-number">1</span>);<br>&#125;<br><br><br><br><br><span class="hljs-comment">//傻缓存</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; str1, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; str2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span> &#123;<br>    <span class="hljs-comment">// 如果已经计算过这个子问题，直接返回结果</span><br>    <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[i][j];<br>    &#125;<br>    <span class="hljs-comment">// 计算最长公共子序列</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>        dp[i][j] = (str1[i] == str2[j]) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        dp[i][j] = (str1[i] == str2[j]) ? <span class="hljs-number">1</span> : process1(str1, str2, i, j - <span class="hljs-number">1</span>, dp);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>        dp[i][j] = (str1[i] == str2[j]) ? <span class="hljs-number">1</span> : process1(str1, str2, i - <span class="hljs-number">1</span>, j, dp);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// i != 0 &amp;&amp; j != 0</span><br>        <span class="hljs-type">int</span> p1 = process1(str1, str2, i - <span class="hljs-number">1</span>, j, dp);<br>        <span class="hljs-type">int</span> p2 = process1(str1, str2, i, j - <span class="hljs-number">1</span>, dp);<br>        <span class="hljs-type">int</span> p3 = (str1[i] == str2[j]) ? (<span class="hljs-number">1</span> + process1(str1, str2, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, dp)) : <span class="hljs-number">0</span>;<br>        dp[i][j] = max(p1, max(p2, p3));<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[i][j];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s1.empty() || s2.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">str1</span><span class="hljs-params">(s1.begin(), s1.end())</span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">str2</span><span class="hljs-params">(s2.begin(), s2.end())</span>;<br>    <span class="hljs-type">int</span> m = str1.size();<br>    <span class="hljs-type">int</span> n = str2.size();<br>    <span class="hljs-comment">// 创建一个 dp 数组，初始化为 -1，表示还没有计算过</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">return</span> process1(str1, str2, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, dp);<br>&#125;<br><br><br><br><br><br><span class="hljs-comment">// 动态规划解法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s1.empty() || s2.empty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">str1</span><span class="hljs-params">(s1.begin(), s1.end())</span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">str2</span><span class="hljs-params">(s2.begin(), s2.end())</span>;<br>    <span class="hljs-type">int</span> N = str1.size();<br>    <span class="hljs-type">int</span> M = str2.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (str1[<span class="hljs-number">0</span>] == str2[<span class="hljs-number">0</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; M; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = (str1[<span class="hljs-number">0</span>] == str2[j]) ? <span class="hljs-number">1</span> : dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = (str1[i] == str2[<span class="hljs-number">0</span>]) ? <span class="hljs-number">1</span> : dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-type">int</span> p1 = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-type">int</span> p2 = dp[i][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> p3 = (str1[i] == str2[j]) ? (<span class="hljs-number">1</span> + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) : <span class="hljs-number">0</span>;<br>            dp[i][j] = max(p1, max(p2, p3));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N - <span class="hljs-number">1</span>][M - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;abcde&quot;</span>;<br>    <span class="hljs-built_in">string</span> s2 = <span class="hljs-string">&quot;ace&quot;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Longest Common Subsequence (Recursive): &quot;</span> &lt;&lt; longestCommonSubsequence1(s1, s2) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Longest Common Subsequence (DP): &quot;</span> &lt;&lt; longestCommonSubsequence2(s1, s2) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="硬币找零问题"><a href="#硬币找零问题" class="headerlink" title="硬币找零问题"></a>硬币找零问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 统计硬币面值和张数,假设输入数组是：1, 2, 2, 3, 3, 3,遍历 arr 统计每个元素出现的次数，counts 会变成 &#123;1: 1, 2: 2, 3: 3&#125;。然后，代码遍历 counts 并将：1 加入 coins，1 加入 zhangs。2 加入 coins，2 加入 zhangs。3 加入 coins，3 加入 zhangs。最终，返回 pair：coins = &#123;1, 2, 3&#125;zhangs = &#123;1, 2, 3&#125;</span><br><span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; getInfo(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr) &#123;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; counts;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) counts[value]++;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; coins, zhangs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : counts) &#123;<br>        coins.push_back(entry.first);<br>        zhangs.push_back(entry.second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;coins, zhangs&#125;;<br>&#125;<br><br><span class="hljs-comment">// 递归方法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; zhangs, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> rest)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == coins.size()) <span class="hljs-keyword">return</span> rest == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ways = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> zhang = <span class="hljs-number">0</span>; zhang &lt;= zhangs[index] &amp;&amp; zhang * coins[index] &lt;= rest; zhang++) &#123;<br>        ways += process(coins, zhangs, index + <span class="hljs-number">1</span>, rest - zhang * coins[index]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ways;<br>&#125;<br><span class="hljs-comment">// 入口函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">coinsWay</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> aim)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty() || aim &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; info = getInfo(arr);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; coins = info.first;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; zhangs = info.second;<br>    <span class="hljs-keyword">return</span> process(coins, zhangs, <span class="hljs-number">0</span>, aim);<br>&#125;<br><br><br><br><br><span class="hljs-comment">// 动态规划方法 1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> aim)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty() || aim &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; info = getInfo(arr);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; coins = info.first;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; zhangs = info.second;<br>    <span class="hljs-type">int</span> N = coins.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(aim + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[N][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= aim; rest++) &#123;<br>            <span class="hljs-type">int</span> ways = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> zhang = <span class="hljs-number">0</span>; zhang &lt;= zhangs[index] &amp;&amp; zhang * coins[index] &lt;= rest; zhang++) &#123;<br>                ways += dp[index + <span class="hljs-number">1</span>][rest - zhang * coins[index]];<br>            &#125;<br>            dp[index][rest] = ways;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][aim];<br>&#125;<br><br><br><br><br><span class="hljs-comment">// 动态规划方法 2（优化）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> aim)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty() || aim &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; info = getInfo(arr);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; coins = info.first;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; zhangs = info.second;<br>    <span class="hljs-type">int</span> N = coins.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(aim + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[N][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= aim; rest++) &#123;<br>            dp[index][rest] = dp[index + <span class="hljs-number">1</span>][rest];<br>            <span class="hljs-keyword">if</span> (rest - coins[index] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[index][rest] += dp[index][rest - coins[index]];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (rest - coins[index] * (zhangs[index] + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[index][rest] -= dp[index + <span class="hljs-number">1</span>][rest - coins[index] * (zhangs[index] + <span class="hljs-number">1</span>)];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][aim];<br>&#125;<br><br><span class="hljs-comment">// 随机生成测试数组</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">randomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> maxLen, <span class="hljs-type">int</span> maxValue)</span> &#123;<br>    <span class="hljs-type">int</span> N = rand() % maxLen;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(N)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) arr[i] = rand() % maxValue + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 打印数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) <span class="hljs-built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">10</span>, maxValue = <span class="hljs-number">20</span>, testTime = <span class="hljs-number">1000000</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = randomArray(maxLen, maxValue);<br>        <span class="hljs-type">int</span> aim = rand() % maxValue;<br>        <span class="hljs-type">int</span> ans1 = coinsWay(arr, aim);<br>        <span class="hljs-type">int</span> ans2 = dp1(arr, aim);<br>        <span class="hljs-type">int</span> ans3 = dp2(arr, aim);<br>        <span class="hljs-keyword">if</span> (ans1 != ans2 || ans1 != ans3) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Oops!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            printArray(arr);<br>            <span class="hljs-built_in">cout</span> &lt;&lt; aim &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans3 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试结束&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="醉汉bob"><a href="#醉汉bob" class="headerlink" title="醉汉bob"></a>醉汉bob</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//计算k步后不会出去的概率</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 递归解法：计算生存可能性</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">livePosibility1</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M)</span> &#123;<br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-type">double</span>&gt;(process(row, col, k, N, M)) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">4</span>, k);<br>&#125;<br><span class="hljs-comment">// 递归处理函数，返回当前状态下的生存点数</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M)</span> &#123;<br>    <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || row &gt;= N || col &lt; <span class="hljs-number">0</span> || col &gt;= M) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果超出棋盘范围，返回0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果走完所有步数且仍在棋盘中，返回1</span><br>    &#125;<br>    <span class="hljs-comment">// 继续递归，尝试四个方向</span><br>    <span class="hljs-type">long</span> up = process(row - <span class="hljs-number">1</span>, col, rest - <span class="hljs-number">1</span>, N, M);<br>    <span class="hljs-type">long</span> down = process(row + <span class="hljs-number">1</span>, col, rest - <span class="hljs-number">1</span>, N, M);<br>    <span class="hljs-type">long</span> left = process(row, col - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, N, M);<br>    <span class="hljs-type">long</span> right = process(row, col + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, N, M);<br>    <span class="hljs-keyword">return</span> up + down + left + right;<br>&#125;<br><br><br><br><span class="hljs-comment">// 动态规划解法：计算生存可能性</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">livePosibility2</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;&gt;&gt; dp(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;&gt;(M, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br>    <span class="hljs-comment">// 初始化 dp 数组，rest=0 的时候每个位置都算作生存点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; ++j) &#123;<br>            dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 动态规划填表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= k; ++rest) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; N; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt; M; ++c) &#123;<br>                dp[r][c][rest] = pick(dp, N, M, r - <span class="hljs-number">1</span>, c, rest - <span class="hljs-number">1</span>);<br>                dp[r][c][rest] += pick(dp, N, M, r + <span class="hljs-number">1</span>, c, rest - <span class="hljs-number">1</span>);<br>                dp[r][c][rest] += pick(dp, N, M, r, c - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>);<br>                dp[r][c][rest] += pick(dp, N, M, r, c + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-type">double</span>&gt;(dp[row][col][k]) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">4</span>, k);<br>&#125;<br><span class="hljs-comment">// 帮助函数：检查当前位置是否越界，并返回相应的值</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">pick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;&gt;&gt;&amp; dp, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> rest)</span> &#123;<br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= N || c &lt; <span class="hljs-number">0</span> || c &gt;= M) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果越界，返回0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[r][c][rest];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 示例：给定棋盘大小50x50，走10步，从位置(6,6)开始</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; livePosibility1(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; livePosibility2(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="英雄之路"><a href="#英雄之路" class="headerlink" title="英雄之路"></a>英雄之路</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//怪物N滴血，英雄攻击在[0~M]，k次后击杀怪物的概率</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 计算右边的生存概率</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">right</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> all = <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, K); <span class="hljs-comment">// 总的砍法数</span><br>    <span class="hljs-type">long</span> kill = process(K, M, N); <span class="hljs-comment">// 砍死怪兽的方式数</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)kill / (<span class="hljs-type">double</span>)all;<br>&#125;<br><br><span class="hljs-comment">// 递归处理函数，计算砍死怪兽的情况数</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> times, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> hp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (times == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> hp &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果没有剩余步数，且怪兽血量&lt;=0，返回1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (hp &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, times); <span class="hljs-comment">// 如果血量&lt;=0，则有 4^times 种方式</span><br>    &#125;<br>    <span class="hljs-type">long</span> ways = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= M; i++) &#123;<br>        ways += process(times - <span class="hljs-number">1</span>, M, hp - i); <span class="hljs-comment">// 遍历所有伤害情况</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ways;<br>&#125;<br><br><br><span class="hljs-comment">// 动态规划解法1，计算砍死怪兽的情况数</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">dp1</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> all = <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, K); <span class="hljs-comment">// 总的砍法数</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;&gt; dp(K + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> times = <span class="hljs-number">1</span>; times &lt;= K; times++) &#123;<br>        dp[times][<span class="hljs-number">0</span>] = <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, times); <span class="hljs-comment">// 初始情况下，血量为0，所有的步数都能砍死</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> hp = <span class="hljs-number">1</span>; hp &lt;= N; hp++) &#123;<br>            <span class="hljs-type">long</span> ways = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= M; i++) &#123;<br>                <span class="hljs-keyword">if</span> (hp - i &gt;= <span class="hljs-number">0</span>) &#123;<br>                    ways += dp[times - <span class="hljs-number">1</span>][hp - i]; <span class="hljs-comment">// 从前一状态迁移</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ways += <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, times - <span class="hljs-number">1</span>); <span class="hljs-comment">// 如果血量为负，则每步有 (M+1) 种情况</span><br>                &#125;<br>            &#125;<br>            dp[times][hp] = ways;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> kill = dp[K][N];<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)kill / (<span class="hljs-type">double</span>)all;<br>&#125;<br><br><br><span class="hljs-comment">// 动态规划解法2，计算砍死怪兽的情况数</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">dp2</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">1</span> || M &lt; <span class="hljs-number">1</span> || K &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> all = <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, K); <span class="hljs-comment">// 总的砍法数</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;&gt; dp(K + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> times = <span class="hljs-number">1</span>; times &lt;= K; times++) &#123;<br>        dp[times][<span class="hljs-number">0</span>] = <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, times); <span class="hljs-comment">// 初始情况下，血量为0，所有的步数都能砍死</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> hp = <span class="hljs-number">1</span>; hp &lt;= N; hp++) &#123;<br>            dp[times][hp] = dp[times][hp - <span class="hljs-number">1</span>] + dp[times - <span class="hljs-number">1</span>][hp]; <span class="hljs-comment">// 当前步数下的血量状态</span><br><br>            <span class="hljs-comment">// 排除非法情况，确保血量不小于0</span><br>            <span class="hljs-keyword">if</span> (hp - <span class="hljs-number">1</span> - M &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[times][hp] -= dp[times - <span class="hljs-number">1</span>][hp - <span class="hljs-number">1</span> - M]; <span class="hljs-comment">// 排除掉那些不可能的情况</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[times][hp] -= <span class="hljs-built_in">pow</span>(M + <span class="hljs-number">1</span>, times - <span class="hljs-number">1</span>); <span class="hljs-comment">// 血量小于0时，跳过</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> kill = dp[K][N];<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)kill / (<span class="hljs-type">double</span>)all;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> NMax = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> MMax = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> KMax = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">200</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-type">int</span> N = rand() % NMax;<br>        <span class="hljs-type">int</span> M = rand() % MMax;<br>        <span class="hljs-type">int</span> K = rand() % KMax;<br>        <span class="hljs-type">double</span> ans1 = right(N, M, K);<br>        <span class="hljs-type">double</span> ans2 = dp1(N, M, K);<br>        <span class="hljs-type">double</span> ans3 = dp2(N, M, K);<br>        <span class="hljs-keyword">if</span> (ans1 != ans2 || ans1 != ans3) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Oops!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试结束&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="组成钱的最小张数"><a href="#组成钱的最小张数" class="headerlink" title="组成钱的最小张数"></a>组成钱的最小张数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure>

<h4 id="返回最接近的两个集合里较小的累加和"><a href="#返回最接近的两个集合里较小的累加和" class="headerlink" title="返回最接近的两个集合里较小的累加和"></a>返回最接近的两个集合里较小的累加和</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 递归解法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">right</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.size() &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, sum / <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// 递归</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> rest)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == arr.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 还有数，arr[i]这个数</span><br>        <span class="hljs-comment">// 可能性1，不使用arr[i]</span><br>        <span class="hljs-type">int</span> p1 = process(arr, i + <span class="hljs-number">1</span>, rest);<br>        <span class="hljs-comment">// 可能性2，要使用arr[i]</span><br>        <span class="hljs-type">int</span> p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= rest) &#123;<br>            p2 = arr[i] + process(arr, i + <span class="hljs-number">1</span>, rest - arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max(p1, p2);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 动态规划解法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.size() &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        sum += num;<br>    &#125;<br>    sum /= <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-type">int</span> N = arr.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(sum + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= sum; rest++) &#123;<br>            <span class="hljs-comment">// 可能性1，不使用arr[i]</span><br>            <span class="hljs-type">int</span> p1 = dp[i + <span class="hljs-number">1</span>][rest];<br>            <span class="hljs-comment">// 可能性2，要使用arr[i]</span><br>            <span class="hljs-type">int</span> p2 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= rest) &#123;<br>                p2 = arr[i] + dp[i + <span class="hljs-number">1</span>][rest - arr[i]];<br>            &#125;<br>            dp[i][rest] = max(p1, p2);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][sum];<br>&#125;<br><br><span class="hljs-comment">// 生成随机数组</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">randomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> len, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(len)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        arr[i] = rand() % value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 打印数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 初始化随机数生成器</span><br><br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> maxValue = <span class="hljs-number">50</span>;<br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-type">int</span> len = rand() % maxLen;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = randomArray(len, maxValue);<br>        <br>        <span class="hljs-type">int</span> ans1 = right(arr);<br>        <span class="hljs-type">int</span> ans2 = dp(arr);<br>        <br>        <span class="hljs-keyword">if</span> (ans1 != ans2) &#123;<br>            printArray(arr);<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;正确的答案: &quot;</span> &lt;&lt; ans1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;动态规划的答案: &quot;</span> &lt;&lt; ans2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Oops!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试结束&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="返回最接近的两个集合里较小的累加和（限制长度）"><a href="#返回最接近的两个集合里较小的累加和（限制长度）" class="headerlink" title="返回最接近的两个集合里较小的累加和（限制长度）"></a>返回最接近的两个集合里较小的累加和（限制长度）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 递归函数：选择子数组的元素，使得总和尽量接近rest但不超过rest</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> picks, <span class="hljs-type">int</span> rest)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == arr.size()) &#123;  <span class="hljs-comment">// 如果所有元素都遍历完了</span><br>        <span class="hljs-comment">// 判断当前挑选的元素数量是否符合条件</span><br>        <span class="hljs-keyword">if</span> ((arr.size() &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (picks == (arr.size() &gt;&gt; <span class="hljs-number">1</span>)) ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果是偶数个元素，挑选一半</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (picks == (arr.size() &gt;&gt; <span class="hljs-number">1</span>) || picks == (arr.size() &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果是奇数个元素，可以挑选半个或半个+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 选择不使用当前元素</span><br>    <span class="hljs-type">int</span> p1 = process(arr, i + <span class="hljs-number">1</span>, picks, rest);<br>    <span class="hljs-comment">// 选择使用当前元素</span><br>    <span class="hljs-type">int</span> p2 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> next2 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt;= rest) &#123;  <span class="hljs-comment">// 如果当前元素不超过剩余的容量</span><br>        next2 = process(arr, i + <span class="hljs-number">1</span>, picks + <span class="hljs-number">1</span>, rest - arr[i]);  <span class="hljs-comment">// 继续递归，挑选下一个元素</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (next2 != <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 如果选择了当前元素</span><br>        p2 = arr[i] + next2;  <span class="hljs-comment">// 加上当前元素的值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(p1, p2);  <span class="hljs-comment">// 返回两种选择中的最大值</span><br>&#125;<br><br><br><span class="hljs-comment">// 动态规划函数1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty() || arr.size() &lt; <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 如果数组为空或者只有一个元素，返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算数组元素的总和，并计算目标的最大和（sum / 2）</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        sum += num;<br>    &#125;<br>    sum &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 计算一半的总和</span><br><br>    <span class="hljs-type">int</span> N = arr.size();  <span class="hljs-comment">// 数组的大小</span><br>    <span class="hljs-type">int</span> M = (arr.size() + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最大挑选的元素数量</span><br><br>    <span class="hljs-comment">// 使用三维DP数组，dp[i][j][k]表示从第i个元素开始，挑选了j个元素，总和为k的最大值</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; dp(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;(M + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(sum + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= sum; k++) &#123;<br>        dp[N][M][k] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 终止条件：如果已经遍历完所有元素，且挑选了最大数量的元素，总和为k</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果数组大小是奇数，允许挑选数量为M-1的情况</span><br>    <span class="hljs-keyword">if</span> ((arr.size() &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= sum; k++) &#123;<br>            dp[N][M - <span class="hljs-number">1</span>][k] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从后往前填充DP数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> picks = <span class="hljs-number">0</span>; picks &lt;= M; picks++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">0</span>; rest &lt;= sum; rest++) &#123;<br>                <span class="hljs-type">int</span> p1 = dp[i + <span class="hljs-number">1</span>][picks][rest];  <span class="hljs-comment">// 不选择当前元素的情况</span><br>                <span class="hljs-type">int</span> p2 = <span class="hljs-number">-1</span>;<br>                <span class="hljs-type">int</span> next2 = <span class="hljs-number">-1</span>;<br>                <span class="hljs-comment">// 如果当前元素可以选择，并且剩余数量符合要求，选择当前元素</span><br>                <span class="hljs-keyword">if</span> (picks + <span class="hljs-number">1</span> &lt;= M &amp;&amp; arr[i] &lt;= rest) &#123;<br>                    next2 = dp[i + <span class="hljs-number">1</span>][picks + <span class="hljs-number">1</span>][rest - arr[i]];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (next2 != <span class="hljs-number">-1</span>) &#123;<br>                    p2 = arr[i] + next2;  <span class="hljs-comment">// 加上当前元素的值</span><br>                &#125;<br>                dp[i][picks][rest] = max(p1, p2);  <span class="hljs-comment">// 选择最大值</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][sum];  <span class="hljs-comment">// 返回结果</span><br>&#125;<br><br><br><br><span class="hljs-comment">// 动态规划函数2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dp2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty() || arr.size() &lt; <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 如果数组为空或者只有一个元素，返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算数组元素的总和，并计算目标的最大和（sum / 2）</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        sum += num;<br>    &#125;<br>    sum &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 计算一半的总和</span><br>    <span class="hljs-type">int</span> N = arr.size();  <span class="hljs-comment">// 数组的大小</span><br>    <span class="hljs-type">int</span> M = (arr.size() + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最大挑选的元素数量</span><br>    <span class="hljs-comment">// 使用三维DP数组，dp[i][j][k]表示从第i个元素开始，挑选了j个元素，总和为k的最大值</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; dp(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;(M + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(sum + <span class="hljs-number">1</span>, INT_MIN)));<br>    <span class="hljs-comment">// 初始化DP数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= sum; k++) &#123;<br>            dp[i][<span class="hljs-number">0</span>][k] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果没有挑选元素，和为0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 初始化第一个元素的情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= sum; k++) &#123;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][k] = (arr[<span class="hljs-number">0</span>] &lt;= k ? arr[<span class="hljs-number">0</span>] : INT_MIN);<br>    &#125;<br>    <span class="hljs-comment">// 填充DP数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= min(i + <span class="hljs-number">1</span>, M); j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= sum; k++) &#123;<br>                dp[i][j][k] = dp[i - <span class="hljs-number">1</span>][j][k];  <span class="hljs-comment">// 不选择当前元素的情况</span><br>                <span class="hljs-keyword">if</span> (k - arr[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j][k] = max(dp[i][j][k], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][k - arr[i]] + arr[i]);  <span class="hljs-comment">// 选择当前元素</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(dp[N - <span class="hljs-number">1</span>][M][sum], dp[N - <span class="hljs-number">1</span>][N - M][sum]);  <span class="hljs-comment">// 返回最大值</span><br>&#125;<br><span class="hljs-comment">// 封装的递归方法，用来选择子数组的元素，使得总和尽量接近sum / 2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">right</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.empty() || arr.size() &lt; <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 如果数组为空或者只有一个元素，返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算总和</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> process(arr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, sum &gt;&gt; <span class="hljs-number">1</span>);  <span class="hljs-comment">// 调用递归函数</span><br>&#125;<br><br><br><span class="hljs-comment">// 随机生成一个数组</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">randomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> len, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(len)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        arr[i] = rand() % value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 打印数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxLen = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 最大数组长度</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxValue = <span class="hljs-number">50</span>;  <span class="hljs-comment">// 数组中元素的最大值</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> testTime = <span class="hljs-number">10000</span>;  <span class="hljs-comment">// 测试次数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-type">int</span> len = rand() % maxLen;  <span class="hljs-comment">// 随机生成数组长度</span><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = randomArray(len, maxValue);  <span class="hljs-comment">// 生成随机数组</span><br><br>        <span class="hljs-type">int</span> ans1 = right(arr);  <span class="hljs-comment">// 使用递归方法计算结果</span><br>        <span class="hljs-type">int</span> ans2 = dp1(arr);  <span class="hljs-comment">// 使用动态规划方法1计算结果</span><br>        <span class="hljs-type">int</span> ans3 = dp2(arr);  <span class="hljs-comment">// 使用动态规划方法2计算结果</span><br><br>        <span class="hljs-comment">// 如果三种方法返回的结果不一致，输出数组和结果</span><br>        <span class="hljs-keyword">if</span> (ans1 != ans2 || ans1 != ans3) &#123;<br>            printArray(arr);<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;right: &quot;</span> &lt;&lt; ans1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;dp1: &quot;</span> &lt;&lt; ans2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;dp2: &quot;</span> &lt;&lt; ans3 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Oops!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试结束&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 方法 1：使用递归回溯求解 N 皇后问题</span><br><span class="hljs-comment">// 返回所有合法的放置方法数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">num1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果 n 小于 1，直接返回 0</span><br>    &#125;<br>    <span class="hljs-comment">// 创建记录皇后位置的数组，record[i] = j 表示第 i 行的皇后放置在第 j 列</span><br>    <span class="hljs-type">int</span> record[n];<br>    <span class="hljs-keyword">return</span> process1(<span class="hljs-number">0</span>, record, n);  <span class="hljs-comment">// 从第 0 行开始递归</span><br>&#125;<br><br><span class="hljs-comment">// 递归函数，处理第 i 行的皇后放置</span><br><span class="hljs-comment">// i 表示当前处理的行，record 数组记录每一行皇后的位置，n 为皇后的数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process1</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> record[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == n) &#123;  <span class="hljs-comment">// 如果已经放置完所有皇后，说明是一种合法解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用于累加合法解的数量</span><br>    <span class="hljs-comment">// 遍历当前行 i 的所有列，尝试将皇后放置在不同的列 j</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (isValid(record, i, j)) &#123;  <span class="hljs-comment">// 如果放置在 (i, j) 位置合法</span><br>            record[i] = j;  <span class="hljs-comment">// 将皇后放置在 (i, j) 位置</span><br>            res += process1(i + <span class="hljs-number">1</span>, record, n);  <span class="hljs-comment">// 递归放置下一行的皇后</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 检查当前放置在 (i, j) 位置的皇后是否与之前的皇后冲突</span><br><span class="hljs-comment">// record 数组记录每一行皇后的位置</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> record[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-comment">// 检查 0..i-1 行中的每一个皇后是否和 (i, j) 冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; i; k++) &#123;<br>        <span class="hljs-keyword">if</span> (j == record[k] || <span class="hljs-built_in">abs</span>(record[k] - j) == <span class="hljs-built_in">abs</span>(i - k)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果同列或者同对角线，返回 false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 如果没有冲突，返回 true</span><br>&#125;<br><br><span class="hljs-comment">// 方法 2：使用位运算优化 N 皇后问题</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">num2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || n &gt; <span class="hljs-number">32</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果 n 小于 1 或者大于 32，返回 0</span><br>    &#125;<br>    <span class="hljs-comment">// limit: 32 位的全 1，用于表示每列是否可用，最多支持 32 皇后问题</span><br>    <span class="hljs-type">int</span> limit = (n == <span class="hljs-number">32</span>) ? <span class="hljs-number">-1</span> : (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 计算列可用的位掩码</span><br>    <span class="hljs-keyword">return</span> process2(limit, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 调用位运算的递归方法</span><br>&#125;<br><br><span class="hljs-comment">// 位运算递归方法</span><br><span class="hljs-comment">// limit: 限制列的掩码，colLim: 已经被占用的列，leftDiaLim: 已经被占用的左下对角线，rightDiaLim: 已经被占用的右下对角线</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process2</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> colLim, <span class="hljs-type">int</span> leftDiaLim, <span class="hljs-type">int</span> rightDiaLim)</span> &#123;<br>    <span class="hljs-keyword">if</span> (colLim == limit) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果所有列都被占用，说明已经放置完所有皇后</span><br>    &#125;<br>    <span class="hljs-comment">// pos: 当前可以放置皇后的所有位置，取 limit - colLim - leftDiaLim - rightDiaLim</span><br>    <span class="hljs-type">int</span> pos = limit &amp; (~(colLim | leftDiaLim | rightDiaLim));  <span class="hljs-comment">// 可以放置皇后的列</span><br>    <span class="hljs-type">int</span> mostRightOne = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用于累加合法解的数量</span><br>    <span class="hljs-keyword">while</span> (pos != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 处理当前可以放置皇后的列</span><br>        <span class="hljs-comment">// 取 pos 中最右边的 1 作为要放置皇后的位置</span><br>        mostRightOne = pos &amp; (~pos + <span class="hljs-number">1</span>);<br>        pos = pos - mostRightOne;  <span class="hljs-comment">// 将 pos 中该位置清零，准备处理下一个位置</span><br>        <span class="hljs-comment">// 递归放置皇后</span><br>        res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) &lt;&lt; <span class="hljs-number">1</span>, (rightDiaLim | mostRightOne) &gt;&gt; <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回合法解的数量</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">15</span>;  <span class="hljs-comment">// 设置皇后的数量</span><br><br>    <span class="hljs-comment">// 测试方法 2</span><br>    <span class="hljs-type">long</span> start = clock();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; num2(n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-type">long</span> end = clock();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Method 2 cost time: &quot;</span> &lt;&lt; (end - start) * <span class="hljs-number">1000.0</span> / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-comment">// 测试方法 1</span><br>    start = clock();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; num1(n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    end = clock();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Method 1 cost time: &quot;</span> &lt;&lt; (end - start) * <span class="hljs-number">1000.0</span> / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="最大为N的数字组合"><a href="#最大为N的数字组合" class="headerlink" title="最大为N的数字组合"></a>最大为N的数字组合</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 最大为N的数字组合</span><br><span class="hljs-comment">// 给定一个按 非递减顺序 排列的数字数组 digits</span><br><span class="hljs-comment">// 已知digits一定不包含&#x27;0&#x27;，可能包含&#x27;1&#x27; ~ &#x27;9&#x27;，且无重复字符</span><br><span class="hljs-comment">// 你可以用任意次数 digits[i] 来写的数字</span><br><span class="hljs-comment">// 例如，如果 digits = [&#x27;1&#x27;,&#x27;3&#x27;,&#x27;5&#x27;]</span><br><span class="hljs-comment">// 我们可以写数字，如 &#x27;13&#x27;, &#x27;551&#x27;, 和 &#x27;1351315&#x27;</span><br><span class="hljs-comment">// 返回 可以生成的小于或等于给定整数 n 的正整数的个数</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">// offset是辅助变量，完全由len决定，只是为了方便提取num中某一位数字，不是关键变量</span><br>	<span class="hljs-comment">// 还剩下len位没有决定</span><br>	<span class="hljs-comment">// 如果之前的位已经确定比num小，那么free == 1，表示接下的数字可以自由选择</span><br>	<span class="hljs-comment">// 如果之前的位和num一样，那么free == 0，表示接下的数字不能大于num当前位的数字</span><br>	<span class="hljs-comment">// 如果之前的位没有使用过数字，fix == 0</span><br>	<span class="hljs-comment">// 如果之前的位已经使用过数字，fix == 1</span><br>	<span class="hljs-comment">// 返回最终&lt;=num的可能性有多少种</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; digits, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>, <span class="hljs-type">int</span> fix)</span> &#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> fix == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// num在当前位的数字</span><br>    <span class="hljs-type">int</span> cur = (num / offset) % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (fix == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 之前从来没有选择过数字</span><br>        <span class="hljs-comment">// 当前依然可以不要任何数字，累加后续的可能性</span><br>        ans += f1(digits, num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 不能自由选择的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : digits) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; cur) &#123;<br>                ans += f1(digits, num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == cur) &#123;<br>                ans += f1(digits, num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// i &gt; cur</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 可以自由选择的情况</span><br>        ans += digits.size() * f1(digits, num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">atMostNGivenDigitSet1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-type">int</span> tmp = num / <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (tmp &gt; <span class="hljs-number">0</span>) &#123;<br>        tmp /= <span class="hljs-number">10</span>;<br>        len++;<br>        offset *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> m = strs.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">digits</span><span class="hljs-params">(m)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        digits[i] = stoi(strs[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> f1(digits, num, offset, len, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; digits, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; cnt, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// num自己</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cur是num当前位的数字</span><br>    <span class="hljs-type">int</span> cur = (num / offset) % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : digits) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; cur) &#123;<br>            ans += cnt[len - <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == cur) &#123;<br>            ans += f2(digits, cnt, num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">atMostNGivenDigitSet2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-type">int</span> m = strs.size();<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">digits</span><span class="hljs-params">(m)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        digits[i] = stoi(strs[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmp = num / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (tmp &gt; <span class="hljs-number">0</span>) &#123;<br>        tmp /= <span class="hljs-number">10</span>;<br>        len++;<br>        offset *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// cnt[i] : 已知前缀比num小，剩下i位没有确定，请问前缀确定的情况下，一共有多少种数字排列</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">cnt</span><span class="hljs-params">(len)</span>;<br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m, k = <span class="hljs-number">1</span>; k &lt; len; k++, i *= m) &#123;<br>        cnt[k] = i;<br>        ans += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans + f2(digits, cnt, num, offset, len);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strs = &#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result from atMostNGivenDigitSet1: &quot;</span> &lt;&lt; atMostNGivenDigitSet1(strs, num) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result from atMostNGivenDigitSet2: &quot;</span> &lt;&lt; atMostNGivenDigitSet2(strs, num) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="统计整数数目"><a href="#统计整数数目" class="headerlink" title="统计整数数目"></a>统计整数数目</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 统计整数数目</span><br><span class="hljs-comment">// 给你两个数字字符串 num1 和 num2 ，以及两个整数max_sum和min_sum</span><br><span class="hljs-comment">// 如果一个整数 x 满足以下条件，我们称它是一个好整数</span><br><span class="hljs-comment">// num1 &lt;= x &lt;= num2</span><br><span class="hljs-comment">// min_sum &lt;= digit_sum(x) &lt;= max_sum</span><br><span class="hljs-comment">// 请你返回好整数的数目</span><br><span class="hljs-comment">// 答案可能很大，答案对 1000000007 取模</span><br><span class="hljs-comment">// 注意，digit_sum(x)表示x各位数字之和</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">23</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">401</span>;<br><br><span class="hljs-type">int</span> dp[MAXN][MAXM][<span class="hljs-number">2</span>];<br><br><span class="hljs-type">char</span> num[MAXN];<br><span class="hljs-type">int</span> min_sum, max_sum, len;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= max_sum; j++) &#123;<br>            dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>            dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>	<span class="hljs-comment">// 注意：</span><br>	<span class="hljs-comment">// 数字，char[] num</span><br>	<span class="hljs-comment">// 数字长度，int len</span><br>	<span class="hljs-comment">// 累加和最小要求，int min</span><br>	<span class="hljs-comment">// 累加和最大要求，int max</span><br>	<span class="hljs-comment">// 这四个变量都是全局静态变量，所以不用带参数，直接访问即可</span><br>	<span class="hljs-comment">// 递归含义：</span><br>	<span class="hljs-comment">// 从num的高位出发，当前来到i位上</span><br>	<span class="hljs-comment">// 之前决定的数字累加和是sum</span><br>	<span class="hljs-comment">// 之前的决定已经比num小，后续可以自由选择数字，那么free == 1</span><br>	<span class="hljs-comment">// 之前的决定和num一样，后续不可以自由选择数字，那么free == 0</span><br>	<span class="hljs-comment">// 返回有多少种可能性</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sum &gt; max_sum) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum + (len - i) * <span class="hljs-number">9</span> &lt; min_sum) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == len) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[i][sum][<span class="hljs-built_in">free</span>] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[i][sum][<span class="hljs-built_in">free</span>];<br>    &#125;<br><br>    <span class="hljs-type">int</span> cur = num[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 还不能自由选择</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pick = <span class="hljs-number">0</span>; pick &lt; cur; pick++) &#123;<br>            ans = (ans + f(i + <span class="hljs-number">1</span>, sum + pick, <span class="hljs-number">1</span>)) % MOD;<br>        &#125;<br>        ans = (ans + f(i + <span class="hljs-number">1</span>, sum + cur, <span class="hljs-number">0</span>)) % MOD;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 可以自由选择</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pick = <span class="hljs-number">0</span>; pick &lt;= <span class="hljs-number">9</span>; pick++) &#123;<br>            ans = (ans + f(i + <span class="hljs-number">1</span>, sum + pick, <span class="hljs-number">1</span>)) % MOD;<br>        &#125;<br>    &#125;<br>    dp[i][sum][<span class="hljs-built_in">free</span>] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        sum += num[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum &gt;= min_sum &amp;&amp; sum &lt;= max_sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; num1, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; num2, <span class="hljs-type">int</span> min_sum, <span class="hljs-type">int</span> max_sum)</span> &#123;<br>    ::min_sum = min_sum;<br>    ::max_sum = max_sum;<br>    <span class="hljs-built_in">strcpy</span>(num, num2.c_str());<br>    len = num2.length();<br>    build();<br>    <span class="hljs-type">int</span> ans = f(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-built_in">strcpy</span>(num, num1.c_str());<br>    len = num1.length();<br>    build();<br>    ans = (ans - f(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) + MOD) % MOD;<br>    <br>    <span class="hljs-keyword">if</span> (check()) &#123;<br>        ans = (ans + <span class="hljs-number">1</span>) % MOD;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">string</span> num1 = <span class="hljs-string">&quot;100&quot;</span>;<br>    <span class="hljs-built_in">string</span> num2 = <span class="hljs-string">&quot;500&quot;</span>;<br>    <span class="hljs-type">int</span> min_sum = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> max_sum = <span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; count(num1, num2, min_sum, max_sum) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="完全没有重复的数字个数"><a href="#完全没有重复的数字个数" class="headerlink" title="完全没有重复的数字个数"></a>完全没有重复的数字个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmp = n / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (tmp &gt; <span class="hljs-number">0</span>) &#123;<br>        len++;<br>        offset *= <span class="hljs-number">10</span>;<br>        tmp /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// cnt[i] :</span><br>    <span class="hljs-comment">// 一共长度为len，还剩i位没有确定，确定的前缀为len-i位，且确定的前缀不为空</span><br>    <span class="hljs-comment">// 0~9一共10个数字，没有选择的数字剩下10-(len-i)个</span><br>    <span class="hljs-comment">// 那么在后续的i位上，有多少种排列</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">cnt</span><span class="hljs-params">(len)</span>;<br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, k = <span class="hljs-number">10</span> - len + <span class="hljs-number">1</span>; i &lt; len; i++, k++) &#123;<br>        cnt[i] = cnt[i - <span class="hljs-number">1</span>] * k;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 如果n的位数是len位，先计算位数少于len的数中，每一位都互不相同的正整数个数，并累加</span><br>        <span class="hljs-comment">// 所有1位数中，每一位都互不相同的正整数个数 = 9</span><br>        <span class="hljs-comment">// 所有2位数中，每一位都互不相同的正整数个数 = 9 * 9</span><br>        <span class="hljs-comment">// 所有3位数中，每一位都互不相同的正整数个数 = 9 * 9 * 8</span><br>        <span class="hljs-comment">// 所有4位数中，每一位都互不相同的正整数个数 = 9 * 9 * 8 * 7</span><br>        <span class="hljs-comment">// ...比len少的位数都累加...</span><br>        ans = <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, a = <span class="hljs-number">9</span>, b = <span class="hljs-number">9</span>; i &lt; len; i++, b--) &#123;<br>            a *= b;<br>            ans += a;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果n的位数是len位，已经计算了位数少于len个的情况</span><br>    <span class="hljs-comment">// 下面计算一定有len位的数字中，&lt;=n且每一位都互不相同的正整数个数</span><br>    <span class="hljs-type">int</span> first = n / offset;<br>    <span class="hljs-comment">// 小于num最高位数字的情况</span><br>    ans += (first - <span class="hljs-number">1</span>) * cnt[len - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 后续累加上，等于num最高位数字的情况</span><br>    ans += f(cnt, n, len - <span class="hljs-number">1</span>, offset / <span class="hljs-number">10</span>, <span class="hljs-number">1</span> &lt;&lt; first);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 之前已经确定了和num一样的前缀，且确定的部分一定不为空</span><br><span class="hljs-comment">// 还有len位没有确定</span><br><span class="hljs-comment">// 哪些数字已经选了，哪些数字没有选，用status表示</span><br><span class="hljs-comment">// 返回&lt;=num且每一位数字都不一样的正整数有多少个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; cnt, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> status)</span> &#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// num自己</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// first是num当前位的数字</span><br>    <span class="hljs-type">int</span> first = (num / offset) % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>; cur &lt; first; cur++) &#123;<br>        <span class="hljs-keyword">if</span> ((status &amp; (<span class="hljs-number">1</span> &lt;&lt; cur)) == <span class="hljs-number">0</span>) &#123;<br>            ans += cnt[len - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((status &amp; (<span class="hljs-number">1</span> &lt;&lt; first)) == <span class="hljs-number">0</span>) &#123;<br>        ans += f(cnt, num, len - <span class="hljs-number">1</span>, offset / <span class="hljs-number">10</span>, status | (<span class="hljs-number">1</span> &lt;&lt; first));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; countSpecialNumbers(n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="至少有1位重复的数字个数"><a href="#至少有1位重复的数字个数" class="headerlink" title="至少有1位重复的数字个数"></a>至少有1位重复的数字个数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 至少有1位重复的数字个数</span><br><span class="hljs-comment">// 给定正整数n，返回在[1, n]范围内至少有1位重复数字的正整数个数</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmp = n / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (tmp &gt; <span class="hljs-number">0</span>) &#123;<br>        len++;<br>        offset *= <span class="hljs-number">10</span>;<br>        tmp /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// cnt[i] : 一共长度为len，还剩i位没有确定，确定的前缀为len-i位，且确定的前缀不为空</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">cnt</span><span class="hljs-params">(len)</span>;<br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, k = <span class="hljs-number">10</span> - len + <span class="hljs-number">1</span>; i &lt; len; i++, k++) &#123;<br>        cnt[i] = cnt[i - <span class="hljs-number">1</span>] * k;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) &#123;<br>        ans = <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, a = <span class="hljs-number">9</span>, b = <span class="hljs-number">9</span>; i &lt; len; i++, b--) &#123;<br>            a *= b;<br>            ans += a;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> first = n / offset;<br>    <span class="hljs-comment">// 小于num最高位数字的情况</span><br>    ans += (first - <span class="hljs-number">1</span>) * cnt[len - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 后续累加上，等于num最高位数字的情况</span><br>    ans += f(cnt, n, len - <span class="hljs-number">1</span>, offset / <span class="hljs-number">10</span>, <span class="hljs-number">1</span> &lt;&lt; first);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 之前已经确定了和num一样的前缀，且确定的部分一定不为空</span><br><span class="hljs-comment">// 还有len位没有确定</span><br><span class="hljs-comment">// 哪些数字已经选了，哪些数字没有选，用status表示</span><br><span class="hljs-comment">// 返回&lt;=num且每一位数字都不一样的正整数有多少个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; cnt, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> status)</span> &#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> first = (num / offset) % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>; cur &lt; first; cur++) &#123;<br>        <span class="hljs-keyword">if</span> ((status &amp; (<span class="hljs-number">1</span> &lt;&lt; cur)) == <span class="hljs-number">0</span>) &#123;<br>            ans += cnt[len - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((status &amp; (<span class="hljs-number">1</span> &lt;&lt; first)) == <span class="hljs-number">0</span>) &#123;<br>        ans += f(cnt, num, len - <span class="hljs-number">1</span>, offset / <span class="hljs-number">10</span>, status | (<span class="hljs-number">1</span> &lt;&lt; first));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numDupDigitsAtMostN</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> n - countSpecialNumbers(n);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; numDupDigitsAtMostN(n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="windy数"><a href="#windy数" class="headerlink" title="windy数"></a>windy数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXLEN = <span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> dp[MAXLEN][<span class="hljs-number">11</span>][<span class="hljs-number">2</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">10</span>; j++) &#123;<br>            dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>            dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> pre, <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[len][pre][<span class="hljs-built_in">free</span>] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[len][pre][<span class="hljs-built_in">free</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> cur = num / offset % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 之前的位和num一样，此时不能随意选择数字</span><br>            <span class="hljs-comment">// 也从来没有选择过数字</span><br>            <span class="hljs-comment">// 就表示：来到的是num的最高位</span><br>            ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 一个数字也不要</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cur; i++) &#123;<br>                ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);<br>            &#125;<br>            ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, cur, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 之前的位和num一样，此时不能随意选择数字，</span><br>            <span class="hljs-comment">// 之前选择过数字pre</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i &lt;= pre - <span class="hljs-number">2</span> || i &gt;= pre + <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i &lt; cur) &#123;<br>                        ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == cur) &#123;<br>                        ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, cur, <span class="hljs-number">0</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// free == 1，可以自由选择数字，前面的状况 &lt; num</span><br>            <span class="hljs-comment">// 从来没有选择过数字</span><br>            ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 还是可以不选择数字</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>                ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// free == 1，可以自由选择数字，前面的状况 &lt; num</span><br>            <span class="hljs-comment">// 选择过数字pre</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i &lt;= pre - <span class="hljs-number">2</span> || i &gt;= pre + <span class="hljs-number">2</span>) &#123;<br>                    ans += f(num, offset / <span class="hljs-number">10</span>, len - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    dp[len][pre][<span class="hljs-built_in">free</span>] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmp = num / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (tmp &gt; <span class="hljs-number">0</span>) &#123;<br>        len++;<br>        offset *= <span class="hljs-number">10</span>;<br>        tmp /= <span class="hljs-number">10</span>;<br>    &#125;<br>    build(len);<br>    <span class="hljs-keyword">return</span> f(num, offset, len, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">compute</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> cnt(b) - cnt(a - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; compute(a, b) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="萌数"><a href="#萌数" class="headerlink" title="萌数"></a>萌数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1001</span>;<br><br><span class="hljs-type">int</span> dp[MAXN][<span class="hljs-number">11</span>][<span class="hljs-number">11</span>][<span class="hljs-number">2</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; n; a++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt;= <span class="hljs-number">10</span>; b++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt;= <span class="hljs-number">10</span>; c++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt;= <span class="hljs-number">1</span>; d++) &#123;<br>                    dp[a][b][c][d] = <span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; num, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> pp, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == num.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[i][pp][p][<span class="hljs-built_in">free</span>] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[i][pp][p][<span class="hljs-built_in">free</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 当前来到的就是num的最高位</span><br>            ans = (ans + f(num, i + <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)) % MOD; <span class="hljs-comment">// 当前位不选数字</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>; cur &lt; num[i] - <span class="hljs-string">&#x27;0&#x27;</span>; cur++) &#123;<br>                ans = (ans + f(num, i + <span class="hljs-number">1</span>, p, cur, <span class="hljs-number">1</span>)) % MOD;<br>            &#125;<br>            ans = (ans + f(num, i + <span class="hljs-number">1</span>, p, num[i] - <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">0</span>)) % MOD;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// free == 0，之前和num一样，此时不能自由选择数字</span><br>            <span class="hljs-comment">// 前一位p，选择过数字，p -&gt; 0 ~ 9</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>; cur &lt; num[i] - <span class="hljs-string">&#x27;0&#x27;</span>; cur++) &#123;<br>                <span class="hljs-keyword">if</span> (pp != cur &amp;&amp; p != cur) &#123;<br>                    ans = (ans + f(num, i + <span class="hljs-number">1</span>, p, cur, <span class="hljs-number">1</span>)) % MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pp != num[i] - <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; p != num[i] - <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                ans = (ans + f(num, i + <span class="hljs-number">1</span>, p, num[i] - <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">0</span>)) % MOD;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// free == 1，能自由选择数字</span><br>            <span class="hljs-comment">// 从来没选过数字</span><br>            ans = (ans + f(num, i + <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)) % MOD; <span class="hljs-comment">// 依然不选数字</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>; cur &lt;= <span class="hljs-number">9</span>; cur++) &#123;<br>                ans = (ans + f(num, i + <span class="hljs-number">1</span>, p, cur, <span class="hljs-number">1</span>)) % MOD;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// free == 1，能自由选择数字</span><br>            <span class="hljs-comment">// 之前选择过数字</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>; cur &lt;= <span class="hljs-number">9</span>; cur++) &#123;<br>                <span class="hljs-keyword">if</span> (pp != cur &amp;&amp; p != cur) &#123;<br>                    ans = (ans + f(num, i + <span class="hljs-number">1</span>, p, cur, <span class="hljs-number">1</span>)) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    dp[i][pp][p][<span class="hljs-built_in">free</span>] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; num)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pp = <span class="hljs-number">-2</span>, p = <span class="hljs-number">-1</span>, i = <span class="hljs-number">0</span>; i &lt; num.size(); pp++, p++, i++) &#123;<br>        <span class="hljs-keyword">if</span> (pp &gt;= <span class="hljs-number">0</span> &amp;&amp; num[pp] == num[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span> &amp;&amp; num[p] == num[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cnt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; num)</span> &#123;<br>    <span class="hljs-keyword">if</span> (num[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> n = num.size();<br>    <span class="hljs-type">long</span> all = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> base = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        all = (all + base * (num[i] - <span class="hljs-string">&#x27;0&#x27;</span>)) % MOD;<br>        base = (base * <span class="hljs-number">10</span>) % MOD;<br>    &#125;<br>    build(n);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((all - f(num, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>) + MOD) % MOD);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">compute</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; l, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&amp; r)</span> &#123;<br>    <span class="hljs-type">int</span> ans = (cnt(r) - cnt(l) + MOD) % MOD;<br>    <span class="hljs-keyword">if</span> (check(l)) &#123;<br>        ans = (ans + <span class="hljs-number">1</span>) % MOD;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">string</span> l, r;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; r;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">l_vec</span><span class="hljs-params">(l.begin(), l.end())</span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title function_">r_vec</span><span class="hljs-params">(r.begin(), r.end())</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; compute(l_vec, r_vec) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="不含连续1的非负整数"><a href="#不含连续1的非负整数" class="headerlink" title="不含连续1的非负整数"></a>不含连续1的非负整数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 给定一个正整数n，请你统计在[0, n]范围的非负整数中</span><br><span class="hljs-comment">// 有多少个整数的二进制表示中不存在连续的1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">findIntegers1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">cnt</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>;<br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    cnt[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= <span class="hljs-number">30</span>; len++) &#123;<br>        cnt[len] = cnt[len - <span class="hljs-number">1</span>] + cnt[len - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> f(cnt, n, <span class="hljs-number">30</span>);<br>&#125;<br><br><span class="hljs-comment">// cnt[len] : 二进制如果有len位，所有二进制状态中不存在连续的1的状态有多少个，辅助数组</span><br><span class="hljs-comment">// 从num二进制形式的高位开始，当前来到第i位，之前的位完全和num一样</span><br><span class="hljs-comment">// 返回&lt;=num且不存在连续的1的状态有多少个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; cnt, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// num自身合法</span><br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ((num &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;<br>        ans += cnt[i];<br>        <span class="hljs-keyword">if</span> ((num &amp; (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>))) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果num二进制状态，前一位是1，当前位也是1</span><br>            <span class="hljs-comment">// 如果前缀保持和num一样，后续一定不合法了</span><br>            <span class="hljs-comment">// 所以提前返回</span><br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 之前的高位和num一样，且合法，继续去i-1位递归</span><br>    ans += f(cnt, num, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">findIntegers2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">cnt</span><span class="hljs-params">(<span class="hljs-number">31</span>)</span>;<br>    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    cnt[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= <span class="hljs-number">30</span>; len++) &#123;<br>        cnt[len] = cnt[len - <span class="hljs-number">1</span>] + cnt[len - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">-1</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) &#123;<br>            ans++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((n &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;<br>            ans += cnt[i];<br>            <span class="hljs-keyword">if</span> ((n &amp; (<span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>))) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result from findIntegers1: &quot;</span> &lt;&lt; findIntegers1(n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result from findIntegers2: &quot;</span> &lt;&lt; findIntegers2(n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">opt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化：兑换金额为0时，不需要任何硬币</span><br><br><span class="hljs-comment">// 阶段（线性增长）：从1逐步增加到目标金额amount</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>    opt[i] = INF; <span class="hljs-comment">// 设置当前金额i的最少硬币数量为一个极大值（用INF表示），方便后续比较取最小值</span><br><br>    <span class="hljs-comment">// 决策（找到子问题）：遍历每个硬币面值，找到凑成当前金额的最优方案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<br>        <span class="hljs-keyword">if</span> (i - coins[j] &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 判断是否可以用当前硬币凑成当前金额</span><br>            <span class="hljs-comment">// 状态（具有最优子结构）：选择最小的硬币数量，确保当前金额的最优解</span><br>            opt[i] = Math.<span class="hljs-built_in">min</span>(opt[i], opt[i - coins[j]] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*无论是递推实现还是记忆化搜索(递归实现)这种定义状态+最优子结构+推导关系的解题方法其实就是 动态规划 算法</span><br><span class="hljs-comment">1.问题定义：</span><br><span class="hljs-comment">设 opt[i] 表示凑成金额 i 所需的最少硬币数量。确定“状态”的原则:寻找变化信息</span><br><span class="hljs-comment">2.状态转移方程：</span><br><span class="hljs-comment">对于每个金额 i，我们可以通过以下公式计算 opt[i]：opt[i] = min&#123;opt[i - coin] + 1&#125; 确定“最优子结构”的原则:寻找代表</span><br><span class="hljs-comment">3.边界：opt[0]=0,opt[i]=+∞(i&gt;0)</span><br><span class="hljs-comment">4.目标：opt[amount]</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>人力模拟 &#x2F; 暴力搜索</strong>：</p>
<ul>
<li>目的是通过手动模拟问题解决过程，理解如何遍历所有可能的状态和情况。</li>
<li>关注点：<strong>轮廓变化</strong>，分析状态如何从一个转移到另一个。我们是不是考虑在列表时候就是一个行一个列，它们往后推移,因此ij作为一个状态。lcs呢?选哪个数刚选的这个末尾是不是一个位置把这个轮廓描述一下表示字符串 <code>text1</code> 的每个字符位置，列表示字符串 <code>text2</code> 的每个字符位置。每个格子 <code>(i, j)</code> 的值代表 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的LCS长度。我们从左上角 <code>(0, 0)</code> 开始计算，逐步填充整个矩阵，一直到右下角的 <code>(n, m)</code>，最终结果即 <code>f[n][m]</code>，作为一个状态之后，把决策写好，这个题目就做完了。它整体的一个变化情况就可以得到我们这个题目的转移方程了。</li>
</ul>
<p><strong>定义状态</strong>：递增循环每一维啊,</p>
<ul>
<li>确定用什么变量或数组来表示问题中的不同状态。</li>
<li>关注点：<strong>代表</strong>（如代表某个位置、子问题的解等），以及状态之间的推导关系。</li>
</ul>
<p><strong>确定最优子结构</strong>：</p>
<ul>
<li>通过找到小问题的最优解来组成大问题的最优解。</li>
<li>关注点：手动模拟时做出的决策，观察这些决策如何影响最终解。</li>
</ul>
<p><strong>写出状态转移方程</strong>：</p>
<ul>
<li>根据之前定义的状态，写出如何从一个状态转移到另一个状态，形成递推关系。</li>
</ul>
<p><strong>确定边界、目标和实现</strong>：</p>
<ul>
<li>确定边界条件（如起点和结束点）和不合法的状态。</li>
<li>目标是找到最终要求的解，并根据状态转移方程使用循环或递归来实现求解。</li>
</ul>
<p>例外</p>
<p>动态规划打印方案的原则</p>
<ol>
<li><strong>记录转移路径</strong>：在动态规划的计算过程中，我们不仅要记录每个状态的最优值，还需要记录每个状态的转移来源</li>
<li><strong>递归输出</strong>：在填完整个动态规划表格后，从终点（如 <code>f[n][m]</code>）开始，沿着记录的路径递归地输出最优方案</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// f[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// pre[i] 用于记录最长子序列中 nums[i] 的前一个元素的索引</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; f[i] &lt; f[j] + <span class="hljs-number">1</span>) &#123;<br>                    f[i] = f[j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新 f[i] 为以 nums[i] 结尾的最长子序列的长度</span><br>                    pre[i] = j; <span class="hljs-comment">// 记录转移路径，将 nums[i] 的前驱设置为 nums[j]</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, end = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (f[i] &gt; ans) &#123;<br>                ans = f[i];<br>                end = i; <span class="hljs-comment">// 记录最长子序列的最后一个元素的索引</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">print</span>(nums, pre, end); <span class="hljs-comment">// 输出最长递增子序列</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 基本情况：如果没有前驱，直接返回</span><br>        <span class="hljs-built_in">print</span>(nums, pre, pre[i]); <span class="hljs-comment">// 递归回溯，输出子序列</span><br>        std::cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出当前元素</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>空间的优化<br>仔细观察状态转移方程，fi?,?,?]总是从f[i-1)?,?,?]转移过来，与更早的i-2,i-3,…. 没有关系如果把每个 fi]看作一行，那么转移只在相邻两行之间发生这种情况下可以使用滚动数组优化,实现中，先不优化，写完以后在每个f的第一维加个&amp;1(and1，即 mod 2)注意初始化复用的空间</p>
<p>零钱兑换”的最优子结构</p>
<p><strong>目标</strong>：找到兑换某个金额所需的最少硬币数量，形成最优的硬币兑换方案。</p>
<p><strong>状态定义</strong>：</p>
<ul>
<li>记录当前的“剩余金额”和“已用硬币枚数”。</li>
<li>新状态目标为“剩余金额”以及在硬币数量最少的前提下达到目标。</li>
</ul>
<p><strong>推导关系</strong>：</p>
<ul>
<li>递推公式为：opt(n) &#x3D; min(opt(n - 1), opt(n - 9), opt(n - 10)) + 1。</li>
<li>其中，<code>opt(n)</code>表示兑换金额为n元时所需的最少硬币数，<code>opt(n - 1)</code>, <code>opt(n - 9)</code>, <code>opt(n - 10)</code>分别代表使用1元、9元和10元硬币时的剩余情况。</li>
</ul>
<p><strong>最优子结构</strong>：</p>
<ul>
<li>通过递推关系，可以在状态、最优化目标、最优解之间建立递归关系，实现零钱兑换的最优解。就是因为我们提炼搜索结构，不要去盲目的根据所有方案。而是我们去只遍历，只要那一个最有解的哎，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(std::string text1, std::string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text<span class="hljs-number">1.l</span>ength();<br>        <span class="hljs-type">int</span> n = text<span class="hljs-number">2.l</span>ength();<br>        std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="路径计数"><a href="#路径计数" class="headerlink" title="路径计数"></a>路径计数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> &#123;<br>    <span class="hljs-type">int</span> n = grid.size();            <span class="hljs-comment">// 行数</span><br>    <span class="hljs-type">int</span> m = grid[<span class="hljs-number">0</span>].size();          <span class="hljs-comment">// 列数</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; f(n, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 创建二维数组f并初始化为0</span><br><br>    <span class="hljs-comment">// 遍历每个网格位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 如果当前格子有障碍物，路径数为0</span><br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                f[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// 起点 (0, 0) 路径数为1（前提是没有障碍物）</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 第一行时，只能从左边到达</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 第一列时，只能从上面到达</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>            <span class="hljs-comment">// 其他情况，路径数等于从上方和左侧位置到达的路径数之和</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回到达终点 (n-1, m-1) 的路径数</span><br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>状态定义</p>
<ul>
<li>设 <code>f[i]</code> 表示<strong>以 <code>i</code> 为结尾</strong>的最大子序和。</li>
</ul>
<p>状态转移方程</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span> + nums<span class="hljs-selector-attr">[i]</span>, nums<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<p>其中，<code>f[i - 1] + nums[i]</code> 表示将 <code>nums[i]</code> 加入到前面的子序列中，继续延续子序和；<code>nums[i]</code> 表示以当前元素 <code>nums[i]</code> 开始一个新的子序列。</p>
<p>边界条件</p>
<p><code>f[0] = nums[0]</code>，因为以第一个元素结尾的最大子序和就是第一个元素的值。</p>
<p>目标</p>
<p>计算 max(f[i])</p>
<p>关于“包含结尾”的原因</p>
<ul>
<li>在这个问题中，状态 <code>f[i]</code> 是以 <code>i</code> 为结尾的子序列的最大和，这样可以确保子序列是连续的。</li>
<li>通过 <code>f[i - 1]</code> 决定是否延续之前的序列，从而达到最大和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// f[i] 表示以 nums[i] 结尾的最大子序和</span><br>        f[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 边界条件：以第一个元素结尾的最大子序和就是它自身</span><br>        <span class="hljs-type">int</span> ans = f[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最大子序和为第一个元素</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            f[i] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>) + nums[i]; <span class="hljs-comment">// 状态转移方程</span><br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[i]); <span class="hljs-comment">// 更新全局最大子序和</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><p>问题定义</p>
<ul>
<li>给定一个数组，找到一个具有最大乘积的连续子数组，返回该最大乘积。</li>
</ul>
<p>状态定义</p>
<ul>
<li><p>设 <code>fmax[i]</code> 表示以 <code>i</code> 为结尾的子数组的<strong>乘积最大值</strong>。</p>
</li>
<li><p>设 <code>fmin[i]</code> 表示以 <code>i</code> 为结尾的子数组的<strong>乘积最小值</strong>。</p>
<p>使用 <code>fmax</code> 和 <code>fmin</code> 一起作为代表，以保证每一步都能满足最优子结构。原因是，当当前数 <code>nums[i]</code> 为负数时，乘以之前的最小值可能会变成最大值，所以需要同时维护最大和最小值。</p>
</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><code>fmax[i] = max(fmax[i - 1] * nums[i], fmin[i - 1] * nums[i], nums[i])</code></li>
<li><code>fmin[i] = min(fmax[i - 1] * nums[i], fmin[i - 1] * nums[i], nums[i])</code><ul>
<li><code>fmax[i]</code> 是当前最大乘积，取决于前一个最大乘积乘以当前数、前一个最小乘积乘以当前数，或者当前数本身。</li>
<li><code>fmin[i]</code> 是当前最小乘积，原因是负数可能会将最小值转化为最大值，因此也需要考虑。</li>
</ul>
</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>fmax[0] = nums[0]</code></li>
<li><code>fmin[0] = nums[0]</code></li>
</ul>
<p>目标</p>
<ul>
<li>求 <code>max(fmax[i])</code>，其中 <code>0 &lt;= i &lt; n</code>，即最大乘积。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fmax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">fmin</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// fmax[i] 和 fmin[i] 分别表示以 nums[i] 结尾的最大和最小乘积</span><br>        fmax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        fmin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最大乘积为第一个元素</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            fmax[i] = std::<span class="hljs-built_in">max</span>(&#123;fmax[i - <span class="hljs-number">1</span>] * nums[i], fmin[i - <span class="hljs-number">1</span>] * nums[i], nums[i]&#125;);<br>            fmin[i] = std::<span class="hljs-built_in">min</span>(&#123;fmax[i - <span class="hljs-number">1</span>] * nums[i], fmin[i - <span class="hljs-number">1</span>] * nums[i], nums[i]&#125;);<br>            ans = std::<span class="hljs-built_in">max</span>(ans, fmax[i]); <span class="hljs-comment">// 更新全局最大乘积</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h4><p>状态定义</p>
<p>设 f[i][j][k]表示在第 i 天结束时，持有 j 股股票（j为 0 或 1），已经完成了 k次交易的最大收益。</p>
<ul>
<li><code>i</code>：第几天。</li>
<li><code>j</code>：是否持有股票（0 表示不持有，1 表示持有）。</li>
<li><code>k</code>：已经完成的交易次数。</li>
</ul>
<p>决策转移</p>
<ul>
<li><p>买入</p>
<p>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span>, f<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k-1]</span> - prices<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>如果在第 <code>i</code> 天选择买入股票，那么前一天的状态应该是不持有股票且已完成 <code>k-1</code> 次交易，并减去当天的价格 <code>prices[i]</code>。</li>
</ul>
</li>
<li><p>卖出</p>
<p>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k]</span>, f<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span> + prices<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>如果在第 <code>i</code> 天选择卖出股票，那么前一天的状态应该是持有股票且已完成 <code>k</code> 次交易，卖出后增加当天的价格 <code>prices[i]</code>。</li>
</ul>
</li>
<li><p>保持</p>
<p>：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[k]</span> = f<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[k]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>不进行买卖操作，保持前一天的状态。</li>
</ul>
</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>f[0][0][0] = 0</code> 表示在第 0 天，没有进行任何交易且不持有股票的情况下，利润为 0。</li>
<li>其余的边界值都初始化为负无穷，表示在开始时这些状态不合法或不可达。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> c, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 移动索引到1开始</span><br>        prices.<span class="hljs-built_in">insert</span>(prices.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 定义 f 数组并初始化为负无穷</span><br>        <span class="hljs-comment">// f[i][j][k] 表示第 i 天，持有 j (0 或 1) 股股票，已经交易了 k 次的最大收益</span><br>        std::vector&lt;std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">2</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c + <span class="hljs-number">1</span>, <span class="hljs-number">-1e9</span>)));<br>        <br>        <span class="hljs-comment">// 边界条件</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历所有状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= c; k++) &#123;<br>                    <span class="hljs-comment">// 决策：不操作</span><br>                    f[i][j][k] = std::<span class="hljs-built_in">max</span>(f[i][j][k], f[i - <span class="hljs-number">1</span>][j][k]);<br>                    <br>                    <span class="hljs-comment">// 决策：买入</span><br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                        f[i][<span class="hljs-number">1</span>][k] = std::<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">1</span>][k], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k - <span class="hljs-number">1</span>] - prices[i]);<br>                    &#125;<br>                    <br>                    <span class="hljs-comment">// 决策：卖出</span><br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                        f[i][<span class="hljs-number">0</span>][k] = std::<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>][k], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k] + prices[i]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到最大的收益</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= c; k++) &#123;<br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[n][<span class="hljs-number">0</span>][k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><p>问题描述</p>
<ul>
<li>给定一排房子，每个房子都有一定的现金。如果两个相邻的房子都被盗，就会触发报警系统。求在不触发报警的情况下能够盗取的最大金额。</li>
</ul>
<p>状态定义</p>
<ul>
<li>设 f[i][j] 表示在第 i个房子时的最大收益：<ul>
<li><code>j = 0</code> 表示未盗窃第 <code>i</code> 个房子。</li>
<li><code>j = 1</code> 表示盗窃第 <code>i</code> 个房子。</li>
</ul>
</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><code>f[i][0] = max(f[i - 1][0], f[i - 1][1])</code>：如果第 <code>i</code> 个房子没有被盗窃，那么最大收益就是前一个房子的状态（不管前一个房子是否被盗）。</li>
<li><code>f[i][1] = f[i - 1][0] + nums[i]</code>：如果第 <code>i</code> 个房子被盗窃，那么前一个房子一定没有被盗窃。</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>f[0][0] = 0</code>：第一个房子不偷的收益为 0。</li>
<li><code>f[0][1] = nums[0]</code>：第一个房子偷的收益为 <code>nums[0]</code>。</li>
</ul>
<p>目标</p>
<ul>
<li>计算 <code>max(f[n][0], f[n][1])</code>，其中 <code>n</code> 是房子的数量，这样可以得到在最后一个房子时的最大收益。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 为方便使用1基索引，我们在开头插入0</span><br>        nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 定义f数组，并初始化为负无穷大（表示不可达状态）</span><br>        std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1e9</span>));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界条件，第0天不偷的收益为0</span><br><br>        <span class="hljs-comment">// 动态规划填表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 不偷第i个房子</span><br>            f[i][<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// 偷第i个房子</span><br>            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最后一天不偷或偷的最大收益</span><br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(f[n][<span class="hljs-number">0</span>], f[n][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，计算将 <code>word1</code> 转换成 <code>word2</code> 所使用的最小操作数。可以对字符串执行以下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p>状态定义</p>
<p>设 <code>f[i][j]</code> 表示 <code>word1</code> 前 <code>i</code> 个字符和 <code>word2</code> 前 <code>j</code> 个字符之间的编辑距离（最小操作数）。</p>
<p>状态转移方程</p>
<ul>
<li><strong>插入操作</strong>：<code>f[i][j] = f[i][j - 1] + 1</code><ul>
<li>相当于在 <code>word1</code> 中第 <code>i</code> 个位置插入 <code>word2[j]</code>，所以 <code>j</code> 减 1 后计算剩余的编辑距离，再加上插入操作的1。</li>
</ul>
</li>
<li><strong>删除操作</strong>：<code>f[i][j] = f[i - 1][j] + 1</code><ul>
<li>相当于删除 <code>word1[i]</code>，因此 <code>i</code> 减 1 后计算剩余的编辑距离，再加上删除操作的1。</li>
</ul>
</li>
<li><strong>替换操作</strong>（或不变）：<code>f[i][j] = f[i - 1][j - 1] + eq</code>，其中 <code>eq = 0</code> 或 <code>1</code><ul>
<li>如果 <code>word1[i]</code> 与 <code>word2[j]</code> 相等，<code>eq = 0</code>；否则，<code>eq = 1</code>，因为需要一次替换操作。</li>
</ul>
</li>
</ul>
<p>初始条件</p>
<ul>
<li><code>f[i][0] = i</code>：将 <code>word1</code> 的前 <code>i</code> 个字符转化为一个空字符串需要 <code>i</code> 次删除操作。</li>
<li><code>f[0][j] = j</code>：将空字符串转化为 <code>word2</code> 的前 <code>j</code> 个字符需要 <code>j</code> 次插入操作。</li>
</ul>
<p>目标</p>
<p>最终目标是计算 <code>f[n][m]</code>，其中 <code>n</code> 和 <code>m</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word2)</span> &#123;<br>        <span class="hljs-type">int</span> n = word1.length();<br>        <span class="hljs-type">int</span> m = word2.length();<br>        <br>        <span class="hljs-comment">// 定义 f[i][j] 并初始化边界</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; f(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) f[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) f[<span class="hljs-number">0</span>][j] = j;<br><br>        <span class="hljs-comment">// 计算编辑距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-type">int</span> eq = (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>                f[i][j] = <span class="hljs-built_in">std</span>::min(&#123;f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 插入</span><br>                                    f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 删除</span><br>                                    f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + eq&#125;);  <span class="hljs-comment">// 替换或不变</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最终的编辑距离</span><br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0&#x2F;1 背包"></a><strong>0&#x2F;1 背包</strong></h3><p>给定 <code>N</code> 个物品，每个物品有一定的体积 <code>V[i]</code> 和价值 <code>W[i]</code>。还有一个容量为 <code>M</code> 的背包，要求在背包容量不超过 <code>M</code> 的前提下，选择一些物品放入背包，使物品的总价值最大。</p>
<p>模版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; V, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; W)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = V.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(M + <span class="hljs-number">1</span>, <span class="hljs-number">-1e9</span>)</span></span>; <span class="hljs-comment">// 初始化为负无穷</span><br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 没有物品且容量为0的初始状态</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 遍历每个物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = M; j &gt;= V[i]; --j) &#123; <span class="hljs-comment">// 倒序遍历容量，确保每个物品仅选择一次</span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - V[i]] + W[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 寻找容量为 M 时的最大价值</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= M; ++j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, f[j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><p>问题描述是：给定一个只包含正整数的非空数组，判断是否可以将数组分割成两个子集，使得两个子集的和相等。</p>
<p>这是一个典型的 0&#x2F;1 背包问题，问题可以转化为：是否可以从数组中选择一些数，使其和等于总和的一半。因为背包其实就是你看每个物品选不选?子集在一个核的限制下。选数的问题就跟背包一样，正好是选出来总体积为三-2这样的物品。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) sum += num;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= num; --j) &#123;<br>                f[j] = f[j] || f[j - num];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[target];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a><strong>完全背包问题</strong></h3><p>给定 NNN 种物品，其中第 iii 种物品的体积为 ViV_iVi，价值为 WiW_iWi，并且每种物品有无限个。现在有一个容量为 MMM 的背包，要求选择若干个物品放入背包中，使得物品的总体积不超过 MMM，并且物品的价值总和最大。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f(m + <span class="hljs-number">1</span>, <span class="hljs-number">-1000000000</span>); <span class="hljs-comment">// 初始化，容量为 m 的背包</span><br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;      <span class="hljs-comment">// 遍历每一种物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v[i]; j &lt;= m; j++) &#123; <span class="hljs-comment">// j 从 v[i] 到 m 顺序遍历</span><br>        f[j] = <span class="hljs-keyword">max</span>(f[j], f[j - v[i]] + w[i]); <span class="hljs-comment">// 更新当前容量 j 的最大值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>    ans = <span class="hljs-keyword">max</span>(ans, f[j]);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="零钱兑换-Ii"><a href="#零钱兑换-Ii" class="headerlink" title="零钱兑换 Ii"></a>零钱兑换 Ii</h4><p>给定一个整数数组 <code>coins</code> 表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p>
<p>编写一个函数来计算可以凑成总金额的硬币组合数，假设每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<ul>
<li>输入：<code>amount = 5, coins = [1, 2, 5]</code></li>
<li>输出：<code>4</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[amount + <span class="hljs-number">1</span>];<br>    Arrays.<span class="hljs-built_in">fill</span>(f, <span class="hljs-number">0</span>);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.length; i++) &#123; <span class="hljs-comment">// 遍历每种硬币</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历从 coins[i] 到 amount 的金额</span><br>            f[j] += f[j - coins[i]]; <span class="hljs-comment">// 更新方法数量</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[amount];<br>&#125;<br><br></code></pre></td></tr></table></figure>





<hr>
<h2 id="二十-字符串处理"><a href="#二十-字符串处理" class="headerlink" title="二十.字符串处理"></a>二十.字符串处理</h2><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>判断子串是否相等</p>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">str = &quot;abcd&quot;，那么我们逐步计算哈希值和幂值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">计算幂值数组 p（假设 P = 31）：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">p[0] = 1</span><br><span class="hljs-comment">p[1] = P^1 = 31</span><br><span class="hljs-comment">p[2] = P^2 = 31 * 31 = 961</span><br><span class="hljs-comment">p[3] = P^3 = 31 * 961 = 29791</span><br><span class="hljs-comment">p[4] = P^4 = 31 * 29791 = 923521</span><br><span class="hljs-comment">计算哈希值数组 h： 假设 str = &quot;abcd&quot;，每个字符的 ASCII 码为：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">a = 97</span><br><span class="hljs-comment">b = 98</span><br><span class="hljs-comment">c = 99</span><br><span class="hljs-comment">d = 100</span><br><span class="hljs-comment">我们通过递推计算 h[i]：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">h[1] = 97 （字符串 &quot;a&quot; 的哈希值）</span><br><span class="hljs-comment">h[2] = h[1] * P + 98 = 97 * 31 + 98 = 3025 （字符串 &quot;ab&quot; 的哈希值）</span><br><span class="hljs-comment">h[3] = h[2] * P + 99 = 3025 * 31 + 99 = 93974 （字符串 &quot;abc&quot; 的哈希值）</span><br><span class="hljs-comment">h[4] = h[3] * P + 100 = 93974 * 31 + 100 = 2911064 （字符串 &quot;abcd&quot; 的哈希值）</span><br><span class="hljs-comment">哈希值的计算方式是递推的：假设我们知道 str[1..i-1] 的哈希值 h[i-1]，那么通过加上字符 str[i]，可以得到 str[1..i] 的哈希值：</span><br><span class="hljs-comment">h[i] = h[i - 1] * P + str[i];</span><br><span class="hljs-comment">当你需要计算某个子串 str[l..r] 的哈希值时，可以通过 h[r] 和 h[l-1] 的差值来计算：</span><br><span class="hljs-comment">ULL get(int l, int r) &#123;</span><br><span class="hljs-comment">    return h[r] - h[l - 1] * p[r - l + 1];</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">现在我们来计算 str[2..3] 也就是 &quot;bc&quot; 的哈希值。</span><br><span class="hljs-comment">计算子串 str[2..3] 的哈希值：</span><br><span class="hljs-comment">h[3] = 93974 （字符串 &quot;abc&quot; 的哈希值）</span><br><span class="hljs-comment">h[1] = 97 （字符串 &quot;a&quot; 的哈希值）</span><br><span class="hljs-comment">子串 &quot;bc&quot; 的哈希值 get(2, 3) 就是：</span><br><span class="hljs-comment">get(2, 3) = h[3] - h[1] * p[3 - 2 + 1] = 93974 - 97 * p[2] = 93974 - 97 * 961</span><br><span class="hljs-comment">          = 93974 - 93377 = 597</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">const</span> ULL P = <span class="hljs-number">31</span>;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><span class="hljs-comment">// 初始化str到数组中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; str, <span class="hljs-type">int</span> n)</span> &#123;<br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算字符串前i个字符的哈希值</span><br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;              <span class="hljs-comment">// 计算P^i</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br>ULL <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="例题-11"><a href="#例题-11" class="headerlink" title="例题"></a>例题</h4><h4 id="判断两个子串是否相等"><a href="#判断两个子串是否相等" class="headerlink" title="判断两个子串是否相等"></a>判断两个子串是否相等</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//给定字符串 str = &quot;abcabc&quot;, 判断 str[1..3] 和 str[4..6] 是否相等。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">const</span> ULL P = <span class="hljs-number">31</span>;<br>ULL h[N], p[N];  <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; str, <span class="hljs-type">int</span> n)</span> &#123;<br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算字符串前i个字符的哈希值</span><br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;              <span class="hljs-comment">// 计算P^i</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l..r] 的哈希值</span><br>ULL <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">areSubstringsEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (r1 - l1 != r2 - l2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 长度不一样就肯定不相等</span><br>    <span class="hljs-keyword">return</span> get(l1, r1) == get(l2, r2);    <span class="hljs-comment">// 比较哈希值</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;abcabc&quot;</span>;<br>    <span class="hljs-type">int</span> n = str.length();<br>    <span class="hljs-comment">// 初始化哈希数组</span><br>    init(str, n);<br>    <span class="hljs-comment">// 判断 str[1..3] 和 str[4..6] 是否相等</span><br>    <span class="hljs-keyword">if</span> (areSubstringsEqual(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Substrings are equal!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Substrings are not equal!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">const</span> ULL P = <span class="hljs-number">31</span>;<br>ULL h1[N], h2[N], p1[N], p2[N];  <span class="hljs-comment">// h1, h2为str1和str2的哈希值，p1, p2为幂值</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; str, <span class="hljs-type">int</span> n, ULL h[], ULL p[])</span> &#123;<br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i - <span class="hljs-number">1</span>];<br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>    &#125;<br>&#125;<br><br>ULL <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, ULL h[], ULL p[])</span> &#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> len, <span class="hljs-built_in">string</span>&amp; str1, <span class="hljs-built_in">string</span>&amp; str2)</span> &#123;<br>    <span class="hljs-built_in">unordered_set</span>&lt;ULL&gt; hashes;<br>    <span class="hljs-type">int</span> n = str1.length(), m = str2.length();<br>    <span class="hljs-comment">// 计算str1所有长度为len的子串的哈希值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123;<br>        hashes.insert(get(i, i + len - <span class="hljs-number">1</span>, h1, p1));<br>    &#125;<br>    <span class="hljs-comment">// 查找str2中是否有长度为len的子串的哈希值与str1相同</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (hashes.count(get(i, i + len - <span class="hljs-number">1</span>, h2, p2))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>    <span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;zcdemn&quot;</span>;<br>    <span class="hljs-type">int</span> n = str1.length(), m = str2.length();<br>    <span class="hljs-comment">// 初始化哈希数组</span><br>    init(str1, n, h1, p1);<br>    init(str2, m, h2, p2);<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = min(n, m);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 二分法查找最长公共子串的长度</span><br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid, str1, str2)) &#123;<br>            ans = mid;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Length of longest common substring: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><p>ne 数组的定义</p>
<p><code>ne[i]</code> 表示字符串 <code>s[1..i]</code>（即从第 1 个字符到第 i 个字符）中，最长的相等的前缀和后缀的长度（前后缀的相等部分不包括 <code>s[i]</code> 本身）。</p>
<p>ne数组的计算过程</p>
<p>对于每个位置 <code>i</code>，我们需要查找 <code>s[1..i]</code> 的最长前后缀。具体计算方法如下：</p>
<ol>
<li>如果当前字符 <code>s[i]</code> 与之前的某个部分不匹配，我们需要查看 <code>ne</code> 数组的值来决定跳过多少个字符，以免进行重复比较。</li>
<li>如果当前字符 <code>s[i]</code> 与之前的某个部分匹配，那么就可以扩展前后缀。</li>
</ol>
<p>字符串：<code>ababcab</code></p>
<ol>
<li>初始化：<ul>
<li><code>s = &quot;ababcab&quot;</code>，长度为 7。</li>
<li><code>ne[0] = 0</code>，因为没有字符。</li>
</ul>
</li>
<li>计算 <code>ne</code> 数组：<ul>
<li><code>i = 1</code>，字符 <code>s[1] = &#39;a&#39;</code>：<ul>
<li>这里没有前缀和后缀，所以 <code>ne[1] = 0</code>。</li>
</ul>
</li>
<li><code>i = 2</code>，字符 <code>s[2] = &#39;b&#39;</code>：<ul>
<li><code>s[1] = &#39;a&#39;</code> 和 <code>s[2] = &#39;b&#39;</code> 不匹配，所以 <code>ne[2] = 0</code>。</li>
</ul>
</li>
<li><code>i = 3</code>，字符 <code>s[3] = &#39;a&#39;</code>：<ul>
<li><code>s[1] = &#39;a&#39;</code> 和 <code>s[3] = &#39;a&#39;</code> 匹配，所以 <code>ne[3] = 1</code>，表示前缀和后缀 <code>a</code> 匹配。</li>
</ul>
</li>
<li><code>i = 4</code>，字符 <code>s[4] = &#39;b&#39;</code>：<ul>
<li><code>s[2] = &#39;b&#39;</code> 和 <code>s[4] = &#39;b&#39;</code> 匹配，所以 <code>ne[4] = 2</code>，表示前缀和后缀 <code>ab</code> 匹配。</li>
</ul>
</li>
<li><code>i = 5</code>，字符 <code>s[5] = &#39;c&#39;</code>：<ul>
<li><code>s[3] = &#39;a&#39;</code> 和 <code>s[5] = &#39;c&#39;</code> 不匹配，回退到 <code>ne[3] = 1</code>，<code>s[1] = &#39;a&#39;</code> 和 <code>s[5] = &#39;c&#39;</code> 也不匹配，回退到 <code>ne[1] = 0</code>，<code>s[1] = &#39;a&#39;</code> 和 <code>s[5] = &#39;c&#39;</code> 不匹配，最终 <code>ne[5] = 0</code>。</li>
</ul>
</li>
<li><code>i = 6</code>，字符 <code>s[6] = &#39;a&#39;</code>：<ul>
<li><code>s[1] = &#39;a&#39;</code> 和 <code>s[6] = &#39;a&#39;</code> 匹配，所以 <code>ne[6] = 1</code>，表示前缀和后缀 <code>a</code> 匹配。</li>
</ul>
</li>
<li><code>i = 7</code>，字符 <code>s[7] = &#39;b&#39;</code>：<ul>
<li><code>s[2] = &#39;b&#39;</code> 和 <code>s[7] = &#39;b&#39;</code> 匹配，所以 <code>ne[7] = 2</code>，表示前缀和后缀 <code>ab</code> 匹配。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><code>ne</code> 数组的含义</p>
<ul>
<li><code>ne[1] = 0</code>，表示从 <code>s[1]</code> 没有任何前后缀匹配。</li>
<li><code>ne[2] = 0</code>，表示从 <code>s[1..2]</code> 没有任何前后缀匹配。</li>
<li><code>ne[3] = 1</code>，表示从 <code>s[1..3]</code> 有一个匹配的前后缀：<code>a</code>。</li>
<li><code>ne[4] = 2</code>，表示从 <code>s[1..4]</code> 有一个匹配的前后缀：<code>ab</code>。</li>
<li><code>ne[5] = 0</code>，表示从 <code>s[1..5]</code> 没有任何前后缀匹配。</li>
<li><code>ne[6] = 1</code>，表示从 <code>s[1..6]</code> 有一个匹配的前后缀：<code>a</code>。</li>
<li><code>ne[7] = 2</code>，表示从 <code>s[1..7]</code> 有一个匹配的前后缀：<code>ab</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> ne[N];  <span class="hljs-comment">// 部分匹配表</span><br><br><span class="hljs-comment">// 计算部分匹配表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">char</span>* p, <span class="hljs-type">int</span> m)</span> &#123;<br>    ne[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 初始化 ne[0]</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// j 代表当前匹配的字符位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];  <span class="hljs-comment">// 回退</span><br>        <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j++;  <span class="hljs-comment">// 匹配成功，扩展</span><br>        ne[i] = j;  <span class="hljs-comment">// 记录部分匹配值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// KMP 算法匹配函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">KMP</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">char</span>* p)</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s), m = <span class="hljs-built_in">strlen</span>(p);<br>    getNext(p, m);  <span class="hljs-comment">// 计算部分匹配表</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 模式串匹配的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 从 s[0] 开始遍历</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];  <span class="hljs-comment">// 如果字符不匹配，回退</span><br>        <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j++;  <span class="hljs-comment">// 匹配成功，扩展</span><br>        <span class="hljs-keyword">if</span> (j == m - <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 匹配成功</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern found at position %d\n&quot;</span>, i - m + <span class="hljs-number">2</span>);  <span class="hljs-comment">// 输出位置（从1开始）</span><br>            j = ne[j];  <span class="hljs-comment">// 使用部分匹配表调整位置</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>], p[<span class="hljs-number">1000</span>];  <span class="hljs-comment">// 定义字符数组存储输入的字符串</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);  <span class="hljs-comment">// 输入主字符串</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, p);  <span class="hljs-comment">// 输入模式串</span><br>    KMP(s, p);  <span class="hljs-comment">// 调用 KMP 算法查找模式串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="例题-12"><a href="#例题-12" class="headerlink" title="例题"></a>例题</h4><h4 id="找出字符串的周期"><a href="#找出字符串的周期" class="headerlink" title="找出字符串的周期"></a>找出字符串的周期</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*输入字符串：&quot;ABCABCABC&quot;</span><br><span class="hljs-comment">计算部分匹配表 ne：</span><br><span class="hljs-comment">ne = [-1, 0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class="hljs-comment">最长前后缀长度：L = ne[8] = 6</span><br><span class="hljs-comment">计算周期：t = len - L = 9 - 6 = 3</span><br><span class="hljs-comment">判断：9 % 3 == 0，所以周期为 3，输出 &quot;The period of the string is: 3&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入字符串：&quot;ABCDE&quot;</span><br><span class="hljs-comment">计算部分匹配表 ne：</span><br><span class="hljs-comment">ne = [-1, 0, 0, 0, 0]</span><br><span class="hljs-comment">最长前后缀长度：L = ne[4] = 0</span><br><span class="hljs-comment">计算周期：t = len - L = 5 - 0 = 5</span><br><span class="hljs-comment">判断：5 % 5 == 0，所以字符串没有周期，输出 &quot;The string does not have a period.&quot;。*/</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> ne[N];  <span class="hljs-comment">// 部分匹配表</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">char</span>[] p, <span class="hljs-type">int</span> m)</span> &#123;<br>    ne[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 比较p[i]和p[j+1]</span><br>            j = ne[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        ne[i] = j;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">KMP</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> n)</span> &#123;<br>    getNext(s, n);<br>    <span class="hljs-type">int</span> len = n;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The string is empty.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> L = ne[len - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 最长公共前后缀长度</span><br>    <span class="hljs-type">int</span> t = len - L;<br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span> &amp;&amp; len % t == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The period of the string is: %d\n&quot;</span>, t);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The string does not have a period.\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s);<br>    KMP(s, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="字符串的最小周期问题"><a href="#字符串的最小周期问题" class="headerlink" title="字符串的最小周期问题"></a>字符串的最小周期问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> ne[N];  <span class="hljs-comment">// 部分匹配表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">char</span>[] p, <span class="hljs-type">int</span> m)</span> &#123;<br>    ne[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) &#123;<br>            j = ne[j];  <span class="hljs-comment">// 回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        ne[i] = j;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">findMinPeriod</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> n)</span> &#123;<br>    getNext(s, n);<br>    <span class="hljs-type">int</span> len = n;<br>    <span class="hljs-type">int</span> L = ne[len - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最长公共前后缀的长度</span><br>    <span class="hljs-type">int</span> t = len - L;  <span class="hljs-comment">// 计算周期的长度</span><br><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-number">0</span> &amp;&amp; len % t == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The period of the string is: %d\n&quot;</span>, t);  <span class="hljs-comment">// 输出最小周期</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The string does not have a period.\n&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s);<br>    findMinPeriod(s, n);  <span class="hljs-comment">// 查找最小周期</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="Trie字符串"><a href="#Trie字符串" class="headerlink" title="Trie字符串"></a>Trie字符串</h3><p>假设我们插入以下字符串：apple app banana appl app</p>
<p><strong>插入 “apple”</strong>:</p>
<p>Root -&gt; a -&gt; p -&gt; p -&gt; l -&gt; e (cnt: 1)</p>
<p><strong>插入 “app”</strong>:</p>
<p>Root -&gt; a -&gt; p -&gt; p (cnt: 2)<br>                      -&gt; l -&gt; e (cnt: 1)</p>
<p><strong>插入 “banana”</strong>:</p>
<p>Root -&gt; a -&gt; p -&gt; p (cnt: 2)<br>                      -&gt; l -&gt; e (cnt: 1)<br>      -&gt; b -&gt; a -&gt; n -&gt; a -&gt; n -&gt; a (cnt: 1)</p>
<p><strong>插入 “appl”</strong>:</p>
<p>Root -&gt; a -&gt; p -&gt; p (cnt: 2)<br>                      -&gt; l -&gt; e (cnt: 1)<br>                            -&gt; l (cnt: 1)<br>      -&gt; b -&gt; a -&gt; n -&gt; a -&gt; n -&gt; a (cnt: 1)</p>
<p><strong>插入 “app”</strong>:</p>
<p>Root -&gt; a -&gt; p -&gt; p (cnt: 3)<br>                      -&gt; l -&gt; e (cnt: 1)<br>                            -&gt; l (cnt: 1)<br>      -&gt; b -&gt; a -&gt; n -&gt; a -&gt; n -&gt; a (cnt: 1)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;  <span class="hljs-comment">// Trie树的结构：儿子节点数组 son，单词计数数组 cnt，当前节点索引 idx</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 从根节点开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">// 转换字符为对应的数组索引</span><br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++idx;  <span class="hljs-comment">// 如果该子节点不存在，则新建节点</span><br>        p = son[p][u];  <span class="hljs-comment">// 跳到该子节点</span><br>    &#125;<br>    cnt[p]++;  <span class="hljs-comment">// 更新以该节点结尾的单词数量</span><br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 从根节点开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">// 转换字符为对应的数组索引</span><br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果没有对应的子节点，说明该字符串不存在</span><br>        p = son[p][u];  <span class="hljs-comment">// 跳到该子节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];  <span class="hljs-comment">// 返回以该节点结尾的单词数量，即该字符串的出现次数</span><br>&#125;<br><br><span class="hljs-comment">// 前缀匹配，返回以 prefix 为前缀的单词数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prefixCount</span><span class="hljs-params">(<span class="hljs-type">char</span> *prefix)</span><br>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 从根节点开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; prefix[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = prefix[i] - <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">// 转换字符为对应的数组索引</span><br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果没有对应的子节点，说明没有这个前缀</span><br>        p = son[p][u];  <span class="hljs-comment">// 跳到该子节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];  <span class="hljs-comment">// 返回该节点及其子树的单词数量</span><br>&#125;<br><br><span class="hljs-comment">// 自动补全，返回所有以 prefix 为前缀的单词</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">autoComplete</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-built_in">string</span> prefix)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (cnt[p] &gt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 如果这个节点结尾有单词</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; prefix &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)  <span class="hljs-comment">// 遍历所有可能的字母</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (son[p][i])  <span class="hljs-comment">// 如果有子节点</span><br>        &#123;<br>            autoComplete(son[p][i], prefix + <span class="hljs-type">char</span>(i + <span class="hljs-string">&#x27;a&#x27;</span>));  <span class="hljs-comment">// 递归生成单词</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br><br>    <span class="hljs-comment">// 插入一些单词</span><br>    insert(<span class="hljs-string">&quot;apple&quot;</span>);<br>    insert(<span class="hljs-string">&quot;app&quot;</span>);<br>    insert(<span class="hljs-string">&quot;banana&quot;</span>);<br>    insert(<span class="hljs-string">&quot;bat&quot;</span>);<br>    insert(<span class="hljs-string">&quot;ball&quot;</span>);<br><br>    <span class="hljs-comment">// 查询字符串出现的次数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;apple count: &quot;</span> &lt;&lt; query(<span class="hljs-string">&quot;apple&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 结果应该是 1</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;app count: &quot;</span> &lt;&lt; query(<span class="hljs-string">&quot;app&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-comment">// 结果应该是 1</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;banana count: &quot;</span> &lt;&lt; query(<span class="hljs-string">&quot;banana&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 结果应该是 1</span><br><br>    <span class="hljs-comment">// 前缀匹配，返回前缀为 &quot;ba&quot; 的单词数量</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Prefix &#x27;ba&#x27; count: &quot;</span> &lt;&lt; prefixCount(<span class="hljs-string">&quot;ba&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 结果应该是 3 (banana, bat, ball)</span><br><br>    <span class="hljs-comment">// 自动补全，输入 &quot;ba&quot; 后，输出所有以 &quot;ba&quot; 开头的单词</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Auto-complete for &#x27;ba&#x27;: &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    autoComplete(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;ba&quot;</span>);  <span class="hljs-comment">// 输出 &quot;banana&quot;, &quot;bat&quot;, &quot;ball&quot;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<h2 id="二十二-数学知识"><a href="#二十二-数学知识" class="headerlink" title="二十二.数学知识"></a>二十二.数学知识</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;A&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> k, string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        ans = ans * <span class="hljs-number">10</span> + <span class="hljs-built_in">calc</span>(s[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这段代码的目的是将一个整数 x 转换为基数 k（即进制）表示的字符串。</span><br><br><span class="hljs-function">string <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 初始化空字符串，用于存储转换结果</span><br>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> t = x % k; <span class="hljs-comment">// 计算 x 对 k 取余，得到当前位的值</span><br><br>        <span class="hljs-comment">// 如果余数小于10，直接将其转为字符并追加到结果字符串</span><br>        <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">9</span>) &#123;<br>            ans = ans + (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;0&#x27;</span> + t); <span class="hljs-comment">// &#x27;0&#x27; + t 转为对应数字字符</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果余数大于9，表示是 A, B, C, ..., Z 等表示 (例如10为A, 11为B等)</span><br>            ans = ans + (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span> + (t - <span class="hljs-number">10</span>)); <span class="hljs-comment">// &#x27;A&#x27; + (t - 10) 转为对应字符</span><br>        &#125;<br>        x = x / k; <span class="hljs-comment">// 更新 x，除以 k</span><br>    &#125;<br><br>    <span class="hljs-comment">// 将结果字符串反序并返回，reverse 是反转字符串的标准操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这段代码的功能是统计从 1 到 2024 之间符合特定条件的数字的个数。一个数字在二进制下和四进制下的各位数字之和相等。</span><br><br><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">// 计算x在b进制下的各位数字之和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sumB</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x) &#123;<br>        sum = sum + x % b;  <span class="hljs-comment">// 获取x在b进制下的当前位，并加到sum</span><br>        x = x / b;  <span class="hljs-comment">// 将x除以b，继续处理下一位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;  <span class="hljs-comment">// 返回各位数字之和</span><br>&#125;<br><br><span class="hljs-comment">// 检查x是否在二进制和四进制下的数字和相等</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> sumB(x, <span class="hljs-number">2</span>) == sumB(x, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 比较二进制和四进制下数字和是否相等</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用来记录符合条件的数字个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2024</span>; i++) &#123;  <span class="hljs-comment">// 从1到2024的每个数字</span><br>        <span class="hljs-keyword">if</span> (check(i)) &#123;  <span class="hljs-comment">// 如果check(i)返回true，说明满足条件</span><br>            ans++;  <span class="hljs-comment">// 满足条件的数字个数+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);  <span class="hljs-comment">// 输出符合条件的数字个数</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题"></a>日期问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 每月天数数组，平年默认是28天</span><br><span class="hljs-type">int</span> months[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;; <br><span class="hljs-comment">// 对应数字的汉字数组</span><br><span class="hljs-type">int</span> hz[] = &#123;<span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-comment">// 判断闰年函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">leap</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span> &#123;<br>    <span class="hljs-comment">// 闰年条件：是400的倍数，或者是4的倍数且不是100的倍数</span><br>    <span class="hljs-keyword">return</span> (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>) || (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 主逻辑处理函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用来记录符合条件的日期数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> year = <span class="hljs-number">2000</span>; year &lt;= <span class="hljs-number">2024</span>; year++) &#123;  <span class="hljs-comment">// 遍历每年</span><br>        <span class="hljs-comment">// 设置当前年份的月份天数</span><br>        <span class="hljs-keyword">if</span> (leap(year)) months[<span class="hljs-number">2</span>] = <span class="hljs-number">29</span>;<br>        <span class="hljs-keyword">else</span> months[<span class="hljs-number">2</span>] = <span class="hljs-number">28</span>;<br><br>        <span class="hljs-comment">// 遍历每月</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> month = <span class="hljs-number">1</span>; month &lt;= <span class="hljs-number">12</span>; month++) &#123;<br>            <span class="hljs-comment">// 遍历每天</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> day = <span class="hljs-number">1</span>; day &lt;= months[month]; day++) &#123;<br>                <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 当天日期的各位数字之和</span><br>                <span class="hljs-type">int</span> y1, y2, y3, y4, m1, m2, d1, d2;  <span class="hljs-comment">// 用来存储年份、月份和日期的各个数字</span><br><br>                y1 = year / <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 年份的千位</span><br>                y2 = year / <span class="hljs-number">100</span> % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 年份的百位</span><br>                y3 = year / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 年份的十位</span><br>                y4 = year % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 年份的个位</span><br>                m1 = month / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 月份的十位</span><br>                m2 = month % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 月份的个位</span><br>                d1 = day / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 日期的十位</span><br>                d2 = day % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 日期的个位</span><br><br>                <span class="hljs-comment">// 计算日期数字和</span><br>                cnt = cnt + hz[y1] + hz[y2] + hz[y3] + hz[y4] + hz[m1] + hz[m2] + hz[d1] + hz[d2];<br>                <br>                <span class="hljs-comment">// 若权值和大于50，计入答案</span><br>                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">50</span>) ans++;<br><br>                <span class="hljs-comment">// 若到达2024年4月13日，输出结果并结束</span><br>                <span class="hljs-keyword">if</span> (year == <span class="hljs-number">2024</span> &amp;&amp; month == <span class="hljs-number">4</span> &amp;&amp; day == <span class="hljs-number">13</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    solve();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>闰年处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">DaysOfMonth</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m)</span><span class="hljs-comment">//2月处理 </span><br>&#123;<br>	<span class="hljs-keyword">if</span>(m==<span class="hljs-number">2</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> is_leap(y)+<span class="hljs-number">28</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> day[m];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>回文</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">is_pali</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//是否回文 </span><br>&#123;<br>	<span class="hljs-built_in">string</span> str=to_string(x);<br>	<span class="hljs-built_in">string</span> s=str;<br>	reverse(s.begin(),s.end());<br>	<span class="hljs-keyword">return</span> s==str;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>abab判断（在回文的前提下）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">is_ab</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//abab判断 </span><br>&#123;<br>	<span class="hljs-built_in">string</span> str=to_string(x);<br>	<span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>]==str[<span class="hljs-number">2</span>]&amp;&amp;str[<span class="hljs-number">1</span>]==str[<span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>日期合法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">is_valid</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//日期合法 </span><br>&#123;<br>	<span class="hljs-built_in">string</span> str=to_string(x);<br>	year=(str[<span class="hljs-number">0</span>]<span class="hljs-number">-48</span>)<span class="hljs-number">1000</span>+(str[<span class="hljs-number">1</span>]<span class="hljs-number">-48</span>)<span class="hljs-number">100</span>+(str[<span class="hljs-number">2</span>]<span class="hljs-number">-48</span>)<span class="hljs-number">100</span>+str[<span class="hljs-number">3</span>]<span class="hljs-number">-48</span>;<br>	month=(str[<span class="hljs-number">4</span>]<span class="hljs-number">-48</span>)<span class="hljs-number">10</span>+str[<span class="hljs-number">5</span>]<span class="hljs-number">-48</span>;<br>	day=str[<span class="hljs-number">6</span>]*<span class="hljs-number">10</span>+str[<span class="hljs-number">7</span>];<br>	<span class="hljs-keyword">if</span>(month&lt;=<span class="hljs-number">12</span>&amp;&amp;day&lt;=day[month]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">if</span>(year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>||year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>) <br>	&#123;<br>		<span class="hljs-keyword">if</span>(month==<span class="hljs-number">2</span>&amp;&amp;day==<span class="hljs-number">29</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>







<h3 id="线性筛法求质数"><a href="#线性筛法求质数" class="headerlink" title="线性筛法求质数"></a>线性筛法求质数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 目的： 2-n的所有质数</span><br><span class="hljs-comment"> * 步骤：从2开始遍历所有小于等于n的整数，标记出合数，最终得到所有未被标记为合数的数即为质数。</span><br><span class="hljs-comment"> * 输入：一个正整数 n</span><br><span class="hljs-comment"> * 输出：输出所有小于或等于 n 的质数</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>;  <span class="hljs-comment">// 假设你要处理的最大数为 1e6，可以根据需求调整</span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> primes[N];  <span class="hljs-comment">// 存储所有质数</span><br><span class="hljs-type">bool</span> st[N];           <span class="hljs-comment">// st[x]表示x是否被筛掉，true表示x是合数，false表示x是质数</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 用来记录质数的个数</span><br><br><span class="hljs-comment">// 线性筛法：用来找出小于等于n的所有质数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt++] = i;  <span class="hljs-comment">// 如果i是质数，将其记录</span><br>        <span class="hljs-comment">// 对于已知的质数，从i开始标记倍数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j++) &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 将i的倍数标记为合数</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 防止重复标记</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br><br>    <span class="hljs-comment">// 读取输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a number to find all primes less than or equal to it: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);  <span class="hljs-comment">// 使用scanf读取long long类型的数</span><br><br>    <span class="hljs-comment">// 调用函数获取所有质数</span><br>    get_primes(n);<br>    <br>    <span class="hljs-comment">// 输出所有质数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Primes less than or equal to %lld are:\n&quot;</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, primes[i]);  <span class="hljs-comment">// 输出质数</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-comment">// 举个简单例子：输入n=10时，程序输出 2 3 5 7</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 目的：该程序用于将给定整数 x 分解成其质因数，并输出每个质因数及其出现次数。</span><br><span class="hljs-comment"> * 步骤：</span><br><span class="hljs-comment"> * 1. 从 2 开始，逐步检查是否能整除 x。</span><br><span class="hljs-comment"> * 2. 如果能整除，则记录该质因数的出现次数，并不断除以该质因数直到不能整除为止。</span><br><span class="hljs-comment"> * 3. 如果剩余的 x 大于 1，说明它本身是质数，输出它。</span><br><span class="hljs-comment"> * 输入：一个长整型数 x</span><br><span class="hljs-comment"> * 输出：x 的质因数分解结果，以“质因数 次数”的形式输出。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i++) &#123;  <span class="hljs-comment">// 从2开始检查到sqrt(x)</span><br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果i能整除x</span><br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录i出现的次数</span><br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 不断除以i</span><br>                x /= i;  <span class="hljs-comment">// 将x除以i</span><br>                s++;  <span class="hljs-comment">// 增加次数</span><br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %d\n&quot;</span>, i, s);  <span class="hljs-comment">// 输出质因数和出现次数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld 1\n&quot;</span>, x);  <span class="hljs-comment">// 如果剩余的x是质数，输出它</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <span class="hljs-comment">// 输出换行</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x;    <br>    <span class="hljs-comment">// 读取用户输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a number to divide: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);  <span class="hljs-comment">// 输入一个long long类型的整数</span><br><br>    <span class="hljs-comment">// 输出分解结果</span><br>    divide(x);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="试除法求所有因数"><a href="#试除法求所有因数" class="headerlink" title="试除法求所有因数"></a>试除法求所有因数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 目的：该算法用于找到一个整数 x 的所有正因数，并按升序排序返回。</span><br><span class="hljs-comment"> * 步骤：遍历从1到sqrt(x)，对于每个能整除x的数i，x/i也是x的因数，记录这些因数。</span><br><span class="hljs-comment"> * 输入：一个正整数 x</span><br><span class="hljs-comment"> * 输出：返回 x 的所有因数，并按升序排列。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 返回 x 的所有正因数</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title function_">get_divisors</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; res;  <span class="hljs-comment">// 用于存储因数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= x / i; i++) &#123;  <span class="hljs-comment">// 遍历从1到sqrt(x)</span><br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果i能整除x</span><br>            res.push_back(i);  <span class="hljs-comment">// i 是一个因数</span><br>            <span class="hljs-keyword">if</span> (i != x / i) &#123;  <span class="hljs-comment">// 如果i和x/i不相等，x/i也是一个因数</span><br>                res.push_back(x / i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    sort(res.begin(), res.end());  <span class="hljs-comment">// 按升序排列因数</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x;<br>    <span class="hljs-comment">// 读取输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a number to find its divisors: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);  <span class="hljs-comment">// 使用scanf读取long long类型的数</span><br>    <span class="hljs-comment">// 获取所有因数</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; divisors = get_divisors(x);<br>    <span class="hljs-comment">// 输出所有因数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Divisors of %lld are:\n&quot;</span>, x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> d : divisors) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, d);  <span class="hljs-comment">// 输出每个因数</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-comment">// 举个简单例子：输入x=18时，程序输出 1 2 3 6 9 18</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="约数个数和约数之和"><a href="#约数个数和约数之和" class="headerlink" title="约数个数和约数之和"></a>约数个数和约数之和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="hljs-comment">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span><br><span class="hljs-comment">约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)</span><br><span class="hljs-comment"> * 目的：该算法用于计算两个整数 a 和 b 的最大公约数（GCD）。</span><br><span class="hljs-comment"> * 步骤：使用 **辗转相除法**（也叫欧几里得算法）来计算最大公约数。该算法通过递归不断交换两个数并用模运算简化问题，直到 b 为 0，a 即为最大公约数。</span><br><span class="hljs-comment"> * 输入：两个整数 a 和 b</span><br><span class="hljs-comment"> * 输出：返回 a 和 b 的最大公约数</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 计算最大公约数（GCD）</span><br><span class="hljs-comment">// 使用辗转相除法（欧几里得算法）</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> b ? gcd(b, a % b) : a;  <span class="hljs-comment">// 递归计算直到b为0，返回a</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b;<br>    <span class="hljs-comment">// 读取输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter two numbers to find their GCD: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);  <span class="hljs-comment">// 使用scanf读取long long类型的两个数</span><br>    <span class="hljs-comment">// 计算最大公约数</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = gcd(a, b);<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The GCD of %lld and %lld is: %lld\n&quot;</span>, a, b, result);<br>    <span class="hljs-comment">// 举个简单例子：输入a=18, b=24时，程序输出 6</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="最大公约数————找到x和y"><a href="#最大公约数————找到x和y" class="headerlink" title="最大公约数————找到x和y"></a>最大公约数————找到x和y</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 扩展欧几里得算法，求解 gcd(a, b)，并且找到 x 和 y，使得 a * x + b * y = gcd(a, b)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;  <span class="hljs-comment">// 基本情况，b == 0 时，返回 gcd(a, b) = a</span><br>        x = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 这里是 a * 1 + b * 0 = a</span><br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-comment">// 递归调用，计算 exgcd(b, a % b)</span><br>    <span class="hljs-type">int</span> d = exgcd(b, a % b, y, x);  <span class="hljs-comment">// 交换 x 和 y，并递归计算 gcd(b, a % b)</span><br>    <br>    <span class="hljs-comment">// 更新 y 的值，新的 y 是递归返回的 y 减去 a / b * x</span><br>    y -= a / b * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a, b, x, y;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;  <span class="hljs-comment">// 输入两个整数 a 和 b</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出这两个整数</span><br><br>    <span class="hljs-comment">// 调用扩展欧几里得算法</span><br>    <span class="hljs-type">int</span> d = exgcd(a, b, x, y);<br>    <span class="hljs-comment">//找到x和y</span><br>    <span class="hljs-comment">// 输出结果：a * x + b * y = gcd(a, b)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d * %d + %d * %d = %d\n&quot;</span>, a, x, b, y, d);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 目的：该算法用于计算 m^k mod p，即计算 m 的 k 次方模 p。</span><br><span class="hljs-comment"> * 步骤：使用 快速幂算法（Exponentiation by Squaring）来计算，时间复杂度为 O(log k)。</span><br><span class="hljs-comment"> *       通过将 k 不断右移（k &gt;&gt;= 1）并适时更新结果，避免直接计算 m 的 k 次方。</span><br><span class="hljs-comment"> * 输入：三个整数 m, k, p，分别表示底数、指数和模数。</span><br><span class="hljs-comment"> * 输出：返回 m^k mod p 的结果。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 快速幂算法：计算 m^k mod p</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span> % p;  <span class="hljs-comment">// 初始化结果为 1 % p</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = m % p;    <span class="hljs-comment">// 初始化 t 为 m % p</span><br>    <span class="hljs-keyword">while</span> (k) &#123;  <span class="hljs-comment">// 当 k 不为零时</span><br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果 k 是奇数</span><br>            res = res * t % p;  <span class="hljs-comment">// 更新结果</span><br>        &#125;<br>        t = t * t % p;  <span class="hljs-comment">// 将 t 平方</span><br>        k &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// k 右移一位，即 k // 2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回最终结果</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> m, k, p;<br>    <span class="hljs-comment">// 读取输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter m, k, p: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld&quot;</span>, &amp;m, &amp;k, &amp;p);  <span class="hljs-comment">// 使用scanf读取long long类型的 m, k, p</span><br>    <span class="hljs-comment">// 调用函数计算 m^k mod p</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = qmi(m, k, p);<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld^%lld mod %lld = %lld\n&quot;</span>, m, k, p, result);<br>    <span class="hljs-comment">// 举个简单例子：输入 m = 2, k = 10, p = 1000 时，程序输出 1024 mod 1000 = 24</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="通过预处理逆元的方式求组合数"><a href="#通过预处理逆元的方式求组合数" class="headerlink" title="通过预处理逆元的方式求组合数"></a>通过预处理逆元的方式求组合数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;  <span class="hljs-comment">// 假设我们取模的数是一个质数</span><br><br><span class="hljs-type">int</span> fact[MAXN], infact[MAXN];<br><br><span class="hljs-comment">// 快速幂计算：a^k % p</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 预处理阶乘和阶乘逆元</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">preprocess</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span> &#123;<br>    fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        fact[i] = (LL)fact[i<span class="hljs-number">-1</span>] * i % p;<br>    &#125;<br>    infact[n] = qmi(fact[n], p<span class="hljs-number">-2</span>, p);  <span class="hljs-comment">// 费马小定理计算逆元</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        infact[i] = (LL)infact[i+<span class="hljs-number">1</span>] * (i+<span class="hljs-number">1</span>) % p;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算C(N, K) % p</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">comb</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> K, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-keyword">if</span> (K &lt; <span class="hljs-number">0</span> || K &gt; N) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (LL)fact[N] * infact[K] % p * infact[N-K] % p;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> N, K;<br>    <span class="hljs-comment">// 用scanf输入N和K</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;N, &amp;K);<br>    <br>    <span class="hljs-comment">// 预处理阶乘和逆元</span><br>    preprocess(N, MOD);<br>    <br>    <span class="hljs-comment">// 输出 C(N, K) % MOD</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, comb(N, K, MOD));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> p = <span class="hljs-number">7</span>; <span class="hljs-comment">// 模质数为7</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 快速幂算法，用于计算 (a^k) % p</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;  <span class="hljs-comment">// 如果 k 是奇数，乘以 a</span><br>        a = (LL)a * a % p;  <span class="hljs-comment">// 计算 a^2 % p</span><br>        k &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// k 右移一位，减少 k 的大小</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 计算组合数 C(a, b) % p</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i++, j--) &#123;<br>        res = (LL)res * j % p;  <span class="hljs-comment">// 乘上 a! 中的元素</span><br>        res = (LL)res * qmi(i, p - <span class="hljs-number">2</span>) % p;  <span class="hljs-comment">// 乘上 i! 的逆元，利用费马小定理计算</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// Lucas 定理，用于计算 C(a, b) % p</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">lucas</span><span class="hljs-params">(LL a, LL b)</span> &#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> C(a, b);  <span class="hljs-comment">// 基本情况，直接计算 C(a, b)</span><br>    <span class="hljs-keyword">return</span> (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;  <span class="hljs-comment">// 递归应用 Lucas 定理</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Enter values for n and m: &quot;</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 计算 C(n, m) % p</span><br>    <span class="hljs-type">int</span> result = lucas(n, m);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C(&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot;) % &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 求x, y，使得ax + by = gcd(a, b)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>    &#123;<br>        x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = exgcd(b, a % b, y, x);<br>    y -= (a/b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a[N][N]是增广矩阵</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gauss</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> c, r;<br>    <span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; c &lt; n; c ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )   <span class="hljs-comment">// 找到绝对值最大的行</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; <span class="hljs-built_in">fabs</span>(a[t][c]))<br>                t = i;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[t][c]) &lt; eps) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      <span class="hljs-comment">// 将绝对值最大的行换到最顶端</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="hljs-comment">// 将当前上的首位变成1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++ )       <span class="hljs-comment">// 用当前行将下面所有的列消成0</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; eps)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= c; j -- )<br>                    a[i][j] -= a[r][j] * a[i][c];<br><br>        r ++ ;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 无解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 有无穷多组解</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++ )<br>            a[i][n] -= a[i][j] * a[j][n];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 有唯一解</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="第二类斯特林"><a href="#第二类斯特林" class="headerlink" title="第二类斯特林"></a>第二类斯特林</h3><h3 id="概率论与期望公式–均值期望"><a href="#概率论与期望公式–均值期望" class="headerlink" title="概率论与期望公式–均值期望"></a>概率论与期望公式–均值期望</h3><h3 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p> 一、基本位运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>示例 (<code>a = 5, b = 3</code>)</th>
<th>二进制</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>与</td>
<td><code>a &amp; b</code></td>
<td><code>0101 &amp; 0011</code></td>
<td><code>0001</code> → 1</td>
</tr>
<tr>
<td>&#96;</td>
<td>&#96;</td>
<td>或</td>
<td>&#96;a</td>
<td>b&#96;</td>
</tr>
<tr>
<td><code>^</code></td>
<td>异或</td>
<td><code>a ^ b</code></td>
<td><code>0101 ^ 0011</code></td>
<td><code>0110</code> → 6</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取反（按位非）</td>
<td><code>~a</code></td>
<td><code>~0101</code></td>
<td><code>1010</code> → -6（补码表示）</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>a &lt;&lt; 1</code></td>
<td><code>0101 &lt;&lt; 1</code></td>
<td><code>1010</code> → 10</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>a &gt;&gt; 1</code></td>
<td><code>0101 &gt;&gt; 1</code></td>
<td><code>0010</code> → 2</td>
</tr>
</tbody></table>
<hr>
<p> 二、常见技巧与应用场景</p>
<ol>
<li>判断奇偶</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 奇数</span><br><span class="hljs-keyword">if</span> (!(x &amp; <span class="hljs-number">1</span>)) <span class="hljs-comment">// 偶数</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>交换两个数（不使用中间变量）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a = a ^ b;<br>b = a ^ b; <span class="hljs-comment">// (a ^ b) ^ b = a</span><br>a = a ^ b; <span class="hljs-comment">// (a ^ b) ^ a = b</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>提取最低位的 1</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> lowbit = x &amp; (-x); <span class="hljs-comment">// 非常常用！快速提取最低位的1</span><br></code></pre></td></tr></table></figure>

<p>比如 <code>x = 12</code> (1100)，最低位1在第3位，<code>x &amp; -x = 0100</code> → 4</p>
<p>这个技巧是 <strong>树状数组、子集枚举</strong> 的核心。</p>
<ol start="4">
<li>位计数（统计有几个1）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++写法</span><br><span class="hljs-type">int</span> count = __builtin_popcount(x); <span class="hljs-comment">// GCC内建函数</span><br></code></pre></td></tr></table></figure>

<p>手动写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x) &#123;<br>    x &amp;= (x - <span class="hljs-number">1</span>); <span class="hljs-comment">// 每次清除最低位的1</span><br>    count++;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p> 三、常见位运算题型</p>
<p>枚举子集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">cpp复制编辑<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> subset = mask; subset; subset = (subset - <span class="hljs-number">1</span>) &amp; mask) &#123;<br>    <span class="hljs-comment">// 遍历 mask 的所有非空子集</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>判断第 i 位是否为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (x &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) <span class="hljs-comment">// 第 i 位是1</span><br></code></pre></td></tr></table></figure>

<p>设置&#x2F;清除&#x2F;翻转第 i 位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">x |= (<span class="hljs-number">1</span> &lt;&lt; i);   <span class="hljs-comment">// 设置第 i 位为1</span><br>x &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; i);  <span class="hljs-comment">// 清除第 i 位为0</span><br>x ^= (<span class="hljs-number">1</span> &lt;&lt; i);   <span class="hljs-comment">// 翻转第 i 位</span><br></code></pre></td></tr></table></figure>

<hr>
<p>四、综合例题</p>
<p>例题1：统计1的个数（Hamming Weight）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        n &amp;= (n - <span class="hljs-number">1</span>);<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例题2：两个整数的汉明距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> __builtin_popcount(x ^ y);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例题3：判断是否是2的幂</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>









<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><p>随机数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">rand() % (maxValue + <span class="hljs-number">1</span>)  <span class="hljs-comment">//生成一个 [0, maxValue] 之间的随机数</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 优化算法（待验证）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">optimizedAlgorithm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-comment">// 替换为你需要验证的算法</span><br>    <span class="hljs-comment">// 例如，选择排序、快速排序、归并排序等</span><br>&#125;<br><br><span class="hljs-comment">// 暴力算法（用作对比）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bruteForceAlgorithm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-comment">// 使用内置的排序算法作为暴力算法（如 std::sort）</span><br>    sort(arr.begin(), arr.end());<br>&#125;<br><br><span class="hljs-comment">// 生成随机数组</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">generateRandomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> maxValue)</span> &#123;<br>    <span class="hljs-type">int</span> size = rand() % (maxSize + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 数组大小在 [0, maxSize] 之间</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(size)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        arr[i] = rand() % (<span class="hljs-number">2</span> * maxValue + <span class="hljs-number">1</span>) - maxValue;  <span class="hljs-comment">// 数值范围 [-maxValue, maxValue]</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 复制数组</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">copyArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">return</span> arr;  <span class="hljs-comment">// 直接返回副本</span><br>&#125;<br><br><span class="hljs-comment">// 比较两个数组是否相等</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr1, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr1.size() != arr2.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr1.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 打印数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 设置随机数种子</span><br><br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">500000</span>;  <span class="hljs-comment">// 测试次数</span><br>    <span class="hljs-type">int</span> maxSize = <span class="hljs-number">100</span>;      <span class="hljs-comment">// 数组最大长度</span><br>    <span class="hljs-type">int</span> maxValue = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 数值范围</span><br>    <span class="hljs-type">bool</span> succeed = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 多次测试</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr1 = generateRandomArray(maxSize, maxValue);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr2 = copyArray(arr1);<br><br>        <span class="hljs-comment">// 使用优化算法排序 arr1</span><br>        optimizedAlgorithm(arr1);<br>        <span class="hljs-comment">// 使用暴力算法排序 arr2</span><br>        bruteForceAlgorithm(arr2);<br><br>        <span class="hljs-comment">// 如果排序结果不一致，输出错误信息</span><br>        <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;<br>            succeed = <span class="hljs-literal">false</span>;<br>            printArray(arr1);<br>            printArray(arr2);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (succeed) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Nice!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Fucking fucked!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试单个排序结果</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = generateRandomArray(maxSize, maxValue);<br>    printArray(arr);<br>    optimizedAlgorithm(arr);<br>    printArray(arr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<p>&#x2F;&#x2F;返回[0,1)的一个小数</p>
<p>&#x2F;&#x2F;任意的x,×属于[0,1)，[0，×)范围上的数出现概率由原来的×调整成x平方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">xToXPower2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(Math.random(), Math.random());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;三次方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">xToXPower3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(Math.random(), Math.max(Math.random(), Math.random()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从1<del>5随机到1</del>7随机</p>
<p>​	由一个f1()条件函数1-5到目标函数f3()1-7</p>
<p>​	令有一个01条件发生器f2()，让12为0，让45为1，到3重复，那么f2_ f2_ f2_让每个二进制位上面全部都是f2就好了，就成为了数字的0-7,可是要1-7，那就当0-7时判断当0时重复做一般就成了1-7</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// f2() - 生成一个 0 或 1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> rand() % <span class="hljs-number">2</span>;  <span class="hljs-comment">// 返回 0 或 1</span><br>&#125;<br><br><span class="hljs-comment">// f3() - 使用 f2() 生成一个 0 到 7 的整数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> ans = (f2() &lt;&lt; <span class="hljs-number">2</span>) + (f2() &lt;&lt; <span class="hljs-number">1</span>) + f2();  <span class="hljs-comment">// 生成一个三位的二进制数</span><br>    <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">// 返回值是 0 到 7 之间</span><br>&#125;<br><br><span class="hljs-comment">// f1() - 生成一个 1 到 5 之间的随机数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> rand() % <span class="hljs-number">5</span> + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 生成 1 到 5 之间的随机数</span><br>&#125;<br><br><span class="hljs-comment">// 将 f1() 映射到 f3() 的 1 到 7</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mapTo1to7</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">int</span> f1_result = f1();  <span class="hljs-comment">// 1 到 5 之间的随机数</span><br>        <span class="hljs-type">int</span> f3_result = f3();  <span class="hljs-comment">// 0 到 7 之间的随机数</span><br>        <br>        <span class="hljs-comment">// 如果 f3() 结果在 0 到 4 之间，映射成功</span><br>        <span class="hljs-keyword">if</span> (f3_result &gt;= <span class="hljs-number">0</span> &amp;&amp; f3_result &lt; <span class="hljs-number">5</span>) &#123;<br>            result = f1_result + f3_result;<br>            <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">// 返回 1 到 7 之间的随机数</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 如果 f3() 的值大于 4，重新尝试</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 设置随机数种子</span><br>    <span class="hljs-comment">// 测试</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Random number from 1 to 7: &quot;</span> &lt;&lt; mapTo1to7() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从a<del>b随机到c</del>d随机 </p>
<p>同理使用01条件器，把a-b分类，c-d变成0 -  d-c</p>
<p>利用这个思想大样本来调试程序</p>
<p>首先我补一个方法。你给我申请一个random数组。呃，这个长度最好随机，所以有个max长度。我然后值呢值我给你个范围range，这个是范围是吧？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">randomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> len, <span class="hljs-type">int</span> range, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(len)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        arr[i] = rand() % (range + <span class="hljs-number">1</span>); <span class="hljs-comment">// 生成 0 ~ range 的随机数</span><br>        <span class="hljs-keyword">if</span> (arr[i] &lt; k || arr[i] &gt; m) &#123;<br>            arr[i] = rand() % (m - k + <span class="hljs-number">1</span>) + k; <span class="hljs-comment">// 保证数组值在 [k, m] 范围内</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 假设 test 和 onlyKTimes 是两个函数，你需要实现它们</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-comment">// 假设的实现，具体逻辑根据实际需求填写</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">onlyKTimes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-comment">// 假设的实现，具体逻辑根据实际需求填写</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">100</span>;  <span class="hljs-comment">//数组长度最大100</span><br>    <span class="hljs-type">int</span> range = <span class="hljs-number">200</span>; <span class="hljs-comment">//数组的值在-200到200间</span><br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">100000</span>;  <span class="hljs-comment">//随机次数</span><br>    <span class="hljs-type">int</span> max = <span class="hljs-number">9</span>;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-type">int</span> a = rand() % max + <span class="hljs-number">1</span>; <span class="hljs-comment">// a 1 ~ 9</span><br>        <span class="hljs-type">int</span> b = rand() % max + <span class="hljs-number">1</span>; <span class="hljs-comment">// b 1 ~ 9</span><br>        <span class="hljs-type">int</span> k = min(a, b);<br>        <span class="hljs-type">int</span> m = max(a, b);<br>		<span class="hljs-comment">//命令k&lt;m</span><br>        <span class="hljs-keyword">if</span> (k == m) &#123;<br>            m++;<br>        &#125;<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = randomArray(len, range, k, m);<br><br>        <span class="hljs-type">int</span> ans1 = test(arr, k, m);<br>        <span class="hljs-type">int</span> ans2 = onlyKTimes(arr, k, m);<br><br>        <span class="hljs-keyword">if</span> (ans1 != ans2) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;出错了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>异或</p>
<p>异或运算的应用</p>
<p>1.应用一：不用任何额外变量交换两个数。要求ab所指向的位置必须在不同位置 </p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span>^b; b = <span class="hljs-keyword">a</span>^b; <span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span>^b;  <br></code></pre></td></tr></table></figure>



<p>2.应用二：在一个数组中找出现奇数次的一种数 [a,b,a,a,b]把所有值都跟eor异或一下，最终结果是出现奇数次的数</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">eor</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">eor</span> = <span class="hljs-keyword">eor</span>^a; <span class="hljs-keyword">eor</span> = <span class="hljs-keyword">eor</span>^b; <span class="hljs-keyword">eor</span> = <span class="hljs-keyword">eor</span>^a;  <br></code></pre></td></tr></table></figure>

<p>3.应用三：二进制int将最右侧的1提取出来组成新的int</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a&amp;(-a);<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法笔记</div>
      <div>https://theganlove.github.io/2024/09/09/算法笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>uert</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/" title="服务器部署">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">服务器部署</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/08/%E9%9A%90%E5%86%99/" title="隐写">
                        <span class="hidden-mobile">隐写</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
