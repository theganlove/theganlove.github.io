

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="uert">
  <meta name="keywords" content="">
  
    <meta name="description" content="注意:本笔记代码都是c++，而且为了蓝桥杯做了很大的改变，所以初次学不要按照本笔记 c++代码的基础内容DevC++常用快捷键 F9：编译并运行程序。  Shift + F9：仅编译（不运行）  Ctrl + &#x2F;：注释当前行或选中的代码  Ctrl + Shift + &#x2F;：取消注释  进入 工具 -&gt; 编辑器选项 -&gt; 代码模板，在其中添加你常用的代码片段。例如，可以创建一个 for">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://theganlove.github.io/2024/09/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="注意:本笔记代码都是c++，而且为了蓝桥杯做了很大的改变，所以初次学不要按照本笔记 c++代码的基础内容DevC++常用快捷键 F9：编译并运行程序。  Shift + F9：仅编译（不运行）  Ctrl + &#x2F;：注释当前行或选中的代码  Ctrl + Shift + &#x2F;：取消注释  进入 工具 -&gt; 编辑器选项 -&gt; 代码模板，在其中添加你常用的代码片段。例如，可以创建一个 for">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-09T11:20:21.000Z">
<meta property="article:modified_time" content="2025-02-14T14:29:36.812Z">
<meta property="article:author" content="uert">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算法笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"theganlove.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>主题</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-09 19:20" pubdate>
          2024年9月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          51k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          425 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>注意:本笔记代码都是c++，而且为了蓝桥杯做了很大的改变，所以初次学不要按照本笔记</p>
<h1 id="c-代码的基础内容"><a href="#c-代码的基础内容" class="headerlink" title="c++代码的基础内容"></a>c++代码的基础内容</h1><h2 id="DevC-常用快捷键"><a href="#DevC-常用快捷键" class="headerlink" title="DevC++常用快捷键"></a>DevC++常用快捷键</h2><ol>
<li><p>F9<code>：编译并运行程序。</code></p>
</li>
<li><p>Shift + F9：仅编译（不运行）</p>
</li>
<li><p><code>Ctrl + /</code>：注释当前行或选中的代码</p>
</li>
<li><p><code>Ctrl + Shift + /</code>：取消注释</p>
</li>
<li><p>进入 <code>工具</code> -&gt; <code>编辑器选项</code> -&gt; <code>代码模板</code>，在其中添加你常用的代码片段。例如，可以创建一个 <code>for</code> 循环模板，快速插入到代码中。</p>
</li>
<li><p>打开 Dev C++，点击 <strong>工具</strong> -&gt; <strong>编译选项</strong>。</p>
<p>在 <strong>编译选项</strong> 窗口中，选择 <strong>编译器设置</strong>。</p>
<p>在 <strong>设置</strong> 选项卡下的 <strong>命令行</strong> 中，加入 <code>-std=c++11</code>（或更高版本的标准，如 <code>-std=c++14</code>、<code>-std=c++17</code>）。</p>
</li>
</ol>
<p>++++</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul>
<li><p><code>#include &lt;bits/stdc++.h&gt;</code><br>不需要一一手动包含，但是占时间，容易超时，不会再写。</p>
</li>
<li><p><code>#include &lt;iostream&gt;</code><br>标准输入输出流，常用对象：<code>std::cin</code>, <code>std::cout</code>, <code>std::cerr</code>, <code>std::endl</code>。</p>
</li>
<li><p><code>#include &lt;string&gt;</code><br>字符串操作，常用类：<code>std::string</code>，常用函数：<code>std::getline</code>。</p>
</li>
<li><p><code>#include &lt;cstring&gt;</code><br>C风格字符串操作，常用函数：<code>strlen</code>, <code>strcpy</code>, <code>strcmp</code>。</p>
</li>
<li><p><code>#include &lt;vector&gt;</code><br>动态数组容器，常用类：<code>std::vector</code>。</p>
</li>
<li><p><code>#include &lt;algorithm&gt;</code><br>通用算法，常用函数：<code>std::sort</code>, <code>std::find</code>, <code>std::max</code>, <code>std::min</code>。</p>
</li>
<li><p><code>#include &lt;map&gt;</code><br>有序键值对容器，常用类：<code>std::map</code>。</p>
</li>
<li><p><code>#include &lt;unordered_map&gt;</code><br>无序键值对容器，常用类：<code>std::unordered_map</code>。</p>
</li>
<li><p><code>#include &lt;unordered_set&gt;</code><br>提供哈希集合，常用类：<code>std::unordered_set</code></p>
</li>
<li><p><code>#include &lt;cmath&gt;</code><br>数学函数，常用函数：<code>std::sqrt</code>, <code>std::pow</code>, <code>std::sin</code>, <code>std::cos</code>。</p>
</li>
<li><p><code>#include &lt;numeric&gt;</code><br>数值操作，常用函数：<code>std::accumulate</code>, <code>std::gcd</code>。</p>
</li>
<li><p><code>#include &lt;utility&gt;</code><br>工具函数，常用类：<code>std::pair</code>。</p>
</li>
</ul>
<p>++++</p>
<h2 id="基础数据结构和算法"><a href="#基础数据结构和算法" class="headerlink" title="基础数据结构和算法"></a><strong>基础数据结构和算法</strong></h2><h3 id="1-基础语法与数据类型"><a href="#1-基础语法与数据类型" class="headerlink" title="1. 基础语法与数据类型"></a>1. <strong>基础语法与数据类型</strong></h3><h4 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1.输入输出"></a>1.输入输出</h4><p>C++ 通过 <code>cin</code> 和 <code>cout</code> 来处理输入和输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Enter your age: &quot;</span>;<br>std::cin &gt;&gt; age;  <span class="hljs-comment">// 输入年龄</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Your age is: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;  <span class="hljs-comment">// 输出年龄</span><br></code></pre></td></tr></table></figure>

<p>scanf和printf</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">scanf(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> <span class="hljs-variable">%f</span> <span class="hljs-variable">%lf</span> <span class="hljs-variable">%s</span>&quot;</span>, &amp;a, &amp;b, &amp;c, str);<span class="hljs-regexp">//</span> Double: <span class="hljs-variable">%lf</span>， 默认保留<span class="hljs-number">6</span>位小数,Char: <span class="hljs-variable">%c</span>, 回车也是一个字符，用’\n’表示<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的整数是: <span class="hljs-variable">%d</span>\n&quot;</span>, a);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的浮点数是: <span class="hljs-variable">%.</span>2f\n&quot;</span>, b);  <span class="hljs-regexp">//</span> 控制浮点数输出保留两位小数<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的双精度浮点数是: <span class="hljs-variable">%.</span>3lf\n&quot;</span>, c);  <span class="hljs-regexp">//</span> 控制双精度浮点数输出保留三位小数<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的字符串是: <span class="hljs-variable">%s</span>\n&quot;</span>, str);<br></code></pre></td></tr></table></figure>

<h4 id="2-基本数学函数"><a href="#2-基本数学函数" class="headerlink" title="2.基本数学函数"></a>2.<strong>基本数学函数</strong></h4><ul>
<li><strong><code>abs(int x)</code></strong>: 返回整数 <code>x</code> 的绝对值。</li>
<li><strong><code>fabs(double x)</code></strong>: 返回浮点数 <code>x</code> 的绝对值。</li>
<li><strong><code>sqrt(double x)</code></strong>: 返回 <code>x</code> 的平方根。</li>
<li><strong><code>pow(double base, double exp)</code></strong>: 返回 <code>base</code> 的 <code>exp</code> 次方。</li>
<li><strong><code>exp(double x)</code></strong>: 返回 <code>e</code> 的 <code>x</code> 次方。</li>
<li><strong><code>log(double x)</code></strong>: 返回 <code>x</code> 的自然对数。</li>
<li><strong><code>log10(double x)</code></strong>: 返回 <code>x</code> 的以 10 为底的对数。</li>
<li><strong><code>ceil(double x)</code></strong>: 返回大于或等于 <code>x</code> 的最小整数。</li>
<li><strong><code>floor(double x)</code></strong>: 返回小于或等于 <code>x</code> 的最大整数。</li>
<li><strong><code>round(double x)</code></strong>: 返回最接近 <code>x</code> 的整数。</li>
</ul>
<p><strong>三角函数</strong></p>
<ul>
<li><strong><code>sin(double x)</code></strong>: 返回 <code>x</code> 的正弦值。</li>
<li><strong><code>cos(double x)</code></strong>: 返回 <code>x</code> 的余弦值。</li>
<li><strong><code>tan(double x)</code></strong>: 返回 <code>x</code> 的正切值。</li>
<li><strong><code>asin(double x)</code></strong>: 返回 <code>x</code> 的反正弦值。</li>
<li><strong><code>acos(double x)</code></strong>: 返回 <code>x</code> 的反余弦值。</li>
<li><strong><code>atan(double x)</code></strong>: 返回 <code>x</code> 的反正切值。</li>
<li><strong><code>atan2(double y, double x)</code></strong>: 计算 <code>y/x</code> 的反正切值，考虑象限。</li>
</ul>
<p><strong>常数</strong></p>
<ul>
<li><strong><code>M_PI</code></strong>: <code>π</code> 的值。</li>
<li><strong><code>M_E</code></strong>: <code>e</code> 的值。</li>
</ul>
<p><strong>其他函数</strong></p>
<ul>
<li><strong><code>modf(double x, double\* intpart)</code></strong>: 拆分 <code>x</code> 为整数部分和小数部分。</li>
<li><strong><code>fmod(double x, double y)</code></strong>: 返回 <code>x</code> 除 <code>y</code> 的余数。</li>
<li><strong><code>hypot(double x, double y)</code></strong>: 返回 <code>sqrt(x^2 + y^2)</code>。</li>
</ul>
<p><strong>随机数</strong></p>
<ul>
<li><strong><code>rand()</code></strong>: 返回一个随机整数。</li>
<li><strong><code>srand(unsigned int seed)</code></strong>: 设置随机数种子。</li>
</ul>
<p><strong>特殊值判断</strong></p>
<ul>
<li><code>isnan(double x)</code>: 判断 <code>x</code> 是否为 NaN。</li>
<li><strong><code>isfinite(double x)</code></strong>: 判断 <code>x</code> 是否为有限值。</li>
<li><strong><code>isinf(double x)</code></strong>: 判断 <code>x</code> 是否为无穷大。</li>
</ul>
<p>+++++</p>
<h3 id="2-字符"><a href="#2-字符" class="headerlink" title="2.字符"></a>2.字符</h3><p>C++ 中，每个常用字符对应一个整数值，通常称为 ASCII 值。可以通过字符与对应的整数值相互转化。</p>
<ul>
<li><h4 id="字符与-ASCII-码："><a href="#字符与-ASCII-码：" class="headerlink" title="字符与 ASCII 码："></a><strong>字符与 ASCII 码：</strong></h4><ul>
<li>‘A’ - ‘Z’ 对应的 ASCII 值是 65 ~ 90</li>
<li>‘a’ - ‘z’ 对应的 ASCII 值是 97 ~ 122</li>
<li>‘0’ - ‘9’ 对应的 ASCII 值是 48 ~ 57</li>
</ul>
</li>
<li><p><strong>字符可以参与运算：</strong></p>
<ul>
<li>运算时，字符会被当做整数处理，使用其对应的 ASCII 值。</li>
</ul>
</li>
</ul>
<p>字符串在 C++ 中本质上是一个字符数组，数组的末尾有一个特殊的结束符 <code>&#39;\0&#39;</code>。所以输出字符串就直接输出arr这个就行 char arr[]&#x3D;”hello world”;</p>
<h4 id="字符数组的常用操作"><a href="#字符数组的常用操作" class="headerlink" title="字符数组的常用操作"></a><strong>字符数组的常用操作</strong></h4><ol>
<li>**<code>strlen(str)</code>**：计算字符串长度。</li>
<li>**<code>strcmp(a, b)</code>**：比较两个字符串，按字典序比较。</li>
<li>**<code>strcpy(a, b)</code>**：将字符串 <code>b</code> 复制到 <code>a</code>。</li>
</ol>
<hr>
<h4 id="标准库类型-string"><a href="#标准库类型-string" class="headerlink" title="标准库类型 string"></a>标准库类型 <code>string</code></h4><p><code>string</code> 是一个动态的字符序列 等同于char arr[]</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::string s2(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-string">&quot;ccccc&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong><code>string</code> 上的常见操作</strong></p>
<ul>
<li><strong><code>getline</code> 读取一整行</strong></li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">getline</span>(cin, str);  <span class="hljs-comment">// 读取一整行输入</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>empty</code> 和 <code>size</code></strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::cout &lt;&lt; <span class="hljs-string">&quot;字符串是否为空: &quot;</span> &lt;&lt; <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">empty</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;字符串的长度: &quot;</span> &lt;&lt; <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">size</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>string</code> 的比较：</strong></li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"> <span class="hljs-meta">if</span> (<span class="hljs-built_in">s1</span> &lt; <span class="hljs-built_in">s2</span>) &#123;<br><span class="hljs-symbol">     std:</span>:cout &lt;&lt; <span class="hljs-built_in">s1</span> &lt;&lt; <span class="hljs-string">&quot; 小于 &quot;</span> &lt;&lt; <span class="hljs-built_in">s2</span> &lt;&lt; std::endl<span class="hljs-comment">;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>string</code> 赋值与拼接</strong></li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">std:</span>:string <span class="hljs-built_in">s3</span> = <span class="hljs-built_in">s1</span> + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">s2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>find查询子串</strong></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span> (pos != std::string::npos) &#123;       <span class="hljs-regexp">//</span>如果没找到，返回std::string::npos<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found at position &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>substr()</code></strong></p>
<p>从字符串中提取子串。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">std::string str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>std::string <span class="hljs-function"><span class="hljs-keyword">sub</span> = <span class="hljs-title">str</span>.<span class="hljs-title">substr</span></span>(7, 5);  // 从索引 <span class="hljs-number">7</span> 开始，提取 <span class="hljs-number">5</span> 个字符<br>std::cout &lt;&lt; <span class="hljs-function"><span class="hljs-keyword">sub</span></span>;  // 输出 <span class="hljs-string">&quot;world&quot;</span><br></code></pre></td></tr></table></figure>

<p> <strong><code>c_str()</code></strong></p>
<p>将 <code>std::string</code> 转换为 C 风格字符串（即以 <code>&#39;\0&#39;</code> 结尾的字符数组）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">c_str</span>();<br>std::cout &lt;&lt; cstr;  <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>c_str()</code> 返回一个指向字符串的常量指针（<code>const char*</code>）。</li>
</ul>
<p><strong><code>append()</code></strong></p>
<p>将另一个字符串或字符附加到当前字符串的末尾。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">cpp复制编辑std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">append</span>(<span class="hljs-string">&quot;, world!&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>push_back()</code></strong></p>
<p>向字符串末尾添加一个字符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-string">&#x27;!&#x27;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>insert()</code></strong></p>
<p>在指定位置插入字符或子字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;, beautiful&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello, beautiful world!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>insert(pos, str)</code>：在位置 <code>pos</code> 插入字符串 <code>str</code>。</li>
<li><code>insert(pos, n, c)</code>：在位置 <code>pos</code> 插入 <code>n</code> 个字符 <code>c</code>。</li>
</ul>
<p> <strong><code>erase()</code></strong></p>
<p>删除指定位置的字符或子字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">erase</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>);  <span class="hljs-comment">// 从索引 5 开始，删除 7 个字符</span><br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>erase(pos, len)</code>：删除从 <code>pos</code> 开始，长度为 <code>len</code> 的子串。</li>
</ul>
<p><strong><code>replace()</code></strong></p>
<p>替换指定位置的字符或子字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">cpp复制编辑std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;C++&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello, C++!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>replace(pos, len, str)</code>：从 <code>pos</code> 开始，删除 <code>len</code> 个字符并用 <code>str</code> 替换它们。</li>
</ul>
<p><strong><code>compare()</code></strong></p>
<p>比较两个字符串的大小（按字典序比较）。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;apple&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;banana&quot;</span>;<br>int result = str1.<span class="hljs-built_in">compare</span>(str2);  // 返回负值，因为 <span class="hljs-string">&quot;apple&quot;</span> 小于 <span class="hljs-string">&quot;banana&quot;</span><br><span class="hljs-built_in">std</span>::cout &lt;&lt; result;  // 输出负数<br></code></pre></td></tr></table></figure>

<ul>
<li><code>compare()</code>：返回值是 <code>0</code> 表示两个字符串相等，负值表示当前字符串小于比较字符串，正值表示当前字符串大于比较字符串。</li>
</ul>
<p><strong><code>find_first_of()</code></strong></p>
<p>查找字符串中第一个包含指定字符或字符集的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>size_t pos = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_first_of</span>(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找第一个元音字母的位置</span><br>std::cout &lt;&lt; pos;  <span class="hljs-comment">// 输出 1，表示 &#x27;e&#x27; 是第一个元音</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>find_first_of(str)</code>：返回第一次出现字符集中任意字符的索引位置。</li>
</ul>
<p> <strong><code>find_last_of()</code></strong></p>
<p>查找字符串中最后一个包含指定字符或字符集的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>size_t pos = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_last_of</span>(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找最后一个元音字母的位置</span><br>std::cout &lt;&lt; pos;  <span class="hljs-comment">// 输出 8，表示 &#x27;o&#x27; 是最后一个元音</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>find_last_of(str)</code>：返回最后一次出现字符集中的任意字符的位置。</li>
</ul>
<p><strong><code>rfind()</code></strong></p>
<p>从字符串的尾部开始查找指定子串的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world! world!&quot;</span>;<br>size_t pos = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">rfind</span>(<span class="hljs-string">&quot;world&quot;</span>);  <span class="hljs-comment">// 查找最后一次出现 &quot;world&quot; 的位置</span><br>std::cout &lt;&lt; pos;  <span class="hljs-comment">// 输出 13</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>rfind(str)</code>：返回从尾部开始查找子串的位置。</li>
</ul>
<p> <strong><code>to_string()</code></strong></p>
<p>将数字类型转换为字符串。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">int <span class="hljs-built_in">num</span> = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = <span class="hljs-built_in">std</span>::to_string(<span class="hljs-built_in">num</span>);  // <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-built_in">std</span>::cout &lt;&lt; str;<br></code></pre></td></tr></table></figure>

<p><strong><code>stoi()</code>, <code>stol()</code>, <code>stof()</code>, <code>stod()</code> 等</strong></p>
<p>将字符串转换为整数、长整型、浮点数等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;12345&quot;</span>;<br>int num = std::<span class="hljs-title function_ invoke__">stoi</span>(<span class="hljs-type">str</span>);  <span class="hljs-comment">// 将字符串转换为整数</span><br>std::cout &lt;&lt; num;  <span class="hljs-comment">// 输出 12345</span><br></code></pre></td></tr></table></figure>

<p> <strong><code>trim()</code> (自定义实现)</strong></p>
<p>C++ 标准库并没有直接提供 <code>trim</code> 函数来去除字符串两端的空白字符，但你可以通过自定义函数来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-keyword">const</span> std::string&amp; <span class="hljs-type">str</span>) &#123;<br>    auto start = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_first_not_of</span>(<span class="hljs-string">&quot; \t\n\r&quot;</span>);<br>    auto end = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_last_not_of</span>(<span class="hljs-string">&quot; \t\n\r&quot;</span>);<br>    <span class="hljs-title function_ invoke__">return</span> (start == std::string::npos || end == std::string::npos) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">substr</span>(start, end - start + <span class="hljs-number">1</span>);<br>&#125;<br><br>int <span class="hljs-title function_ invoke__">main</span>() &#123;<br>    std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;   Hello, world!   &quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-type">str</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;|Hello, world!|&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>++++</p>
<h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。当函数的形参为引用类型时，对形参的修改会影响实参的值。使用引用的作用：避免拷贝、让函数返回额外信息。</p>
<p>++++</p>
<h3 id="4-STL"><a href="#4-STL" class="headerlink" title="4.STL"></a>4.STL</h3><h4 id="一-STL-的主要组成部分"><a href="#一-STL-的主要组成部分" class="headerlink" title="一.STL 的主要组成部分"></a>一.STL 的主要组成部分</h4><ol>
<li>**容器 (Containers)**：用来存储和管理数据的集合。</li>
<li>**算法 (Algorithms)**：用于对数据进行操作，如排序、查找、修改等。</li>
<li>**迭代器 (Iterators)**：用于遍历容器中的元素，提供统一的访问接口。</li>
</ol>
<h4 id="二、容器-Containers"><a href="#二、容器-Containers" class="headerlink" title="二、容器 (Containers)"></a>二、容器 (Containers)</h4><p>STL 容器分为三类：<strong>顺序容器</strong>、<strong>关联容器</strong>和<strong>无序关联容器</strong>。</p>
<h5 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1.顺序容器"></a>1.顺序容器</h5><p>顺序容器存储数据时，元素按插入顺序排列，常见的顺序容器有：</p>
<ul>
<li>**<code>vector</code>**：动态数组，支持快速随机访问。</li>
<li>**<code>deque</code>**：双端队列，支持两端快速插入和删除。</li>
<li>**<code>list</code>**：双向链表，支持双向遍历，插入和删除操作效率较高。</li>
<li>**<code>array</code>**：定长数组（C++11 引入），存储固定大小的数据。</li>
<li>**<code>forward_list</code>**：单向链表（C++11 引入），支持单向遍历。</li>
</ul>
<p><strong><code>vector</code></strong> 动态数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 初始化</span><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 尾部添加元素</span><br>vec[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;        <span class="hljs-comment">// 随机访问</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 5 3 4</span><br> &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>deque</code></strong> 双端队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-type">int</span>&gt; dq = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入元素</span><br>dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入元素</span><br>dq.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-comment">// 移除头部元素</span><br>dq.<span class="hljs-built_in">pop_back</span>();     <span class="hljs-comment">// 移除尾部元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : dq) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：2 3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>list</code></strong> 双向链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br> lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入</span><br> lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入</span><br> lst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 移除值为2的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : lst) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：0 1 3 4</span><br> &#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>array</code></strong> 定长数组（C++11）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 固定大小为3的数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>forward_list</code></strong> 单向链表（C++11）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::forward_list&lt;<span class="hljs-type">int</span>&gt; flst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>flst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 头部插入</span><br>flst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 移除值为2的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : flst) &#123;<br>     std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：0 1 3</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2. 关联容器"></a>2. <strong>关联容器</strong></h5><p>关联容器基于平衡二叉树（通常是红黑树）实现，元素按键值排序，支持快速查找、插入和删除操作。常见的关联容器有：</p>
<ul>
<li>**<code>set</code>**：存储唯一的元素，自动按元素的键值排序。</li>
<li>**<code>map</code>**：键值对（key-value）形式存储元素，按键排序。</li>
<li>**<code>multiset</code>**：存储允许重复的元素，按键排序。</li>
<li>**<code>multimap</code>**：存储允许重复的键值对，按键排序。</li>
</ul>
<p><strong><code>set</code></strong> 存储唯一元素，自动排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动排序，重复元素被忽略</span><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : s) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>map</code></strong> 键值对形式存储，按键排序</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m = &#123;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;&#125;; <span class="hljs-comment">// 自动排序，重复键的值会被覆盖</span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; m;<br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>m[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>m[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : m) &#123;<br>    std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">// 输出：apple: 3 banana: 2 orange: 4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>multiset</code></strong> 存储允许重复元素，按键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::multiset&lt;<span class="hljs-type">int</span>&gt; ms = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 插入重复元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ms) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 1 2 2 3 4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>multimap</code></strong> 存储允许重复的键值对，按键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::multimap&lt;std::string, <span class="hljs-type">int</span>&gt; mm;<br>mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;);<br>mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>&#125;);  <span class="hljs-comment">// 相同键可以重复插入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : mm) &#123;<br>    std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出： apple: 3 apple: 5 banana: 2</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="3-无序关联容器"><a href="#3-无序关联容器" class="headerlink" title="3. 无序关联容器"></a>3. <strong>无序关联容器</strong></h5><p>无序关联容器是基于哈希表实现的容器，元素无序排列，但支持常数时间复杂度的查找、插入和删除操作。常见的无序关联容器有：</p>
<ul>
<li>**<code>unordered_set</code>**：无序集合，元素唯一。</li>
<li>**<code>unordered_map</code>**：无序键值对，基于哈希表存储。</li>
<li>**<code>unordered_multiset</code>**：无序多重集合，允许重复元素。</li>
<li>**<code>unordered_multimap</code>**：无序多重键值对，允许重复键。</li>
</ul>
<p><strong><code>unordered_set</code></strong> 无序集合，元素唯一</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_set&lt;<span class="hljs-type">int</span>&gt; uset = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">// 重复的1被忽略</span><br>uset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : uset) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出顺序不固定，例如：3 1 2 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>unordered_map</code></strong> 无序键值对，基于哈希表存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; umap;<br>umap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>umap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>umap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : umap) &#123;<br>    std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">// 输出顺序不固定，例如：</span><br>banana: <span class="hljs-number">2</span> apple: <span class="hljs-number">3</span> orange: <span class="hljs-number">4</span><br> &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>unordered_multiset</code></strong> 无序多重集合，允许重复元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_multiset&lt;<span class="hljs-type">int</span>&gt; ums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>ums.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 插入重复元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ums) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出顺序不固定，例如：1 1 2 2 3 4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>unordered_multimap</code></strong> 无序多重键值对，允许重复键</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_multimap&lt;std::string, <span class="hljs-type">int</span>&gt; umm;<br>umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;);<br>umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>&#125;);  <span class="hljs-comment">// 相同键可以重复插入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : umm) &#123;<br>  	std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出顺序不固定，例如： apple: 3 apple: 5 banana: 2</span><br> &#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="三、算法-Algorithms"><a href="#三、算法-Algorithms" class="headerlink" title="三、算法 (Algorithms)"></a>三、算法 (Algorithms)</h4><p>STL 提供了一系列的算法来操作容器，如排序、查找、修改等。这些算法定义在头文件 <code>&lt;algorithm&gt;</code> 中，并且可以通过迭代器访问容器的元素。</p>
<h5 id="1-常用算法"><a href="#1-常用算法" class="headerlink" title="1. 常用算法"></a>1. <strong>常用算法</strong></h5><ul>
<li>**<code>sort</code>**：对容器进行排序。</li>
<li>**<code>find</code>**：查找某个元素。</li>
<li>**<code>binary_search</code>**：二分查找，要求容器是有序的。</li>
<li>**<code>reverse</code>**：将容器中的元素反转。</li>
<li>**<code>accumulate</code>**：计算容器中元素的累加和。</li>
<li>**<code>count</code>**：统计容器中某个元素的出现次数。</li>
</ul>
<p><strong><code>sort</code></strong> 对容器进行排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 升序排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>find</code></strong> 查找某个元素</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::vector&lt;int&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>auto it = std::find(vec.<span class="hljs-keyword">begin</span>(), vec.<span class="hljs-keyword">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-keyword">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-regexp">//</span> 输出：<span class="hljs-title class_">Element</span> <span class="hljs-symbol">found:</span> <span class="hljs-number">3</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>binary_search</code></strong> 二分查找（要求容器是有序的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">bool</span> found = std::<span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (found) &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>reverse</code></strong> 将容器中的元素反转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">reverse</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>   std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>accumulate</code></strong> 计算容器中元素的累加和</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">std</span>::vector&lt;int&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-attribute">int</span> sum = std::accumulate(vec.begin(), vec.end(), <span class="hljs-number">0</span>);  // 初始值为<span class="hljs-number">0</span><br><span class="hljs-attribute">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  // 输出：Sum: <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>

<p><strong><code>count</code></strong> 统计容器中某个元素的出现次数</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">std</span>::vector&lt;int&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-attribute">int</span> cnt = std::count(vec.begin(), vec.end(), <span class="hljs-number">2</span>);<br><span class="hljs-attribute">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Count of 2: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  // 输出：Count of <span class="hljs-number">2</span>: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>



<h5 id="2-自定义比较函数"><a href="#2-自定义比较函数" class="headerlink" title="2. 自定义比较函数"></a>2. <strong>自定义比较函数</strong></h5><p><strong><code>sort</code></strong> 使用自定义比较函数</p>
<p>默认情况下，<code>std::sort</code> 会进行升序排序。我们可以通过传递一个自定义比较函数来控制排序方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 自定义比较函数，实现降序排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), descending);  <span class="hljs-comment">// 使用自定义比较函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>      std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>find_if</code></strong> 使用自定义条件</p>
<p><code>std::find_if</code> 可根据自定义的 <strong>谓词函数</strong> 查找符合条件的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 自定义谓词函数，查找第一个大于3的元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">greaterThanThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">3</span>;<br>&#125;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), greaterThanThree);<br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>()) &#123;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;First element greater than 3: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：4</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br> 	 std::cout &lt;&lt; <span class="hljs-string">&quot;No element found\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>binary_search</code></strong> 自定义比较函数</p>
<p><code>std::binary_search</code> 也可以接受自定义的比较函数，但要求容器中的元素按该规则预先排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 自定义比较函数，进行降序比较</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), descending);  <span class="hljs-comment">// 降序排序</span><br><span class="hljs-type">bool</span> found = std::<span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, descending);<br><span class="hljs-keyword">if</span> (found) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>set</code></strong> 自定义比较函数（按降序存储）</p>
<p>C++ 中的 <strong><code>std::set</code></strong> 默认是升序排序。我们可以自定义一个比较函数来改变排序顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 自定义比较函数，按降序排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Descending</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br>std::set&lt;<span class="hljs-type">int</span>, Descending&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : s) &#123;<br>     std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>priority_queue</code></strong> 自定义比较函数（实现小顶堆）</p>
<p><code>std::priority_queue</code> 默认是大顶堆，我们可以通过自定义比较函数创建小顶堆。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 自定义比较函数，实现小顶堆</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 使较小的元素拥有更高优先级</span><br>    &#125;<br>&#125;;<br><br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, Compare&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>  	std::cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 3 5</span><br>    pq.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="四、迭代器-Iterators"><a href="#四、迭代器-Iterators" class="headerlink" title="四、迭代器 (Iterators)"></a>四、迭代器 (Iterators)</h4><p>迭代器提供了一种统一的方式来遍历 STL 容器。常见的迭代器类型有：</p>
<ul>
<li>**<code>begin()</code> 和 <code>end()</code>**：返回指向容器第一个元素和尾后元素的迭代器。</li>
<li>**<code>rbegin()</code> 和 <code>rend()</code>**：返回逆序迭代器，分别指向最后一个元素和第一个元素之前的位置。</li>
<li>**<code>cbegin()</code> 和 <code>cend()</code>**：返回常量迭代器，不能用于修改元素。</li>
</ul>
<p>迭代器可以通过 <code>*it</code> 解引用访问元素，通过 <code>++it</code> 或 <code>--it</code> 移动到下一个或上一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 使用普通迭代器遍历</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using iterator: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>      std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 使用常量迭代器遍历</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using const_iterator: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">cbegin</span>(); it != vec.<span class="hljs-built_in">cend</span>(); ++it) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 使用逆序迭代器遍历</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using reverse_iterator: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">rbegin</span>(); it != vec.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<h4 id="五-辅助工具类（Utility-Components）"><a href="#五-辅助工具类（Utility-Components）" class="headerlink" title="五.辅助工具类（Utility Components）"></a>五.辅助工具类（Utility Components）</h4><ul>
<li><strong>数据结构</strong>：<code>pair</code>、<code>tuple</code>、<code>make_pair</code>、<code>make_tuple</code></li>
<li><strong>移动语义和转发</strong>：<code>std::move</code>、<code>std::forward</code></li>
<li><strong>交换和引用</strong>：<code>std::swap</code>、<code>std::reference_wrapper</code></li>
<li><strong>关系运算符</strong>：<code>std::rel_ops</code></li>
<li><strong>类型特性工具</strong>：<code>std::declval</code>、<code>std::enable_if</code></li>
<li><strong>解构支持</strong>：<code>std::tie</code></li>
</ul>
<p><strong><code>pair</code> 的基本使用</strong></p>
<p><code>pair</code> 的定义在 <code>&lt;utility&gt;</code> 头文件中，通常用 <code>std::make_pair</code> 函数来创建一个 <code>pair</code>，也可以直接使用构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 make_pair 函数创建一个 pair</span><br>std::pair&lt;std::string, <span class="hljs-type">int</span>&gt; student = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-comment">// 访问 pair 中的元素</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; student.first &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; student.second &lt;&lt; std::endl;<br><span class="hljs-comment">// 也可以直接使用构造函数初始化 pair</span><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">score</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">98.5</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Rank: &quot;</span> &lt;&lt; score.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; score.second &lt;&lt; std::endl;<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>pair</code> 的成员</strong></li>
</ol>
<ul>
<li><code>first</code>: 表示 <code>pair</code> 中的第一个元素。</li>
<li><code>second</code>: 表示 <code>pair</code> 中的第二个元素。</li>
</ul>
<p>可以通过 <code>pair.first</code> 和 <code>pair.second</code> 分别访问两个值。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>)</span></span>;  <span class="hljs-comment">// 初始化pair，第一个元素是int，第二个是char</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p.first &lt;&lt; std::endl;  <span class="hljs-comment">// 输出10</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Second: &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;  <span class="hljs-comment">// 输出&#x27;A&#x27;</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>与容器结合使用</strong></li>
</ol>
<p><code>pair</code> 在 STL 容器中非常常用，特别是在关联容器（如 <code>map</code> 和 <code>set</code>）中，<code>pair</code> 用于表示键值对。在 <code>map</code> 中，键值对的每个元素实际上是一个 <code>pair</code>，其中 <code>first</code> 是键，<code>second</code> 是值。</p>
<p>在 <code>map</code> 中使用 <code>pair</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 创建一个 map 来存储学生姓名和分数</span><br> std::map&lt;std::string, <span class="hljs-type">int</span>&gt; studentScores;<br><span class="hljs-comment">// 插入键值对，使用 make_pair 函数</span><br>studentScores.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90</span>));<br>studentScores.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">85</span>));<br><span class="hljs-comment">// 访问 map 中的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : studentScores) &#123;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; entry.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; entry.second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// 也可以通过 [] 操作符直接访问键值对</span><br>studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] = <span class="hljs-number">88</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Charlie&#x27;s Score: &quot;</span> &lt;&lt; studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>比较 <code>pair</code></strong></li>
</ol>
<p><code>pair</code> 支持比较操作（如 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等）。比较规则是先比较 <code>first</code> 元素，如果 <code>first</code> 相等，则比较 <code>second</code> 元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p1 is less than p2&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 比较的是 first，若相等，则比较 second</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>p1</code> 和 <code>p2</code> 的 <code>first</code> 部分相同，比较结果取决于 <code>second</code> 部分。</p>
<ol start="5">
<li><strong><code>pair</code> 的常见用法</strong></li>
</ol>
<ul>
<li><p><strong>作为函数的返回值</strong>：当你需要从函数中返回多个值时，<code>pair</code> 可以作为方便的结构体来返回两个值，而不需要创建专门的结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">getMinMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(a, b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(b, a);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getMinMax</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Min: &quot;</span> &lt;&lt; result.first &lt;&lt; <span class="hljs-string">&quot;, Max: &quot;</span> &lt;&lt; result.second &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><strong><code>tuple</code> 作为扩展</strong></li>
</ol>
<p><code>pair</code> 只能存储两个相关联的值。如果你需要存储更多的值，可以使用 C++11 引入的 <code>tuple</code>，它是 <code>pair</code> 的扩展版，可以存储任意多个元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-type">double</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90.5</span>)</span></span>;<br><span class="hljs-comment">// 访问 tuple 中的元素</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;ID: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Score: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<p><code>tuple</code> 可以通过 <code>std::get&lt;index&gt;</code> 来访问每个元素，并且可以存储任意数量和类型的元素。</p>
<p><strong><code>pair</code>：一对数据存储</strong></p>
<ul>
<li><p><strong>功能：</strong> 存储两个不同类型的数据对，常用于 <strong><code>map</code></strong> 中的键值对存储。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br>std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：1, apple</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>tuple</code>：多数据存储</p>
<ul>
<li><p><strong>功能：</strong> 可存储任意数量、任意类型的元素，比 <code>pair</code> 更灵活。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">auto t = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>// 输出：<span class="hljs-number">1</span>, apple, <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>make_pair</code> 和 <code>make_tuple</code>：简化对象创建</strong></p>
<ul>
<li><p><strong>功能：</strong> 分别用于创建 <code>pair</code> 和 <code>tuple</code>，自动推导类型，简化代码。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code>, <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">auto</span> p = std::make_pair(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br><span class="hljs-attribute">auto</span> t = std::make_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>.<span class="hljs-number">5</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::move</code>：移动语义</p>
<ul>
<li><p><strong>功能：</strong> 用于将对象的资源移动到另一个对象，而不是复制，提高性能。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::string newStr = std::<span class="hljs-title function_ invoke__">move</span>(<span class="hljs-type">str</span>);  <span class="hljs-comment">// 将 str 移动到 newStr</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>std::forward</code>：完美转发</strong></p>
<ul>
<li><p><strong>功能：</strong> 在模板函数中用于保持参数的值类别（左值或右值）。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> forwarded = std::forward&lt;T&gt;(arg);  <span class="hljs-comment">// 完美转发</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::swap</code>：交换两个对象的值</p>
<ul>
<li><p><strong>功能：</strong> 用于交换两个对象的内容。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-attribute">std</span>::swap(a, b);  // a 变为 <span class="hljs-number">20</span>，b 变为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::rel_ops</code>：自动实现关系运算符**</p>
<ul>
<li><p><strong>功能：</strong> 提供通用的关系运算符（如 <code>!=</code>, <code>&lt;=</code>），基于 <code>==</code> 和 <code>&lt;</code> 自动推导。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::rel_ops;  <span class="hljs-comment">// 开启运算符自动推导</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::reference_wrapper</code>：引用包装器</p>
<ul>
<li><p><strong>功能：</strong> 用于包装引用类型，方便存储在容器中。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;functional&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> n = <span class="hljs-number">10</span>;<br>std::<span class="hljs-built_in">ref</span>erence_wrapper&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">ref</span> = n;<br><span class="hljs-built_in">ref</span>.<span class="hljs-keyword">get</span>() = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 修改原始变量 n 的值为 20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>类型特性工具：<code>std::declval</code>、<code>std::enable_if</code> 等</p>
<ul>
<li><p><strong>功能：</strong> 帮助在模板元编程中处理类型推导和 SFINAE（替换失败不为错误）等问题。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code>、<code>&lt;type_traits&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">template</span> &lt;typename <span class="hljs-type">T</span>&gt;<br><span class="hljs-title">auto</span> create() -&gt; decl<span class="hljs-keyword">type</span>(<span class="hljs-type">T</span>()) &#123;<br>    return <span class="hljs-type">T</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>std::tie</code>：解构 <code>tuple</code> 或 <code>pair</code></strong></p>
<ul>
<li><p><strong>功能：</strong> 将 <code>tuple</code> 或 <code>pair</code> 中的元素解构为多个变量。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>std::string c;<br>std::<span class="hljs-built_in">tie</span>(a, b, c) = t;  <span class="hljs-comment">// 解构 tuple</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-优化技巧"><a href="#5-优化技巧" class="headerlink" title="5.优化技巧"></a>5.优化技巧</h3><p>在算法竞赛中，为了编写简洁高效的代码，争取时间并减少输入输出的繁琐步骤，常见的简便操作可以帮助你在紧张的比赛环境中提高编写和执行代码的效率。以下是一些常见的简便操作和优化技巧：</p>
<h4 id="1-快速输入输出"><a href="#1-快速输入输出" class="headerlink" title="1. 快速输入输出"></a>1. <strong>快速输入输出</strong></h4><p> 直接用scanf和printf就行</p>
<h4 id="2-使用宏定义减少代码量"><a href="#2-使用宏定义减少代码量" class="headerlink" title="2.使用宏定义减少代码量"></a>2.<strong>使用宏定义减少代码量</strong></h4><p>宏可以用于减少输入输出、常用算法或者常用数据结构的代码量。虽然宏定义过多可能影响代码的可读性，但在竞赛中可以帮助你快速编写代码。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  <span class="hljs-comment">// 引入所有标准库头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long  <span class="hljs-comment">// 定义long long，避免重复写</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);  <span class="hljs-comment">// 使用 %lld 来读取 long long 类型</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;q[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, q[i]);  <span class="hljs-comment">// 输出排序后的数组</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-使用-STL-简化操作"><a href="#3-使用-STL-简化操作" class="headerlink" title="3. 使用 STL 简化操作"></a>3. <strong>使用 STL 简化操作</strong></h4><p>C++ 标准模板库（STL）提供了丰富的容器和算法，可以大幅减少代码量和开发时间。在竞赛中常用的有：</p>
<p><strong><code>std::vector</code> 和 <code>std::pair</code></strong></p>
<ul>
<li><code>vector</code> 是动态数组，非常适合存储大规模数据。</li>
<li><code>pair</code> 用于存储两个相关联的值，常用于排序和存储坐标、键值对等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;&#125;;<br>    <br>    <span class="hljs-comment">// 使用sort对pair进行排序，按照first排序</span><br>    <span class="hljs-built_in">sort</span>(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : vp) &#123;<br>        cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>常用 STL 函数：<code>sort</code>、<code>max_element</code>、<code>min_element</code></strong></p>
<p>使用 STL 提供的算法库，如 <code>sort</code>、<code>max_element</code> 等，可以快速实现排序和最大最小值的查找，避免手动实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 查找最大值和最小值</span><br>    <span class="hljs-type">int</span> maxVal = *<span class="hljs-built_in">max_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> minVal = *<span class="hljs-built_in">min_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Max: &quot;</span> &lt;&lt; maxVal &lt;&lt; <span class="hljs-string">&quot;, Min: &quot;</span> &lt;&lt; minVal &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-使用-auto-减少冗长的类型声明"><a href="#4-使用-auto-减少冗长的类型声明" class="headerlink" title="4. 使用 auto 减少冗长的类型声明"></a>4. <strong>使用 <code>auto</code> 减少冗长的类型声明</strong></h4><p><code>auto</code> 关键字允许编译器自动推导变量类型，特别是在使用复杂的 STL 容器时，它可以显著减少代码的长度和复杂性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vec = vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动推导类型</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : vec) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出 1 2 3</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-位操作优化"><a href="#5-位操作优化" class="headerlink" title="5. 位操作优化"></a>5. <strong>位操作优化</strong></h4><p>位操作是非常高效的操作，它能让很多算法在常数时间内完成操作。常见的应用包括判断奇偶性、交换数值、位掩码操作等。</p>
<p><strong>常见的位操作技巧</strong>：</p>
<ul>
<li><p><strong>判断奇偶</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &amp; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果 n 的最低位是 1 则为奇数，否则为偶数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>交换两个数</strong>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">void</span> swap(int &amp;a, int &amp;b) &#123;<br>    <span class="hljs-attribute">a</span> = a<span class="hljs-regexp"> ^</span> b;<br>    <span class="hljs-attribute">b</span> = a<span class="hljs-regexp"> ^</span> b;<br>    <span class="hljs-attribute">a</span> = a<span class="hljs-regexp"> ^</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>快速计算 2 的幂</strong>：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">bool isPowerOfTwo(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>    return (<span class="hljs-built_in">n</span> &gt; <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">n</span> &amp; (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;  // <span class="hljs-built_in">n</span> 是 <span class="hljs-number">2</span> 的幂时，其二进制中只有一个 <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="蓝桥杯备考"><a href="#蓝桥杯备考" class="headerlink" title="蓝桥杯备考"></a>蓝桥杯备考</h1><p>C++代码中的操作次数控制在 10的7为最佳。64MB相当于10的7个int</p>
<h2 id="N的范围判断算法是什么"><a href="#N的范围判断算法是什么" class="headerlink" title="N的范围判断算法是什么"></a>N的范围判断算法是什么</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>n &lt; <span class="hljs-number">30</span>,指数级别, dfs+剪枝，状态压缩dp<br><span class="hljs-number">2.</span>n &lt; <span class="hljs-number">100</span>=&gt;<span class="hljs-number">0</span>(n)，foyd, dp<br><span class="hljs-number">3.</span>n&lt;<span class="hljs-number">1000</span>=&gt;<span class="hljs-number">0</span>(n2)，<span class="hljs-number">0</span>(n?logn)，dp，二分<br><span class="hljs-number">4.</span>n ≤ <span class="hljs-number">10000</span> =&gt;<span class="hljs-number">0</span>(n* √n)，块状链表<br><span class="hljs-number">5.</span>&lt; <span class="hljs-number">100000</span>=&gt;<span class="hljs-number">0</span>(nlogn)=&gt;各种sort，线段树、树状数组、<span class="hljs-built_in">set</span>/<span class="hljs-built_in">map</span>、heap、dijkstratheap、spfa、求凸包、求半<br>平面交、二分<br><span class="hljs-number">6.</span>n&lt; <span class="hljs-number">1000000</span> =&gt; <span class="hljs-number">0</span>(m),以及常数较小的 <span class="hljs-number">0</span>(nlogn)算法=&gt;hash、双指针扫描、kmp、AC自动机，常数比较小的O(nlogn)的做法:sort、树状数组、heap、dijkstra、spfa<br><span class="hljs-number">7.</span>n &lt; <span class="hljs-number">10000000</span> =&gt;<span class="hljs-number">0</span>(n)，双指针扫描、kmp、AC自动机、线性筛素数<br><span class="hljs-number">8.</span>n ≤ <span class="hljs-number">10</span>° =&gt;O(√π)，判断质数<br><span class="hljs-number">9.</span>n&lt; <span class="hljs-number">1018</span> =&gt;<span class="hljs-number">0</span>(logn)，最大公约数<br></code></pre></td></tr></table></figure>

<h2 id="最基础的部分："><a href="#最基础的部分：" class="headerlink" title="最基础的部分："></a>最基础的部分：</h2><p>顺序，选择，循环，数组，函数，字符串，结构体(类)的语法(必会)，高精度 ，组合数的思想，概率论与期望常见公式，找规律能力，进制转换</p>
<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p>一维前缀和差分与二维前缀和差分(必会，思想很简单)</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>链表，队列，栈(模拟)，优先列队&#x2F;堆，哈希表，单调栈，单调队列，二维单调队列(求解子矩阵最值，尽量会)，并查集，树状数组(解决单点修改，区间求和问题，尽量会，一般考就压轴)，线段树</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>dfs(回溯),bfs(必会，比较简单，解决等权值最小路径问题),二进制枚举(必会，近三年填空题考的多，用二进制位01表示选和不选)</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记忆化搜索(尽可能会，因为基本上所有dp题都可以用记搜)</p>
<p>线性dp(必会，考的非常多与频繁，前几年基本上一场会出现至少二题线性dp，去年没考)</p>
<p>背包问题与背包计数(必会，01，完全，多重，还有个整数划分问题)</p>
<p>区间dp,树形dp,数位dp,状压dp</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>最大公约数，最小公倍数，唯一分解定理(必会)<br>素数，素数筛法 (必会)<br>快速幂，费马小定理求逆元(必会)<br>排列组合，第二类斯特林数(必会)<br>概率论与期望公式(尽量会，去年第一次考，然后每年都会考均值期望)<br>矩阵乘法(尽量会，近几年没考过)<br>数论分块(尽量会，近几年没考过)</p>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>单起点多终点正权最短路(必会，dijikstra)<br>单起点多终点负权最短路(必会，Bellmanford，spfa)<br>多起点多终点最短路(必会，Floy 记住循环kij就好）<br>最小瓶颈路<br>最小生成树<br>最近公共祖光(Ica)尽量会)</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串哈希(必会，尤其是与二分结合的思想以及回文半径回文中心的思想)<br>kmp(必会，会求周期)<br>manacher(求回文串，尽可能会)<br>字典树(尽可能会)</p>
<hr>
<h1 id="C-算法详细内容"><a href="#C-算法详细内容" class="headerlink" title="C++算法详细内容"></a>C++算法详细内容</h1><h2 id="基础数据结构和算法-1"><a href="#基础数据结构和算法-1" class="headerlink" title="基础数据结构和算法"></a><strong>基础数据结构和算法</strong></h2><h3 id="1-基础语法与数据类型-1"><a href="#1-基础语法与数据类型-1" class="headerlink" title="1. 基础语法与数据类型"></a>1. <strong>基础语法与数据类型</strong></h3><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>C++ 通过 <code>cin</code> 和 <code>cout</code> 来处理输入和输出。(慢统一用scanfprintf)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Enter your age: &quot;</span>;<br>std::cin &gt;&gt; age;  <span class="hljs-comment">// 输入年龄</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Your age is: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;  <span class="hljs-comment">// 输出年龄</span><br></code></pre></td></tr></table></figure>

<p>scanf和printf</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">scanf(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> <span class="hljs-variable">%f</span> <span class="hljs-variable">%lf</span> <span class="hljs-variable">%s</span>&quot;</span>, &amp;a, &amp;b, &amp;c, str);<span class="hljs-regexp">//</span> Double: <span class="hljs-variable">%lf</span>， 默认保留<span class="hljs-number">6</span>位小数,Char: <span class="hljs-variable">%c</span>, 回车也是一个字符，用’\n’表示<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的整数是: <span class="hljs-variable">%d</span>\n&quot;</span>, a);<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的浮点数是: <span class="hljs-variable">%.</span>2f\n&quot;</span>, b);  <span class="hljs-regexp">//</span> 控制浮点数输出保留两位小数<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的双精度浮点数是: <span class="hljs-variable">%.</span>3lf\n&quot;</span>, c);  <span class="hljs-regexp">//</span> 控制双精度浮点数输出保留三位小数<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;输入的字符串是: <span class="hljs-variable">%s</span>\n&quot;</span>, str);<br></code></pre></td></tr></table></figure>

<h4 id="基本数学函数"><a href="#基本数学函数" class="headerlink" title="基本数学函数"></a><strong>基本数学函数</strong></h4><ul>
<li><strong><code>abs(int x)</code></strong>: 返回整数 <code>x</code> 的绝对值。</li>
<li><strong><code>fabs(double x)</code></strong>: 返回浮点数 <code>x</code> 的绝对值。</li>
<li><strong><code>sqrt(double x)</code></strong>: 返回 <code>x</code> 的平方根。</li>
<li><strong><code>pow(double base, double exp)</code></strong>: 返回 <code>base</code> 的 <code>exp</code> 次方。</li>
<li><strong><code>exp(double x)</code></strong>: 返回 <code>e</code> 的 <code>x</code> 次方。</li>
<li><strong><code>log(double x)</code></strong>: 返回 <code>x</code> 的自然对数。</li>
<li><strong><code>log10(double x)</code></strong>: 返回 <code>x</code> 的以 10 为底的对数。</li>
<li><strong><code>ceil(double x)</code></strong>: 返回大于或等于 <code>x</code> 的最小整数。</li>
<li><strong><code>floor(double x)</code></strong>: 返回小于或等于 <code>x</code> 的最大整数。</li>
<li><strong><code>round(double x)</code></strong>: 返回最接近 <code>x</code> 的整数。</li>
</ul>
<p><strong>三角函数</strong></p>
<ul>
<li><strong><code>sin(double x)</code></strong>: 返回 <code>x</code> 的正弦值。</li>
<li><strong><code>cos(double x)</code></strong>: 返回 <code>x</code> 的余弦值。</li>
<li><strong><code>tan(double x)</code></strong>: 返回 <code>x</code> 的正切值。</li>
<li><strong><code>asin(double x)</code></strong>: 返回 <code>x</code> 的反正弦值。</li>
<li><strong><code>acos(double x)</code></strong>: 返回 <code>x</code> 的反余弦值。</li>
<li><strong><code>atan(double x)</code></strong>: 返回 <code>x</code> 的反正切值。</li>
<li><strong><code>atan2(double y, double x)</code></strong>: 计算 <code>y/x</code> 的反正切值，考虑象限。</li>
</ul>
<p><strong>常数</strong></p>
<ul>
<li><strong><code>M_PI</code></strong>: <code>π</code> 的值。</li>
<li><strong><code>M_E</code></strong>: <code>e</code> 的值。</li>
</ul>
<p><strong>其他函数</strong></p>
<ul>
<li><strong><code>modf(double x, double\* intpart)</code></strong>: 拆分 <code>x</code> 为整数部分和小数部分。</li>
<li><strong><code>fmod(double x, double y)</code></strong>: 返回 <code>x</code> 除 <code>y</code> 的余数。</li>
<li><strong><code>hypot(double x, double y)</code></strong>: 返回 <code>sqrt(x^2 + y^2)</code>。</li>
</ul>
<p><strong>随机数</strong></p>
<ul>
<li><strong><code>rand()</code></strong>: 返回一个随机整数。</li>
<li><strong><code>srand(unsigned int seed)</code></strong>: 设置随机数种子。</li>
</ul>
<p><strong>特殊值判断</strong></p>
<ul>
<li><code>isnan(double x)</code>: 判断 <code>x</code> 是否为 NaN。</li>
<li><strong><code>isfinite(double x)</code></strong>: 判断 <code>x</code> 是否为有限值。</li>
<li><strong><code>isinf(double x)</code></strong>: 判断 <code>x</code> 是否为无穷大。</li>
</ul>
<p>+++++</p>
<h3 id="2-字符-1"><a href="#2-字符-1" class="headerlink" title="2.字符"></a>2.字符</h3><p>C++ 中，每个常用字符对应一个整数值，通常称为 ASCII 值。可以通过字符与对应的整数值相互转化。</p>
<ul>
<li><h4 id="字符与-ASCII-码：-1"><a href="#字符与-ASCII-码：-1" class="headerlink" title="字符与 ASCII 码："></a><strong>字符与 ASCII 码：</strong></h4><ul>
<li>‘A’ - ‘Z’ 对应的 ASCII 值是 65 ~ 90</li>
<li>‘a’ - ‘z’ 对应的 ASCII 值是 97 ~ 122</li>
<li>‘0’ - ‘9’ 对应的 ASCII 值是 48 ~ 57</li>
</ul>
</li>
<li><p><strong>字符可以参与运算：</strong></p>
<ul>
<li>运算时，字符会被当做整数处理，使用其对应的 ASCII 值。</li>
</ul>
</li>
</ul>
<p>字符串在 C++ 中本质上是一个字符数组，数组的末尾有一个特殊的结束符 <code>&#39;\0&#39;</code>。所以输出字符串就直接输出arr这个就行 char arr[]&#x3D;”hello world”;</p>
<h4 id="字符数组的常用操作-1"><a href="#字符数组的常用操作-1" class="headerlink" title="字符数组的常用操作"></a><strong>字符数组的常用操作</strong></h4><ol>
<li>**<code>strlen(str)</code>**：计算字符串长度。</li>
<li>**<code>strcmp(a, b)</code>**：比较两个字符串，按字典序比较。</li>
<li>**<code>strcpy(a, b)</code>**：将字符串 <code>b</code> 复制到 <code>a</code>。</li>
</ol>
<h4 id="标准库类型-string-1"><a href="#标准库类型-string-1" class="headerlink" title="标准库类型 string"></a>标准库类型 <code>string</code></h4><p><code>string</code> 是一个动态的字符序列 等同于char arr[]</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::string s2(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-regexp">//</span> 初始化为 <span class="hljs-string">&quot;ccccc&quot;</span><br></code></pre></td></tr></table></figure>



<p><strong><code>string</code> 上的常见操作</strong></p>
<ul>
<li><strong><code>getline</code> 读取一整行</strong></li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">getline</span>(cin, str);  <span class="hljs-comment">// 读取一整行输入</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>empty</code> 和 <code>size</code></strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::cout &lt;&lt; <span class="hljs-string">&quot;字符串是否为空: &quot;</span> &lt;&lt; <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">empty</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;字符串的长度: &quot;</span> &lt;&lt; <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">size</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>string</code> 的比较：</strong></li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"> <span class="hljs-meta">if</span> (<span class="hljs-built_in">s1</span> &lt; <span class="hljs-built_in">s2</span>) &#123;<br><span class="hljs-symbol">     std:</span>:cout &lt;&lt; <span class="hljs-built_in">s1</span> &lt;&lt; <span class="hljs-string">&quot; 小于 &quot;</span> &lt;&lt; <span class="hljs-built_in">s2</span> &lt;&lt; std::endl<span class="hljs-comment">;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>string</code> 赋值与拼接</strong></li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">std:</span>:string <span class="hljs-built_in">s3</span> = <span class="hljs-built_in">s1</span> + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">s2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>find查询子串</strong></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">if</span> (pos != std::string::npos) &#123;       <span class="hljs-regexp">//</span>如果没找到，返回std::string::npos<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found at position &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Not found&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>substr()</code></strong></p>
<p>从字符串中提取子串。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">std::string str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>std::string <span class="hljs-function"><span class="hljs-keyword">sub</span> = <span class="hljs-title">str</span>.<span class="hljs-title">substr</span></span>(7, 5);  // 从索引 <span class="hljs-number">7</span> 开始，提取 <span class="hljs-number">5</span> 个字符<br>std::cout &lt;&lt; <span class="hljs-function"><span class="hljs-keyword">sub</span></span>;  // 输出 <span class="hljs-string">&quot;world&quot;</span><br></code></pre></td></tr></table></figure>

<p> <strong><code>c_str()</code></strong></p>
<p>将 <code>std::string</code> 转换为 C 风格字符串（即以 <code>&#39;\0&#39;</code> 结尾的字符数组）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">c_str</span>();<br>std::cout &lt;&lt; cstr;  <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>c_str()</code> 返回一个指向字符串的常量指针（<code>const char*</code>）。</li>
</ul>
<p><strong><code>append()</code></strong></p>
<p>将另一个字符串或字符附加到当前字符串的末尾。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">cpp复制编辑std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">append</span>(<span class="hljs-string">&quot;, world!&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>push_back()</code></strong></p>
<p>向字符串末尾添加一个字符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-string">&#x27;!&#x27;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>insert()</code></strong></p>
<p>在指定位置插入字符或子字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;, beautiful&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello, beautiful world!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>insert(pos, str)</code>：在位置 <code>pos</code> 插入字符串 <code>str</code>。</li>
<li><code>insert(pos, n, c)</code>：在位置 <code>pos</code> 插入 <code>n</code> 个字符 <code>c</code>。</li>
</ul>
<p> <strong><code>erase()</code></strong></p>
<p>删除指定位置的字符或子字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">erase</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>);  <span class="hljs-comment">// 从索引 5 开始，删除 7 个字符</span><br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>erase(pos, len)</code>：删除从 <code>pos</code> 开始，长度为 <code>len</code> 的子串。</li>
</ul>
<p><strong><code>replace()</code></strong></p>
<p>替换指定位置的字符或子字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">cpp复制编辑std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;C++&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-type">str</span>;  <span class="hljs-comment">// 输出 &quot;Hello, C++!&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>replace(pos, len, str)</code>：从 <code>pos</code> 开始，删除 <code>len</code> 个字符并用 <code>str</code> 替换它们。</li>
</ul>
<p><strong><code>compare()</code></strong></p>
<p>比较两个字符串的大小（按字典序比较）。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;apple&quot;</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;banana&quot;</span>;<br>int result = str1.<span class="hljs-built_in">compare</span>(str2);  // 返回负值，因为 <span class="hljs-string">&quot;apple&quot;</span> 小于 <span class="hljs-string">&quot;banana&quot;</span><br><span class="hljs-built_in">std</span>::cout &lt;&lt; result;  // 输出负数<br></code></pre></td></tr></table></figure>

<ul>
<li><code>compare()</code>：返回值是 <code>0</code> 表示两个字符串相等，负值表示当前字符串小于比较字符串，正值表示当前字符串大于比较字符串。</li>
</ul>
<p><strong><code>find_first_of()</code></strong></p>
<p>查找字符串中第一个包含指定字符或字符集的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>size_t pos = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_first_of</span>(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找第一个元音字母的位置</span><br>std::cout &lt;&lt; pos;  <span class="hljs-comment">// 输出 1，表示 &#x27;e&#x27; 是第一个元音</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>find_first_of(str)</code>：返回第一次出现字符集中任意字符的索引位置。</li>
</ul>
<p> <strong><code>find_last_of()</code></strong></p>
<p>查找字符串中最后一个包含指定字符或字符集的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>size_t pos = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_last_of</span>(<span class="hljs-string">&quot;aeiou&quot;</span>);  <span class="hljs-comment">// 查找最后一个元音字母的位置</span><br>std::cout &lt;&lt; pos;  <span class="hljs-comment">// 输出 8，表示 &#x27;o&#x27; 是最后一个元音</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>find_last_of(str)</code>：返回最后一次出现字符集中的任意字符的位置。</li>
</ul>
<p><strong><code>rfind()</code></strong></p>
<p>从字符串的尾部开始查找指定子串的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world! world!&quot;</span>;<br>size_t pos = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">rfind</span>(<span class="hljs-string">&quot;world&quot;</span>);  <span class="hljs-comment">// 查找最后一次出现 &quot;world&quot; 的位置</span><br>std::cout &lt;&lt; pos;  <span class="hljs-comment">// 输出 13</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>rfind(str)</code>：返回从尾部开始查找子串的位置。</li>
</ul>
<p> <strong><code>to_string()</code></strong></p>
<p>将数字类型转换为字符串。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">int <span class="hljs-built_in">num</span> = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = <span class="hljs-built_in">std</span>::to_string(<span class="hljs-built_in">num</span>);  // <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-built_in">std</span>::cout &lt;&lt; str;<br></code></pre></td></tr></table></figure>

<p><strong><code>stoi()</code>, <code>stol()</code>, <code>stof()</code>, <code>stod()</code> 等</strong></p>
<p>将字符串转换为整数、长整型、浮点数等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;12345&quot;</span>;<br>int num = std::<span class="hljs-title function_ invoke__">stoi</span>(<span class="hljs-type">str</span>);  <span class="hljs-comment">// 将字符串转换为整数</span><br>std::cout &lt;&lt; num;  <span class="hljs-comment">// 输出 12345</span><br></code></pre></td></tr></table></figure>

<p> <strong><code>trim()</code> (自定义实现)</strong></p>
<p>C++ 标准库并没有直接提供 <code>trim</code> 函数来去除字符串两端的空白字符，但你可以通过自定义函数来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-keyword">const</span> std::string&amp; <span class="hljs-type">str</span>) &#123;<br>    auto start = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_first_not_of</span>(<span class="hljs-string">&quot; \t\n\r&quot;</span>);<br>    auto end = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">find_last_not_of</span>(<span class="hljs-string">&quot; \t\n\r&quot;</span>);<br>    <span class="hljs-title function_ invoke__">return</span> (start == std::string::npos || end == std::string::npos) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">substr</span>(start, end - start + <span class="hljs-number">1</span>);<br>&#125;<br><br>int <span class="hljs-title function_ invoke__">main</span>() &#123;<br>    std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;   Hello, world!   &quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-type">str</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;|Hello, world!|&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>++++</p>
<h3 id="3-函数-1"><a href="#3-函数-1" class="headerlink" title="3.函数"></a>3.函数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。当函数的形参为引用类型时，对形参的修改会影响实参的值。使用引用的作用：避免拷贝、让函数返回额外信息。</p>
<p>++++</p>
<h3 id="4-STL-1"><a href="#4-STL-1" class="headerlink" title="4.STL"></a>4.STL</h3><h4 id="一-STL-的主要组成部分-1"><a href="#一-STL-的主要组成部分-1" class="headerlink" title="一.STL 的主要组成部分"></a>一.STL 的主要组成部分</h4><ol>
<li>**容器 (Containers)**：用来存储和管理数据的集合。</li>
<li>**算法 (Algorithms)**：用于对数据进行操作，如排序、查找、修改等。</li>
<li>**迭代器 (Iterators)**：用于遍历容器中的元素，提供统一的访问接口。</li>
</ol>
<hr>
<h4 id="二、容器-Containers-1"><a href="#二、容器-Containers-1" class="headerlink" title="二、容器 (Containers)"></a>二、容器 (Containers)</h4><p>STL 容器分为三类：<strong>顺序容器</strong>、<strong>关联容器</strong>和<strong>无序关联容器</strong>。</p>
<h5 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h5><p>顺序容器存储数据时，元素按插入顺序排列，常见的顺序容器有：</p>
<ul>
<li>**<code>vector</code>**：动态数组，支持快速随机访问。</li>
<li>**<code>deque</code>**：双端队列，支持两端快速插入和删除。</li>
<li>**<code>list</code>**：双向链表，支持双向遍历，插入和删除操作效率较高。</li>
<li>**<code>array</code>**：定长数组（C++11 引入），存储固定大小的数据。</li>
<li>**<code>forward_list</code>**：单向链表（C++11 引入），支持单向遍历。</li>
</ul>
<p><strong><code>vector</code></strong> 动态数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 初始化</span><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 尾部添加元素</span><br>vec[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;        <span class="hljs-comment">// 随机访问</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 5 3 4</span><br> &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>deque</code></strong> 双端队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::deque&lt;<span class="hljs-type">int</span>&gt; dq = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入元素</span><br>dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入元素</span><br>dq.<span class="hljs-built_in">pop_front</span>();    <span class="hljs-comment">// 移除头部元素</span><br>dq.<span class="hljs-built_in">pop_back</span>();     <span class="hljs-comment">// 移除尾部元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : dq) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：2 3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>list</code></strong> 双向链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br> lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入</span><br> lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);   <span class="hljs-comment">// 在尾部插入</span><br> lst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 移除值为2的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : lst) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：0 1 3 4</span><br> &#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>array</code></strong> 定长数组（C++11）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 固定大小为3的数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>forward_list</code></strong> 单向链表（C++11）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::forward_list&lt;<span class="hljs-type">int</span>&gt; flst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>flst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 头部插入</span><br>flst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 移除值为2的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : flst) &#123;<br>     std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：0 1 3</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a><strong>关联容器</strong></h5><p>关联容器基于平衡二叉树（通常是红黑树）实现，元素按键值排序，支持快速查找、插入和删除操作。常见的关联容器有：</p>
<ul>
<li>**<code>set</code>**：存储唯一的元素，自动按元素的键值排序。</li>
<li>**<code>map</code>**：键值对（key-value）形式存储元素，按键排序。</li>
<li>**<code>multiset</code>**：存储允许重复的元素，按键排序。</li>
<li>**<code>multimap</code>**：存储允许重复的键值对，按键排序。</li>
</ul>
<p><strong><code>set</code></strong> 存储唯一元素，自动排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动排序，重复元素被忽略</span><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : s) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>map</code></strong> 键值对形式存储，按键排序</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m = &#123;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;&#125;; <span class="hljs-comment">// 自动排序，重复键的值会被覆盖</span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; m;<br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>m[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>m[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : m) &#123;<br>    std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">// 输出：apple: 3 banana: 2 orange: 4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>multiset</code></strong> 存储允许重复元素，按键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::multiset&lt;<span class="hljs-type">int</span>&gt; ms = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 插入重复元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ms) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 1 2 2 3 4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>multimap</code></strong> 存储允许重复的键值对，按键排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::multimap&lt;std::string, <span class="hljs-type">int</span>&gt; mm;<br>mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;);<br>mm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>&#125;);  <span class="hljs-comment">// 相同键可以重复插入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : mm) &#123;<br>    std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出： apple: 3 apple: 5 banana: 2</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a><strong>无序关联容器</strong></h5><p>无序关联容器是基于哈希表实现的容器，元素无序排列，但支持常数时间复杂度的查找、插入和删除操作。常见的无序关联容器有：</p>
<ul>
<li>**<code>unordered_set</code>**：无序集合，元素唯一。</li>
<li>**<code>unordered_map</code>**：无序键值对，基于哈希表存储。</li>
<li>**<code>unordered_multiset</code>**：无序多重集合，允许重复元素。</li>
<li>**<code>unordered_multimap</code>**：无序多重键值对，允许重复键。</li>
</ul>
<p><strong><code>unordered_set</code></strong> 无序集合，元素唯一</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_set&lt;<span class="hljs-type">int</span>&gt; uset = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">// 重复的1被忽略</span><br>uset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 插入新元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : uset) &#123;<br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出顺序不固定，例如：3 1 2 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>unordered_map</code></strong> 无序键值对，基于哈希表存储</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; umap;<br>umap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">3</span>;<br>umap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>umap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : umap) &#123;<br>    std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-comment">// 输出顺序不固定，例如：</span><br>banana: <span class="hljs-number">2</span> apple: <span class="hljs-number">3</span> orange: <span class="hljs-number">4</span><br> &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>unordered_multiset</code></strong> 无序多重集合，允许重复元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_multiset&lt;<span class="hljs-type">int</span>&gt; ums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>ums.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 插入重复元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ums) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出顺序不固定，例如：1 1 2 2 3 4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>unordered_multimap</code></strong> 无序多重键值对，允许重复键</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_multimap&lt;std::string, <span class="hljs-type">int</span>&gt; umm;<br>umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>&#125;);<br>umm.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>&#125;);  <span class="hljs-comment">// 相同键可以重复插入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [key, value] : umm) &#123;<br>  	std::cout &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出顺序不固定，例如： apple: 3 apple: 5 banana: 2</span><br> &#125;<br><br></code></pre></td></tr></table></figure>





<hr>
<h4 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h4><p>STL 提供了一系列的算法来操作容器，如排序、查找、修改等。这些算法定义在头文件 <code>&lt;algorithm&gt;</code> 中，并且可以通过迭代器访问容器的元素。</p>
<h5 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a><strong>常用算法</strong></h5><ul>
<li>**<code>sort</code>**：对容器进行排序。</li>
<li>**<code>find</code>**：查找某个元素。</li>
<li>**<code>binary_search</code>**：二分查找，要求容器是有序的。</li>
<li>**<code>reverse</code>**：将容器中的元素反转。</li>
<li>**<code>accumulate</code>**：计算容器中元素的累加和。</li>
<li>**<code>count</code>**：统计容器中某个元素的出现次数。</li>
</ul>
<p><strong><code>sort</code></strong> 对容器进行排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 升序排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>    std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>find</code></strong> 查找某个元素</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::vector&lt;int&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>auto it = std::find(vec.<span class="hljs-keyword">begin</span>(), vec.<span class="hljs-keyword">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-keyword">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-regexp">//</span> 输出：<span class="hljs-title class_">Element</span> <span class="hljs-symbol">found:</span> <span class="hljs-number">3</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>binary_search</code></strong> 二分查找（要求容器是有序的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">bool</span> found = std::<span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (found) &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>reverse</code></strong> 将容器中的元素反转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">reverse</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) &#123;<br>   std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>accumulate</code></strong> 计算容器中元素的累加和</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">std</span>::vector&lt;int&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-attribute">int</span> sum = std::accumulate(vec.begin(), vec.end(), <span class="hljs-number">0</span>);  // 初始值为<span class="hljs-number">0</span><br><span class="hljs-attribute">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  // 输出：Sum: <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>

<p><strong><code>count</code></strong> 统计容器中某个元素的出现次数</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">std</span>::vector&lt;int&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-attribute">int</span> cnt = std::count(vec.begin(), vec.end(), <span class="hljs-number">2</span>);<br><span class="hljs-attribute">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Count of 2: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  // 输出：Count of <span class="hljs-number">2</span>: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>



<h5 id="自定义比较函数"><a href="#自定义比较函数" class="headerlink" title="自定义比较函数"></a><strong>自定义比较函数</strong></h5><p><strong><code>sort</code></strong> 使用自定义比较函数</p>
<p>默认情况下，<code>std::sort</code> 会进行升序排序。我们可以通过传递一个自定义比较函数来控制排序方式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 自定义比较函数，实现降序排序</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">descending</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>std::vector&lt;<span class="hljs-built_in">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>std::sort(vec.begin(), vec.end(), <span class="hljs-keyword">descending</span>);  <span class="hljs-comment">// 使用自定义比较函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> v : vec) &#123;<br>      std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>find_if</code></strong> 使用自定义条件</p>
<p><code>std::find_if</code> 可根据自定义的 <strong>谓词函数</strong> 查找符合条件的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 自定义谓词函数，查找第一个大于3的元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">greaterThanThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">3</span>;<br>&#125;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), greaterThanThree);<br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>()) &#123;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;First element greater than 3: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：4</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br> 	 std::cout &lt;&lt; <span class="hljs-string">&quot;No element found\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>binary_search</code></strong> 自定义比较函数</p>
<p><code>std::binary_search</code> 也可以接受自定义的比较函数，但要求容器中的元素按该规则预先排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 自定义比较函数，进行降序比较</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">descending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">std</span>::sort(vec.begin(), vec.end(), descending);  <span class="hljs-comment">// 降序排序</span><br><span class="hljs-type">bool</span> found = <span class="hljs-built_in">std</span>::binary_search(vec.begin(), vec.end(), <span class="hljs-number">3</span>, descending);<br><span class="hljs-keyword">if</span> (found) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Element found\n&quot;</span>;  <span class="hljs-comment">// 输出：Element found</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Element not found\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>set</code></strong> 自定义比较函数（按降序存储）</p>
<p>C++ 中的 <strong><code>std::set</code></strong> 默认是升序排序。我们可以自定义一个比较函数来改变排序顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 自定义比较函数，按降序排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Descending</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br>std::set&lt;<span class="hljs-type">int</span>, Descending&gt; s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : s) &#123;<br>     std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出：5 4 3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>priority_queue</code></strong> 自定义比较函数（实现小顶堆）</p>
<p><code>std::priority_queue</code> 默认是大顶堆，我们可以通过自定义比较函数创建小顶堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义比较器：根据整数的绝对值大小来排序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CompareAbs</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);  <span class="hljs-comment">// 绝对值小的优先</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 这里定义一个堆类型别名</span><br><span class="hljs-keyword">using</span> MinHeap = priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt;;  <span class="hljs-comment">// 最小堆</span><br><span class="hljs-keyword">using</span> MaxHeap = priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, std::less&lt;<span class="hljs-type">int</span>&gt;&gt;;     <span class="hljs-comment">// 最大堆</span><br><span class="hljs-keyword">using</span> AbsHeap = priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, CompareAbs&gt;;          <span class="hljs-comment">// 自定义堆（按绝对值排序）</span><br><br><span class="hljs-comment">// 插入元素</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> HeapType&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(HeapType&amp; pq, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    pq.<span class="hljs-built_in">push</span>(value);<br>&#125;<br><br><span class="hljs-comment">// 提取堆顶元素</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> HeapType&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extractTop</span><span class="hljs-params">(HeapType&amp; pq)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Heap is empty!&quot;</span>);<br>    <span class="hljs-type">int</span> topValue = pq.<span class="hljs-built_in">top</span>();<br>    pq.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> topValue;<br>&#125;<br><br><span class="hljs-comment">// 查看堆顶元素</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> HeapType&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">(HeapType&amp; pq)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Heap is empty!&quot;</span>);<br>    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-comment">// 打印堆中的元素（辅助函数，用于调试）</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> HeapType&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printHeap</span><span class="hljs-params">(HeapType&amp; pq)</span> </span>&#123;<br>    HeapType temp = pq; <span class="hljs-comment">// 创建一个副本，以便不破坏原堆</span><br>    <span class="hljs-keyword">while</span> (!temp.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; temp.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        temp.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用最小堆</span><br>    MinHeap minHeap;<br>    <span class="hljs-built_in">insert</span>(minHeap, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">insert</span>(minHeap, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">insert</span>(minHeap, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">insert</span>(minHeap, <span class="hljs-number">15</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Min heap after insertions: &quot;</span>;<br>    <span class="hljs-built_in">printHeap</span>(minHeap);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Extract top: &quot;</span> &lt;&lt; <span class="hljs-built_in">extractTop</span>(minHeap) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Min heap after extraction: &quot;</span>;<br>    <span class="hljs-built_in">printHeap</span>(minHeap);<br><br>    <span class="hljs-comment">// 使用最大堆</span><br>    MaxHeap maxHeap;<br>    <span class="hljs-built_in">insert</span>(maxHeap, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">insert</span>(maxHeap, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">insert</span>(maxHeap, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">insert</span>(maxHeap, <span class="hljs-number">15</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Max heap after insertions: &quot;</span>;<br>    <span class="hljs-built_in">printHeap</span>(maxHeap);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Extract top: &quot;</span> &lt;&lt; <span class="hljs-built_in">extractTop</span>(maxHeap) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Max heap after extraction: &quot;</span>;<br>    <span class="hljs-built_in">printHeap</span>(maxHeap);<br><br>    <span class="hljs-comment">// 使用按绝对值排序的堆</span><br>    AbsHeap absHeap;<br>    <span class="hljs-built_in">insert</span>(absHeap, <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">insert</span>(absHeap, <span class="hljs-number">-20</span>);<br>    <span class="hljs-built_in">insert</span>(absHeap, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">insert</span>(absHeap, <span class="hljs-number">-15</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Abs heap after insertions: &quot;</span>;<br>    <span class="hljs-built_in">printHeap</span>(absHeap);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Extract top: &quot;</span> &lt;&lt; <span class="hljs-built_in">extractTop</span>(absHeap) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Abs heap after extraction: &quot;</span>;<br>    <span class="hljs-built_in">printHeap</span>(absHeap);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<hr>
<h4 id="四、迭代器-Iterators-1"><a href="#四、迭代器-Iterators-1" class="headerlink" title="四、迭代器 (Iterators)"></a>四、迭代器 (Iterators)</h4><p>迭代器提供了一种统一的方式来遍历 STL 容器。常见的迭代器类型有：</p>
<ul>
<li>**<code>begin()</code> 和 <code>end()</code>**：返回指向容器第一个元素和尾后元素的迭代器。</li>
<li>**<code>rbegin()</code> 和 <code>rend()</code>**：返回逆序迭代器，分别指向最后一个元素和第一个元素之前的位置。</li>
<li>**<code>cbegin()</code> 和 <code>cend()</code>**：返回常量迭代器，不能用于修改元素。</li>
</ul>
<p>迭代器可以通过 <code>*it</code> 解引用访问元素，通过 <code>++it</code> 或 <code>--it</code> 移动到下一个或上一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 使用普通迭代器遍历</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using iterator: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>      std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 使用常量迭代器遍历</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using const_iterator: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">cbegin</span>(); it != vec.<span class="hljs-built_in">cend</span>(); ++it) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 使用逆序迭代器遍历</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Elements using reverse_iterator: &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">rbegin</span>(); it != vec.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>



<hr>
<h4 id="五-辅助工具类（Utility-Components）-1"><a href="#五-辅助工具类（Utility-Components）-1" class="headerlink" title="五.辅助工具类（Utility Components）"></a>五.辅助工具类（Utility Components）</h4><ul>
<li><strong>数据结构</strong>：<code>pair</code>、<code>tuple</code>、<code>make_pair</code>、<code>make_tuple</code></li>
<li><strong>移动语义和转发</strong>：<code>std::move</code>、<code>std::forward</code></li>
<li><strong>交换和引用</strong>：<code>std::swap</code>、<code>std::reference_wrapper</code></li>
<li><strong>关系运算符</strong>：<code>std::rel_ops</code></li>
<li><strong>类型特性工具</strong>：<code>std::declval</code>、<code>std::enable_if</code></li>
<li><strong>解构支持</strong>：<code>std::tie</code></li>
</ul>
<p><strong><code>pair</code> 的基本使用</strong></p>
<p><code>pair</code> 的定义在 <code>&lt;utility&gt;</code> 头文件中，通常用 <code>std::make_pair</code> 函数来创建一个 <code>pair</code>，也可以直接使用构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 make_pair 函数创建一个 pair</span><br>std::pair&lt;std::string, <span class="hljs-type">int</span>&gt; student = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-comment">// 访问 pair 中的元素</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; student.first &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; student.second &lt;&lt; std::endl;<br><span class="hljs-comment">// 也可以直接使用构造函数初始化 pair</span><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">score</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">98.5</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Rank: &quot;</span> &lt;&lt; score.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; score.second &lt;&lt; std::endl;<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>pair</code> 的成员</strong></li>
</ol>
<ul>
<li><code>first</code>: 表示 <code>pair</code> 中的第一个元素。</li>
<li><code>second</code>: 表示 <code>pair</code> 中的第二个元素。</li>
</ul>
<p>可以通过 <code>pair.first</code> 和 <code>pair.second</code> 分别访问两个值。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>)</span></span>;  <span class="hljs-comment">// 初始化pair，第一个元素是int，第二个是char</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p.first &lt;&lt; std::endl;  <span class="hljs-comment">// 输出10</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Second: &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;  <span class="hljs-comment">// 输出&#x27;A&#x27;</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>与容器结合使用</strong></li>
</ol>
<p><code>pair</code> 在 STL 容器中非常常用，特别是在关联容器（如 <code>map</code> 和 <code>set</code>）中，<code>pair</code> 用于表示键值对。在 <code>map</code> 中，键值对的每个元素实际上是一个 <code>pair</code>，其中 <code>first</code> 是键，<code>second</code> 是值。</p>
<p>在 <code>map</code> 中使用 <code>pair</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 创建一个 map 来存储学生姓名和分数</span><br> std::map&lt;std::string, <span class="hljs-type">int</span>&gt; studentScores;<br><span class="hljs-comment">// 插入键值对，使用 make_pair 函数</span><br>studentScores.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90</span>));<br>studentScores.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">85</span>));<br><span class="hljs-comment">// 访问 map 中的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : studentScores) &#123;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; entry.first &lt;&lt; <span class="hljs-string">&quot;, Score: &quot;</span> &lt;&lt; entry.second &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// 也可以通过 [] 操作符直接访问键值对</span><br>studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] = <span class="hljs-number">88</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Charlie&#x27;s Score: &quot;</span> &lt;&lt; studentScores[<span class="hljs-string">&quot;Charlie&quot;</span>] &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>比较 <code>pair</code></strong></li>
</ol>
<p><code>pair</code> 支持比较操作（如 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等）。比较规则是先比较 <code>first</code> 元素，如果 <code>first</code> 相等，则比较 <code>second</code> 元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p1 is less than p2&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 比较的是 first，若相等，则比较 second</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>p1</code> 和 <code>p2</code> 的 <code>first</code> 部分相同，比较结果取决于 <code>second</code> 部分。</p>
<ol start="5">
<li><strong><code>pair</code> 的常见用法</strong></li>
</ol>
<ul>
<li><p><strong>作为函数的返回值</strong>：当你需要从函数中返回多个值时，<code>pair</code> 可以作为方便的结构体来返回两个值，而不需要创建专门的结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">getMinMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(a, b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(b, a);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getMinMax</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Min: &quot;</span> &lt;&lt; result.first &lt;&lt; <span class="hljs-string">&quot;, Max: &quot;</span> &lt;&lt; result.second &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><strong><code>tuple</code> 作为扩展</strong></li>
</ol>
<p><code>pair</code> 只能存储两个相关联的值。如果你需要存储更多的值，可以使用 C++11 引入的 <code>tuple</code>，它是 <code>pair</code> 的扩展版，可以存储任意多个元素。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-type">double</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">90.5</span>)</span></span>;<br><span class="hljs-comment">// 访问 tuple 中的元素</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;ID: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Score: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<p><code>tuple</code> 可以通过 <code>std::get&lt;index&gt;</code> 来访问每个元素，并且可以存储任意数量和类型的元素。</p>
<p><strong><code>pair</code>：一对数据存储</strong></p>
<ul>
<li><p><strong>功能：</strong> 存储两个不同类型的数据对，常用于 <strong><code>map</code></strong> 中的键值对存储。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br>std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 输出：1, apple</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>tuple</code>：多数据存储</p>
<ul>
<li><p><strong>功能：</strong> 可存储任意数量、任意类型的元素，比 <code>pair</code> 更灵活。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">auto t = <span class="hljs-built_in">std</span>::make_tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>// 输出：<span class="hljs-number">1</span>, apple, <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>make_pair</code> 和 <code>make_tuple</code>：简化对象创建</strong></p>
<ul>
<li><p><strong>功能：</strong> 分别用于创建 <code>pair</code> 和 <code>tuple</code>，自动推导类型，简化代码。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code>, <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">auto</span> p = std::make_pair(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br><span class="hljs-attribute">auto</span> t = std::make_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>.<span class="hljs-number">5</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::move</code>：移动语义</p>
<ul>
<li><p><strong>功能：</strong> 用于将对象的资源移动到另一个对象，而不是复制，提高性能。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::string <span class="hljs-type">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::string newStr = std::<span class="hljs-title function_ invoke__">move</span>(<span class="hljs-type">str</span>);  <span class="hljs-comment">// 将 str 移动到 newStr</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>std::forward</code>：完美转发</strong></p>
<ul>
<li><p><strong>功能：</strong> 在模板函数中用于保持参数的值类别（左值或右值）。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> forwarded = std::forward&lt;T&gt;(arg);  <span class="hljs-comment">// 完美转发</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::swap</code>：交换两个对象的值</p>
<ul>
<li><p><strong>功能：</strong> 用于交换两个对象的内容。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br><span class="hljs-attribute">std</span>::swap(a, b);  // a 变为 <span class="hljs-number">20</span>，b 变为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::rel_ops</code>：自动实现关系运算符**</p>
<ul>
<li><p><strong>功能：</strong> 提供通用的关系运算符（如 <code>!=</code>, <code>&lt;=</code>），基于 <code>==</code> 和 <code>&lt;</code> 自动推导。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::rel_ops;  <span class="hljs-comment">// 开启运算符自动推导</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>std::reference_wrapper</code>：引用包装器</p>
<ul>
<li><p><strong>功能：</strong> 用于包装引用类型，方便存储在容器中。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;functional&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> n = <span class="hljs-number">10</span>;<br>std::<span class="hljs-built_in">ref</span>erence_wrapper&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">ref</span> = n;<br><span class="hljs-built_in">ref</span>.<span class="hljs-keyword">get</span>() = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 修改原始变量 n 的值为 20</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>类型特性工具：<code>std::declval</code>、<code>std::enable_if</code> 等</p>
<ul>
<li><p><strong>功能：</strong> 帮助在模板元编程中处理类型推导和 SFINAE（替换失败不为错误）等问题。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;utility&gt;</code>、<code>&lt;type_traits&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">template</span> &lt;typename <span class="hljs-type">T</span>&gt;<br><span class="hljs-title">auto</span> create() -&gt; decl<span class="hljs-keyword">type</span>(<span class="hljs-type">T</span>()) &#123;<br>    return <span class="hljs-type">T</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>std::tie</code>：解构 <code>tuple</code> 或 <code>pair</code></strong></p>
<ul>
<li><p><strong>功能：</strong> 将 <code>tuple</code> 或 <code>pair</code> 中的元素解构为多个变量。</p>
</li>
<li><p><strong>头文件：</strong> <code>&lt;tuple&gt;</code></p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>std::string c;<br>std::<span class="hljs-built_in">tie</span>(a, b, c) = t;  <span class="hljs-comment">// 解构 tuple</span><br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="六-数组"><a href="#六-数组" class="headerlink" title="六.数组"></a>六.数组</h4><p>针对去重这类操作的模版</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">num</span>.size;i++)&#123;<br>	<span class="hljs-keyword">if</span>(要什么)&#123;<br>		<span class="hljs-built_in">num</span>[n] = <span class="hljs-built_in">num</span>[i];<br>		n++;<br>	&#125;<br>&#125;<br>去重:i=<span class="hljs-number">0</span> || <span class="hljs-built_in">num</span>[i]!=<span class="hljs-built_in">num</span>[i<span class="hljs-number">-1</span>]<br>移动零: <span class="hljs-built_in">num</span>[i]!=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>





<hr>
<h2 id="一-二分"><a href="#一-二分" class="headerlink" title="一.二分"></a>一.二分</h2><h3 id="二分查找的基本实现："><a href="#二分查找的基本实现：" class="headerlink" title="二分查找的基本实现："></a><strong>二分查找的基本实现</strong>：</h3><p>二分查找用于在有序数组中查找目标值 <code>target</code>，其时间复杂度为 O(log n)。</p>
<p>要求需要有序的数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] == target)<br>        <span class="hljs-keyword">return</span> mid;  <span class="hljs-comment">// 找到目标，返回索引</span><br>    <span class="hljs-keyword">if</span> (array[mid] &lt; target)<br>        left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 目标在右边</span><br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 目标在左边</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 没有找到目标，返回 -1</span><br></code></pre></td></tr></table></figure>

<p>适用更广的前驱型——找最后一个 &lt;&#x3D; <code>target</code> 的元素的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>, right = n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//向上取整</span><br>    <span class="hljs-keyword">if</span> (array[mid] &lt;= target)  <span class="hljs-comment">// array[mid] &gt; target此外也可以写别的条件也就是我们要的答案的基本性质</span><br>        left = mid;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 不安全返回n</span><br></code></pre></td></tr></table></figure>

<p>适用更广的后继型———找第一个 &gt;&#x3D; target 的数不存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (array[mid] &gt;= target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 如果大于等于目标值，返回true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search_upper_bound</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n;  <br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))  <br>            right = mid;  <br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> left;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>二分查找的“三步走”</strong>：</p>
<ul>
<li><strong>步骤 1</strong>：写出二分的条件，通常是一个“不等式”条件。例如，对于 <code>upper_bound</code> 查找，可以用“<code>val</code> 的数中最小的”这种不等式条件。</li>
<li><strong>步骤 2</strong>：将条件放到 <code>if</code> 中，并确定满足条件时需要缩小哪一半（<code>right = mid</code> 还是 <code>left = mid</code>）。</li>
<li><strong>步骤 3</strong>：另一半条件放在 <code>else</code> 中。通常可以是 <code>left = mid + 1</code> 或 <code>right = mid - 1</code>。对于向上取整或其他情况可以调整 <code>mid</code> 计算方式。</li>
</ul>
<p><strong>边界处理</strong>：</p>
<ul>
<li>如果题目存在无解情况，可以在返回值上调整，比如上界增加 1 或下界减少 1，以表示没有找到符合条件的值。</li>
</ul>
<hr>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[right])<br>            right = mid;<br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[right];<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= target)  <span class="hljs-comment">// 查找位置第一个 &gt;= target 的数</span><br>        right = mid;<br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(right);<br><br>left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= target)  <span class="hljs-comment">// 查找位置最后一个 &lt;= target 的数</span><br>        left = mid;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(right);<br><br><span class="hljs-keyword">if</span> (ans[<span class="hljs-number">0</span>] == ans[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure>

<h4 id="实数平方根"><a href="#实数平方根" class="headerlink" title="实数平方根"></a>实数平方根</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myRealSqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-type">double</span> left = <span class="hljs-number">0</span>, right = x;<br>    <span class="hljs-keyword">while</span> (right - left &gt; <span class="hljs-number">1e-7</span>) &#123; <span class="hljs-comment">//要求比保留小数多2，这里就是5位小数</span><br>        <span class="hljs-type">double</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt;= x) &#123;<br>            left = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h3><p><strong>算法步骤</strong>：</p>
<ul>
<li><strong>比较两点</strong> <code>lmid</code> 和 <code>rmid</code> 的函数值：<ul>
<li>如果 <code>f(lmid) &lt; f(rmid)</code>，则极值位于 <code>lmid</code> 的右边（排除 <code>lmid</code> 左侧区间），所以更新左边界 <code>left = lmid + 1</code>。</li>
<li>否则，极值位于 <code>rmid</code> 的左边（排除 <code>rmid</code> 右侧区间），更新右边界 <code>right = rmid - 1</code>。</li>
</ul>
</li>
<li>不断重复上述过程，直到区间收缩到极值点。</li>
</ul>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> lmid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> rmid = (lmid + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[lmid] &lt;= nums[rmid]) <br>        left = lmid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>        right = rmid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br><br></code></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>该算法通过三分查找，逐渐缩小区间直到找到数组的峰值位置。</li>
<li>在单峰函数中，这种方法能有效找到极值点。</li>
</ul>
<hr>
<h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>二分答案的本质啊，就是去通过题目给的限制条件。建立一个单调分段，建立一个单调分段，零一函数啊，这个函数的。定义域是解空间，就答案值域是零或者一就是数，那么这个函数本身其实是。对这个限制的一个验证啊，一个判定。那么，通过这个函数，我们就可以在整个解上，对吧？这个。空间里边去二分查找这个分线点在什么地方，这就是我们要的答案。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><h5 id="分割数组问题："><a href="#分割数组问题：" class="headerlink" title="分割数组问题："></a>分割数组问题：</h5><p>将数组 <code>nums</code> 分成 <code>m</code> 个连续的子数组，使得这些子数组中的<strong>最大和</strong>最小，并保证划分是合理的（即尽量均匀）。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li>通过二分查找来求解最大和的最小值。</li>
<li><strong>初始范围</strong>：最小值为数组中的最大元素，最大值为数组所有元素的和。</li>
<li><strong>判定条件</strong>：给定一个划分值 <code>T</code>，判断能否将数组划分成不超过 <code>m</code> 个子数组，使得每个子数组的和都不大于 <code>T</code>。</li>
</ul>
<p><strong>判定函数</strong>：</p>
<ul>
<li>遍历数组，累加当前子数组的和 <code>sum</code>，一旦 <code>sum</code> 超过了 <code>T</code>，就开始划分新的一组，并重置 <code>sum</code>。</li>
<li>如果划分的组数超过了 <code>m</code>，则说明 <code>T</code> 不足够大，需要增大 <code>T</code>；否则，说明 <code>T</code> 是一个可行的值，尝试减小 <code>T</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数组中的最大值</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 数组所有元素的和</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canSplit</span>(nums, mid, m))<br>            right = mid;  <span class="hljs-comment">// 尝试减小最大值</span><br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 增大最大值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canSplit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> maxSum, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        <span class="hljs-keyword">if</span> (sum &gt; maxSum) &#123;  <span class="hljs-comment">// 如果当前子数组的和超过了允许的最大值</span><br>            sum = num;<br>            count++;  <span class="hljs-comment">// 划分出新的子数组</span><br>            <span class="hljs-keyword">if</span> (count &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高精度问题"><a href="#高精度问题" class="headerlink" title="高精度问题"></a>高精度问题</h3><h4 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h4><p>长度很长的情况下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt; 0</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.size() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.size()) t += A[i] * b;<br>        C.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0，r是余数不用赋值直接传入就行</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.push_back(r / b);<br>        r %= b;<br>    &#125;<br>    reverse(C.begin(), C.end());<br>    <span class="hljs-keyword">while</span> (C.size() &gt; <span class="hljs-number">1</span> &amp;&amp; C.back() == <span class="hljs-number">0</span>) C.pop_back();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>+++++</p>
<h2 id="二-排序"><a href="#二-排序" class="headerlink" title="二.排序"></a>二.排序</h2><table>
<thead>
<tr>
<th><strong>时间复杂度</strong></th>
<th><strong>稳定</strong></th>
<th><strong>中立</strong></th>
<th><strong>不稳定</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>O(n²)</strong></td>
<td><strong>插入排序</strong>   有序规划水   一个个来嘛…</td>
<td><strong>冒泡排序</strong>   中立划水   交换一下…</td>
<td><strong>选择排序</strong>   混乱划水   随便找个最小的…</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td><strong>计数排序 &#x2F; 基数排序</strong>   不比较？那从数值范围入手吧   守序中立</td>
<td><strong>桶排序</strong>   绝对中立   我分个组，排序你们决定</td>
<td><strong>希尔排序</strong>   混乱中立   插入慢？增量分组插入吧</td>
</tr>
<tr>
<td><strong>O(n log n)</strong></td>
<td><strong>归并排序</strong>   守序内卷   nlogn 稳定可靠，合并有序   值得拥有</td>
<td><strong>堆排序</strong>   中立内卷   优化的基础算法…</td>
<td><strong>快速排序</strong>   混乱内卷   swap是门艺术，不服来快排</td>
</tr>
</tbody></table>
<p>交换类排序</p>
<p>冒泡排序</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每一轮遍历可以把最大（或最小）的元素放在数组的末尾。</p>
<hr>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li><p>时间复杂度：O(n log n)</p>
</li>
<li><p>空间复杂度：O(log n)</p>
</li>
<li><p>稳定性：不稳定</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过分治法将数组划分为较小的子数组，递归排序。</p>
<p>荷兰旗问题————划分两个区域</p>
<p>流程1——划分&gt;&lt;两个区域：当前数&lt;&#x3D;目标：先和&lt;&#x3D;区下一个位置交换，然后&lt;&#x3D;区向右扩，指针后移</p>
<p>​		  							 当前数&gt;目标：指针直接后移</p>
<p>流程2——划分&gt;&#x3D;&lt;三个区域：当前数&lt;目标：先和&lt;区下一个位置交换，然后&lt;区向右扩，指针后移</p>
<p>​		 								 当前数&#x3D;&#x3D;目标：指针直接后移</p>
<p>​										  当前数&gt;目标：先和&gt;区的前一个数交换，然后&gt;区向左扩， 指针不要动											</p>
<p>​		</p>
<hr>
<p>插入类排序</p>
<p><strong>(1) 直接插入排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> key = arr[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合小规模数据集，具有局部性特点的数据性能较好。</p>
<p><strong>(2) 希尔排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> key = arr[i];<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;<br>                arr[j] = arr[j - gap];<br>                j -= gap;<br>            &#125;<br>            arr[j] = key;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过缩小增量逐步优化插入排序。</p>
<p>选择类排序</p>
<p><strong>选择排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> minIdx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;<br>                minIdx = j;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每轮找到最小（或最大）值并交换到对应位置。</p>
<hr>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆就是 <code>完全二叉树</code>+<code>满足大根或小根的结构</code>(一代不如一代，越来越强的一代)</p>
<p>我们由数组脑补出完全二叉树的结构，堆只有向上调整和向下调整两种算法</p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// 将所有元素压入堆中，形成一个最大堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        q.<span class="hljs-built_in">push</span>(-a[i]);  <span class="hljs-comment">// 使用负值来模拟最小堆</span><br>    &#125;<br>    <span class="hljs-comment">// 将堆中的元素依次弹出，得到有序序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        a[i] = -q.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 取出最小值并存入数组</span><br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：利用堆结构维护最大或最小堆。</p>
<p>最大线段重合问题</p>
<p>给定很多线段，每个线段都有两个数[start,end]表示线段开始位置和结束位置，左右都是闭区间规定：<br>1)线段的开始和结束位置一定都是整数值<br>2)线段重合区域的长度必须&gt;&#x3D;1<br>返回线段最多重合区域中，包含了几条线段</p>
<p>流程准备一个小根堆，将所有线段以第一个数的大小从小到大排序这些线段，开始执行：第一个线段将二位置放入堆中，当小根堆里有小于等于此线段第一个数时，把他取出，然后将线段第二个数push进堆里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LineSegment</span> &#123;</span><br>    <span class="hljs-type">int</span> start;<br>    <span class="hljs-type">int</span> end;<br>&#125;;<br><br><span class="hljs-comment">// 比较函数：按 start 升序排列</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">compareByStart</span><span class="hljs-params">(<span class="hljs-type">const</span> LineSegment&amp; a, <span class="hljs-type">const</span> LineSegment&amp; b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a.start &lt; b.start;  <span class="hljs-comment">// 返回 true 表示 a 排在前面</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxOverlapSegments</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;LineSegment&gt;&amp; segments)</span> &#123;<br>    <span class="hljs-keyword">if</span> (segments.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 1. 将所有线段按 start 排序</span><br>    sort(segments.begin(), segments.end(), compareByStart);<br><br>    <span class="hljs-comment">// 2. 小根堆用于存储线段的结束位置（end）</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br><br>    <span class="hljs-comment">// 3. 初始化最大重叠数</span><br>    <span class="hljs-type">int</span> maxOverlap = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 4. 遍历所有线段</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; segment : segments) &#123;<br>        <span class="hljs-comment">// 取出所有结束位置小于等于当前线段起始位置的线段</span><br>        <span class="hljs-keyword">while</span> (!pq.empty() &amp;&amp; pq.top() &lt;= segment.start) &#123;<br>            pq.pop();  <span class="hljs-comment">// 这些线段不再重叠</span><br>        &#125;<br><br>        <span class="hljs-comment">// 将当前线段的结束位置加入堆</span><br>        pq.push(segment.end);<br><br>        <span class="hljs-comment">// 记录堆中当前的线段数，即当前重叠的线段数</span><br>        maxOverlap = max(maxOverlap, (<span class="hljs-type">int</span>)pq.size());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxOverlap;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;LineSegment&gt; segments = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">8</span>&#125; &#125;;<br><br>    <span class="hljs-type">int</span> result = maxOverlapSegments(segments);<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最大重叠的线段数: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<hr>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在合并的过程中，我们不仅可以 <strong>排序</strong>，还可以 <strong>统计</strong> 数组中元素之间的关系,在每层merge前统计关系</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h5><p>统计左面有多少数比本身小累加起来</p>
<p>merge过程中设置一个ans，当左组拷贝时ans+右组指针到结尾的数的个数*拷贝的数，相等时先拷贝右边</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    res += merge_sort(q, l, mid);<br>    res += merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt; q[j])&#123;     <br>            tmp[k ++ ] = q[i ++ ];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <br>            tmp[k ++ ] = q[j ++ ];<br>        &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 归并排序计算逆序对</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];  <span class="hljs-comment">// 临时数组</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 递归的终止条件</span><br>    <br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 找到中点</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 统计逆序对的结果</span><br>    <br>    <span class="hljs-comment">// 递归调用归并排序，处理左右两部分</span><br>    res += merge_sort(q, l, mid);<br>    res += merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-comment">// 合并过程中，统计符合条件的逆序对</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">tmp</span><span class="hljs-params">(r - l + <span class="hljs-number">1</span>)</span>;  <span class="hljs-comment">// 临时数组，大小为归并后数组的大小</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 统计符合条件的数 (逆序对)</span><br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= mid; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt;= r &amp;&amp; q[i] &gt; q[j]) &#123;  <span class="hljs-comment">// 比较左右两部分的元素</span><br>            j++;  <span class="hljs-comment">// 找到所有满足条件的右侧元素</span><br>        &#125;<br>        res += (j - (mid + <span class="hljs-number">1</span>));  <span class="hljs-comment">// 累加逆序对</span><br>    &#125;<br><br>    <span class="hljs-comment">// 合并过程</span><br>    i = l;  <span class="hljs-comment">// 重置 i 和 j 用于合并操作</span><br>    j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) &#123;<br>            tmp[k++] = q[i++];  <span class="hljs-comment">// 左边的元素较小</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = q[j++];  <span class="hljs-comment">// 右边的元素较小</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br><br><br>    <span class="hljs-comment">// 将临时数组的元素拷贝回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>        q[i] = tmp[j];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回当前统计的结果</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h5 id="自定义问题"><a href="#自定义问题" class="headerlink" title="自定义问题"></a>自定义问题</h5><p>num的右边有多少个数*2之后依然&lt;num 这个方案设计了R来让其滑动窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 归并排序计算逆序对</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-type">int</span> temp[<span class="hljs-number">1000</span>];  <span class="hljs-comment">// 临时数组</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 递归的终止条件</span><br>    <br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 找到中点</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 统计逆序对的结果</span><br>    <br>    <span class="hljs-comment">// 递归调用归并排序，处理左右两部分</span><br>    res += merge_sort(q, l, mid);<br>    res += merge_sort(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-comment">// 合并过程中，统计符合条件的逆序对</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">tmp</span><span class="hljs-params">(r - l + <span class="hljs-number">1</span>)</span>;  <span class="hljs-comment">// 临时数组，大小为归并后数组的大小</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 统计符合条件的数 (逆序对)</span><br>    <span class="hljs-keyword">for</span> (i = l; i &lt;= mid; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt;= r &amp;&amp;  (<span class="hljs-type">long</span>)q[i] &gt; (<span class="hljs-type">long</span>)q[j] * <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 比较左右两部分的元素</span><br>            j++;  <span class="hljs-comment">// 找到所有满足条件的右侧元素</span><br>        &#125;<br>        res += (j - (mid + <span class="hljs-number">1</span>));  <span class="hljs-comment">// 累加逆序对</span><br>    &#125;<br><br>    <span class="hljs-comment">// 合并过程</span><br>    i = l;  <span class="hljs-comment">// 重置 i 和 j 用于合并操作</span><br>    j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) &#123;<br>            tmp[k++] = q[i++];  <span class="hljs-comment">// 左边的元素较小</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = q[j++];  <span class="hljs-comment">// 右边的元素较小</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br><br><br>    <span class="hljs-comment">// 将临时数组的元素拷贝回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>        q[i] = tmp[j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回当前统计的结果</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="比较一个区间的问题"><a href="#比较一个区间的问题" class="headerlink" title="比较一个区间的问题"></a>比较一个区间的问题</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 合并排序计算区间和在 [lower, upper] 范围内的数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 递归调用归并排序，统计左半部分和右半部分</span><br>    res += merge_sort(nums, l, mid, lower, upper);<br>    res += merge_sort(nums, mid + <span class="hljs-number">1</span>, r, lower, upper);<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">tmp</span><span class="hljs-params">(r - l + <span class="hljs-number">1</span>)</span>;<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 统计符合条件的数 (区间和在 lower, upper 范围内)</span><br>    <span class="hljs-type">int</span> windowL = l;<br>    <span class="hljs-type">int</span> windowR = l;<br>    <br>    <span class="hljs-keyword">for</span> (i = j; i &lt;= r; i++) &#123;<br>        <span class="hljs-type">long</span> min_val = nums[i] - upper;<br>        <span class="hljs-type">long</span> max_val = nums[i] - lower;<br><br>        <span class="hljs-keyword">while</span> (windowR &lt;= mid &amp;&amp; nums[windowR] &lt;= max_val) &#123;<br>            windowR++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (windowL &lt;= mid &amp;&amp; nums[windowL] &lt; min_val) &#123;<br>            windowL++;<br>        &#125;<br><br>        res += windowR - windowL;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并过程</span><br>    i = l;<br>    j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>            tmp[k++] = nums[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmp[k++] = nums[j++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余元素放入临时数组</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = nums[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = nums[j++];<br><br>    <span class="hljs-comment">// 将临时数组的元素拷贝回原数组</span><br>    <span class="hljs-keyword">for</span> (i = l, k = <span class="hljs-number">0</span>; i &lt;= r; i++, k++) &#123;<br>        nums[i] = tmp[k];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回当前统计的结果</span><br>&#125;<br></code></pre></td></tr></table></figure>







<hr>
<p>二、非比较类排序</p>
<ol>
<li>计数排序</li>
</ol>
<ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(k)</li>
<li>稳定性：稳定</li>
<li>适用于已知范围的整数排序，将每个数据作为键（key）存储在额外的数组中。通过统计每个数出现的次数，可以按序填充回原数组，从而完成排序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> max)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count[max + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> output[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[arr[i]]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[arr[i]] - <span class="hljs-number">1</span>] = arr[i];<br>        count[arr[i]]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合范围较小的整数排序。</p>
<ol start="2">
<li>桶排序</li>
</ol>
<ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
<li>将数据分布到有限数量的桶（bucket）中，每个桶内的数据再分别进行排序（可以用其他排序算法）。最后将各桶中的数据按顺序合并。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-type">float</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">float</span>&gt; buckets[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> idx = n * arr[i];<br>        buckets[idx].<span class="hljs-built_in">push_back</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::<span class="hljs-built_in">sort</span>(buckets[i].<span class="hljs-built_in">begin</span>(), buckets[i].<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;val : buckets[i]) &#123;<br>            arr[idx++] = val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合分布均匀的实数排序。</p>
<ol start="3">
<li>基数排序</li>
</ol>
<ul>
<li>时间复杂度：O(nk)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
<li>将数据切割成一位一位的数字（通常为十进制位，0-9），从低位到高位依次对每一位进行计数排序（或从高位到低位）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSortForRadix</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> exp)</span> </span>&#123;<br>    <span class="hljs-type">int</span> output[n], count[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[(arr[i] / exp) % <span class="hljs-number">10</span>]++;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[(arr[i] / exp) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = arr[i];<br>        count[(arr[i] / exp) % <span class="hljs-number">10</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = <span class="hljs-built_in">getMax</span>(arr, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> exp = <span class="hljs-number">1</span>; max / exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) <span class="hljs-built_in">countingSortForRadix</span>(arr, n, exp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：按位排序，从低位到高位逐一处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>算法选择</strong>：根据数据的规模、分布特点选择合适的算法。快速排序在多数情况下表现良好，但对于极端情况可能退化；归并排序的稳定性和性能较优但占用额外空间；堆排序在处理大规模数据时表现优异。</li>
<li><strong>非比较排序</strong>：如计数排序、桶排序和基数排序，适合特定场景，通常用于整型或有范围限制的数据。</li>
</ul>
<h4 id="查找第-k-大元素"><a href="#查找第-k-大元素" class="headerlink" title="查找第 k 大元素"></a>查找第 <code>k</code> 大元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// quickSort 函数：用于查找在排序后位置为 index 的元素的值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> arr[l];<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(arr, l, r);<br>        <span class="hljs-keyword">if</span> (index == pivot) <span class="hljs-keyword">return</span> arr[pivot];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; pivot) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(arr, l, pivot - <span class="hljs-number">1</span>, index);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSort</span>(arr, pivot + <span class="hljs-number">1</span>, r, index);<br>    &#125;<br><br>    <span class="hljs-comment">// partition 函数：分区操作，返回分区位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pivot = l + <span class="hljs-built_in">rand</span>() % (r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> pivotVal = a[pivot];<br><br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">while</span> (a[l] &lt; pivotVal) l++;<br>            <span class="hljs-keyword">while</span> (a[r] &gt; pivotVal) r--;<br>            <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> temp = a[l];<br>                a[l] = a[r];<br>                a[r] = temp;<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="翻转对"><a href="#翻转对" class="headerlink" title="翻转对"></a>翻转对</h4><p>题目要求在一个数组中找到满足条件 <code>nums[i] &gt; 2 * nums[j]</code> 的所有下标对 <code>(i, j)</code>，其中 <code>i &lt; j</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ans;  <span class="hljs-comment">// 全局变量，记录翻转对数量</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr, l, mid);<br>        <span class="hljs-built_in">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">calculate</span>(arr, l, mid, r);<br>        <span class="hljs-built_in">merge</span>(arr, l, mid, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= mid; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt;= right &amp;&amp; arr[i] &gt; <span class="hljs-number">2LL</span> * arr[j]) j++;<br>            ans += j - (mid + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 累加符合条件的对数</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) temp[k++] = arr[i++];<br>            <span class="hljs-keyword">else</span> temp[k++] = arr[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];<br>        <span class="hljs-keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temp.<span class="hljs-built_in">size</span>(); i++) arr[left + i] = temp[i];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="三-前缀和"><a href="#三-前缀和" class="headerlink" title="三.前缀和"></a>三.前缀和</h2><p>一维前缀和<br>S[i] &#x3D; a[1] + a[2] + … a[i]<br>a[l] + … + a[r] &#x3D; S[r] - S[l - 1]</p>
<p>一维差分<br>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</p>
<p>二维前缀和<br>S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</p>
<p>二维差分<br>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c</p>
<h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>定义：前缀和数组是用于快速计算数组任意区间和的辅助数组。<code>S[i]</code> 表示从数组开头到第 <code>i</code> 个元素的累加和。</p>
<p>公式：</p>
<ul>
<li>基本公式：<code>S[i] = S[i-1] + A[i]</code></li>
<li>区间和公式：要计算原数组 <code>A</code> 中 <code>[i, j]</code> 区间的和，可以使用前缀和数组：<code>sum(i, j) = S[j] - S[i-1]</code>  用x,y模拟s[x]-s[y]此时只需要遍历x的位置。</li>
</ul>
<p>[3, 1, 4, 5, 2]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//维护前缀和的写法[3, 4, 8, 13, 15]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sums</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>; <br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>    s[i] = s[i<span class="hljs-number">-1</span>] + sums[i<span class="hljs-number">-1</span>]; <br>&#125;<br><br><br><span class="hljs-comment">//preMin写法，从左往右遍历，preMin[] = [3, 1, 1, 1, 1]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preMin</span><span class="hljs-params">(n)</span></span>;<br>preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>];  <span class="hljs-comment">//这里的s指的是前缀和数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    preMin[i] = <span class="hljs-built_in">min</span>(preMin[i<span class="hljs-number">-1</span>], s[i]);   <br>&#125;<br><br><br><span class="hljs-comment">//preMax写法，从左往右遍历，preMax[] = [3, 3, 4, 5, 5]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preMax</span><span class="hljs-params">(n)</span></span>;<br>preMax[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>];  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    preMax[i] = <span class="hljs-built_in">max</span>(preMax[i<span class="hljs-number">-1</span>], s[i]);  <br>&#125;<br><br><span class="hljs-comment">//sufMin 的写法，从右往左遍历，sufMin[] = [1, 1, 2, 2, 2]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sufMin</span><span class="hljs-params">(n)</span></span>;<br>sufMin[n<span class="hljs-number">-1</span>] = s[n<span class="hljs-number">-1</span>]; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    sufMin[i] = <span class="hljs-built_in">min</span>(sufMin[i + <span class="hljs-number">1</span>], s[i]);  <br>&#125;<br><br><span class="hljs-comment">//sufMax 的写法，从右往左遍历，sufMax[] = [5, 5, 5, 5, 2]</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sufMax</span><span class="hljs-params">(n)</span></span>;<br>sufMax[n<span class="hljs-number">-1</span>] = s[n<span class="hljs-number">-1</span>];  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    sufMax[i] = <span class="hljs-built_in">max</span>(sufMax[i + <span class="hljs-number">1</span>], s[i]); <br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li><strong>思路</strong>：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。所以只需用一个计数数组或 hash map 维护S中每个值的个数，枚举右端点 i，看一下等于S[i]-k 的值有几个就行了</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><h5 id="优美子数组和问题"><a href="#优美子数组和问题" class="headerlink" title="优美子数组和问题"></a>优美子数组和问题</h5><p>子数组中的奇数个数等于给定的整数 <code>k</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;vector&gt;<br>#include &lt;unordered_map&gt;<br><br>using namespace std;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>; <span class="hljs-comment">// 前缀和数组 s(0-n)，初始化为0</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; count; <span class="hljs-comment">// 用于记录前缀和出现的次数</span><br>    count[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始前缀和为0时，计数为1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算前缀和 s[i]，其中 nums[i-1] 是当前元素，nums[i-1] % 2 用于判断奇偶性</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>; <span class="hljs-comment">// 前缀和的奇偶性计算</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] - k &gt;= <span class="hljs-number">0</span>) &#123;<br>            ans += count[s[i] - k]; <span class="hljs-comment">// 如果满足条件，累加出现的次数</span><br>        &#125;<br>        count[s[i]]++; <span class="hljs-comment">// 更新当前前缀和出现的次数</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>解析：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。所以只需用一个计数数组或 hash map 维护S中每个值的个数，枚举右端点 i，看一下等于S[i]-k 的值有几个就行了</p>
<h5 id="最大子数组和问题"><a href="#最大子数组和问题" class="headerlink" title="最大子数组和问题"></a>最大子数组和问题</h5><p>问题描述：给定一个整数数组，要求找到其最大子数组的和。子数组的定义是数组中连续的一部分元素。</p>
<p><strong>思路</strong>：</p>
<p>可以通过前缀和的方式来求解最大子数组和问题。</p>
<p>同时我们需要一个 <code>preMin</code> 数组来记录当前子数组的前缀和中的最小值，以便在当前区间进行减法操作时，获得可能的最大子数组和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-type">int</span>[] preMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀最小值数组</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算前缀和</span><br>    &#125;<br>    preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>]; <span class="hljs-comment">//preMin书写模版</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        preMin[i] = Math.min(preMin[i-<span class="hljs-number">1</span>], s[i]); <span class="hljs-comment">// 维护前缀最小值</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>; <span class="hljs-comment">// 初始化答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = Math.max(ans, s[i] - preMin[i-<span class="hljs-number">1</span>]); <span class="hljs-comment">// 计算最大子数组和 从一开始</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="一维差分数组"><a href="#一维差分数组" class="headerlink" title="一维差分数组"></a>一维差分数组</h3><p>总结：把 A的第!个数到第r个数加 d，B 的变化为:B;加 d，B,+ 减d，它比较适用于我们想把一段儿-个子段都加一个值的时候。比如我们想把a的dl到底I个数啊啊|到r这个字段都加一个数d。</p>
<ul>
<li><p><strong>差分数组</strong>的引入则为高效区间更新提供了一种新的方法。在解决大规模区间更新问题时，如果直接对原数组进行操作，时间复杂度会比较高，而差分数组通过记录相邻元素之间的差值，在常数时间内更新区间，最后通过前缀和恢复原数组。</p>
</li>
<li><p>例如，在航班预定问题中，差分数组 <code>id</code> 被用来记录每个区间的变化量，最终通过前缀和恢复预定后的航班乘客数量。</p>
</li>
<li><p>差分数组的本质是通过对局部变化的记录和累积，使得区间更新可以在 O(1) 时间内完成，极大优化了需要频繁进行更新操作的场景。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">宇航票预定<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">book</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bookings, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; booking : bookings) &#123;<br>            <span class="hljs-type">int</span> a = booking[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> b = booking[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> c = booking[<span class="hljs-number">2</span>];<br>            id[a] += c;<br>            id[b + <span class="hljs-number">1</span>] -= c;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + id[i];<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            answer[i - <span class="hljs-number">1</span>] = sum[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><ul>
<li><p>在本部分的笔记中，前缀和的概念被推广到了二维情况。二维前缀和 <code>S[i][j]</code> 表示的是从矩阵左上角 <code>(1, 1)</code> 到当前坐标 <code>(i, j)</code> 的所有元素的累加和，这一概念让我们能够快速计算任意矩形区域内的元素和。</p>
</li>
<li><p>类似于一维前缀和的区间和公式，二维前缀和的矩形区域和通过前缀和数组快速求解，避免了重复计算。计算区域 <code>(p, q)</code> 到 <code>(i, j)</code> 的矩形区域和的公式为：</p>
<ul>
<li><code>sum(p, q, i, j) = S[i][j] - S[i][q-1] - S[p-1][j] + S[p-1][q-1]</code></li>
</ul>
</li>
<li><p>这种方式不仅能快速处理问题，还能提升算法的时间复杂度，尤其适合处理较大规模的矩阵求和问题。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">二维区域的和<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.length;<br>    <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].length;<br>    sum = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            sum[i][j] = sum[i - <span class="hljs-number">1</span>][j] + sum[i][j - <span class="hljs-number">1</span>] - sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>    row1 += <span class="hljs-number">1</span>;<br>    col1 += <span class="hljs-number">1</span>;<br>    row2 += <span class="hljs-number">1</span>;<br>    col2 += <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> sum[row2][col2] - sum[row1 - <span class="hljs-number">1</span>][col2] - sum[row2][col1 - <span class="hljs-number">1</span>] + sum[row1 - <span class="hljs-number">1</span>][col1 - <span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="二维差分数组"><a href="#二维差分数组" class="headerlink" title="二维差分数组"></a>二维差分数组</h3><hr>
<h2 id="四-进制转换"><a href="#四-进制转换" class="headerlink" title="四.进制转换"></a>四.进制转换</h2><hr>
<h2 id="五-找规律能力"><a href="#五-找规律能力" class="headerlink" title="五.找规律能力"></a>五.找规律能力</h2><hr>
<h2 id="六-链表"><a href="#六-链表" class="headerlink" title="六.链表"></a>六.链表</h2><p>直接链表实现过于浪费，我们一般通过数组来模拟链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;<br>    head = ne[head];<br>&#125;<br><span class="hljs-comment">// 在第k个位置插入一个数a (k是从1开始的)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertAt</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>        insert(a);  <span class="hljs-comment">// 如果是插入头部，直接调用插入头部的函数</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-comment">// 找到第k-1个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k - <span class="hljs-number">1</span> &amp;&amp; cur != <span class="hljs-number">-1</span>; i++) &#123;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 如果k超出了链表的范围</span><br>    e[idx] = a;<br>    ne[idx] = ne[cur];  <span class="hljs-comment">// 新节点的next指向第k个节点</span><br>    ne[cur] = idx;      <span class="hljs-comment">// 第k-1个节点的next指向新节点</span><br>    idx++;<br>&#125;<br><span class="hljs-comment">// 删除第k个位置的元素 (k是从1开始的)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">removeAt</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>        remove();  <span class="hljs-comment">// 如果删除的是头结点，直接调用删除头结点的函数</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-comment">// 找到第k-1个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k - <span class="hljs-number">1</span> &amp;&amp; cur != <span class="hljs-number">-1</span>; i++) &#123;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">-1</span> || ne[cur] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// k超出范围</span><br>    <span class="hljs-comment">// 删除第k个节点</span><br>    <span class="hljs-type">int</span> temp = ne[cur];<br>    ne[cur] = ne[temp];  <span class="hljs-comment">// 第k-1个节点的next指向第k+1个节点</span><br>&#125;<br><span class="hljs-comment">// 查找第k个位置的元素 (k是从1开始的)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getAt</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-comment">// 遍历到第k个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k &amp;&amp; cur != <span class="hljs-number">-1</span>; i++) &#123;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果k超出了链表的范围</span><br>    <span class="hljs-keyword">return</span> e[cur];<br>&#125;<br><span class="hljs-comment">// 输出链表所有元素</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; e[cur] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cur = ne[cur];<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure>



<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl">head  head 是一个指针，指向链表的第一个节点，因此它表示整个链表的起始<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;null(补充的<span class="hljs-keyword">last</span>)<br><br> struct ListNode &#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* <span class="hljs-keyword">next</span>;<br>    ListNode(<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>) : val(<span class="hljs-keyword">x</span>), <span class="hljs-keyword">next</span>(nullptr) &#123;&#125;<br>&#125;;<br><br>ListNode* reverseList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-keyword">last</span> = nullptr;<br>    <span class="hljs-keyword">while</span> (head != nullptr) &#123;<br>        ListNode* nextHead = head-&gt;<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span> 暂存下一个节点<br>        head-&gt;<span class="hljs-keyword">next</span> = <span class="hljs-keyword">last</span>;                <span class="hljs-regexp">//</span> 反转当前节点的指针<br>        <span class="hljs-keyword">last</span> = head;                      <span class="hljs-regexp">//</span> 更新<span class="hljs-keyword">last</span>为当前节点<br>        head = nextHead;                  <span class="hljs-regexp">//</span> 继续处理下一个节点<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">last</span>;                          <span class="hljs-regexp">//</span> 返回新头节点<br>&#125;<br><br></code></pre></td></tr></table></figure>





<p>+++++</p>
<h2 id="七-栈"><a href="#七-栈" class="headerlink" title="七.栈"></a>七.栈</h2><h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>经验</p>
<p>当新h小于之前的h,进行累加长度更新答案,pop上一个被推的栈,推累长加一的h栈</p>
<p>核心思想:单调栈考虑前面不影响后面<br>套路模版: </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//int一个答案要全局</span><br>heights.push_back(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果需要弹空就写</span><br><span class="hljs-keyword">for</span>()&#123;<br>	<span class="hljs-keyword">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(栈顶与新元素不满足单调栈)&#123;<br>	 	累加长度<br>	 	更新答案<br>	 	<span class="hljs-keyword">pop</span>弹栈<br>	 	....... <span class="hljs-comment">//期间可以思考增加限制</span><br>	&#125;<br>	s.<span class="hljs-keyword">push</span>(&#123;accmulatedWidth+<span class="hljs-number">1</span>,height&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><h4 id="柱状图中最大矩形"><a href="#柱状图中最大矩形" class="headerlink" title="柱状图中最大矩形"></a>柱状图中最大矩形</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">heighs=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br>private:<br>	stuct UERT&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	<span class="hljs-built_in">stack</span> &lt;UERT&gt; s;<br>public:<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>    	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    	heights.push_back(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 便于最后清空栈</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>    		<span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度小于栈顶柱子的高度，则计算面积</span><br>            <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top().height &gt;= height) &#123;<br>                accmulatedWidth += s.top().width;<br>                res = max(ans,s.top().width*accmulatedWidth);            <br>                s.pop();            <br>        	&#125;<br>        	s.push(&#123;accmulatedWidth+<span class="hljs-number">1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>   		&#125;<br>    	<span class="hljs-keyword">return</span> res;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>private:<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UERT</span>&#123;</span><br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	<span class="hljs-built_in">stack</span> &lt;UERT&gt; s;<br>public:<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>            <span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度大于栈顶柱子，计算能存储的雨水</span><br>            <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top().height &lt;= height) &#123;<br>                <span class="hljs-type">int</span> bottom = s.top().height;<br>                accmulatedWidth += s.top().width;<br>                s.pop();<br>                <span class="hljs-keyword">if</span> (s.empty()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果栈为空，跳过,水从左边溜走了</span><br>                <span class="hljs-type">int</span> up = min(height,s.top().height);<br>                ans += accmulatedWidth*(up-bottom);<br>            &#125;<br>            s.push(&#123;accmulatedWidth+<span class="hljs-number">1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>        &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;	<br>	<br>前缀和思想<br><span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>    <span class="hljs-type">int</span> n = heights.size();<br>    preMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    sufMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    <br>    <span class="hljs-comment">// 预处理preMax数组</span><br>    preMax[<span class="hljs-number">0</span>] = heights[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        preMax[i] = max(preMax[i - <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 预处理sufMax数组</span><br>    sufMax[n - <span class="hljs-number">1</span>] = heights[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        sufMax[i] = max(sufMax[i + <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> up = min(preMax[i - <span class="hljs-number">1</span>], sufMax[i + <span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> bottom = heights[i];<br>        <span class="hljs-keyword">if</span> (up &gt; bottom) &#123;<br>            ans += up - bottom;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>preMax[]：记录当前位置左侧的最大高度。<br>sufMax[]：记录当前位置右侧的最大高度。<br></code></pre></td></tr></table></figure>







<p>+++++</p>
<h2 id="八-队列和双指针"><a href="#八-队列和双指针" class="headerlink" title="八.队列和双指针"></a>八.队列和双指针</h2><p>模拟队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>我们就希望去维护一个这样的候选,集合里边的元素，它们的值是递减的。所以当I它大于等于k-1时，我已经攒够了。q的值是递减的呀，可能成为一个答案的选项，那么此时就对头最好，我就取对头作为答案。这就是我们要干三件事情。</p>
<p>单调队列维护的是一个候选集合，前面的比较旧，后面的比较新(时间有单调性</p>
<p>候选项的某个属性也具有单调性</p>
<p>确定递增递减的方法–考虑任意两个候选顶j&lt;j2，写出j比优的条件</p>
<p>排除冗余的关键:若j比j差，j的生命周期还比了短，那了 就没卵用了</p>
<p>单调队列题目代码套路:<br>·for 每个元素<br>    (1)while(队头过期)队头出队<br>    (2)取队头为最佳选项，计算答案                                                                                                                                            	(3)while(队尾与新元素不满足单调性)队尾出队                                                                                                                                                                                                                                                        	(3)新元素入队</p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="找到滑动窗口最大值"><a href="#找到滑动窗口最大值" class="headerlink" title="找到滑动窗口最大值"></a>找到滑动窗口最大值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">maxSlidingWindow</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; ans; <span class="hljs-comment">// 存储结果</span><br>        <span class="hljs-built_in">deque</span>&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 用于维护滑动窗口的双端队列</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-comment">// 删除过期元素：如果队首元素不在当前窗口范围内，则弹出队首</span><br>            <span class="hljs-keyword">while</span> (!q.empty() &amp;&amp; q.front() &lt;= i - k) &#123;<br>                q.pop_front();<br>            &#125;<br><br>            <span class="hljs-comment">// 插入新元素：移除队列中所有小于当前元素的值，以保持递减顺序</span><br>            <span class="hljs-keyword">while</span> (!q.empty() &amp;&amp; nums[q.back()] &lt;= nums[i]) &#123;<br>                q.pop_back();<br>            &#125;<br><br>            <span class="hljs-comment">// 将当前元素的索引加入到队列中</span><br>            q.push_back(i);<br><br>            <span class="hljs-comment">// 记录当前窗口的最大值：队首元素即为窗口内的最大值</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                ans.push_back(nums[q.front()]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="二维单调队列"><a href="#二维单调队列" class="headerlink" title="二维单调队列"></a>二维单调队列</h3><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><strong>定义</strong>：通过一左一右或一前一后两个指针逼近来找到符合条件的解</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">for<span class="hljs-comment">(i=0,j=0;i&lt;n;i++)</span>&#123;<br>	<span class="hljs-keyword">while</span> <span class="hljs-comment">(j&lt;i&amp;&amp;check(i,j)</span>)j++;<br>	<span class="hljs-comment">//每道题目的具体逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><h5 id="两数之和："><a href="#两数之和：" class="headerlink" title="两数之和："></a>两数之和：</h5><p>给定一个有序数组，找到两个数，使得它们的和等于目标值 <code>target</code>。返回这两个数的下标，假定数组内没有重复解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入有序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 两个指针从数组两端开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; numbers[i]+numbers[j]&gt;target)	j--;<br>        <span class="hljs-keyword">if</span> (i&lt;j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>            reture &#123;i<span class="hljs-number">+1</span>,j<span class="hljs-number">+1</span>&#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;<br><br>输入无序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; pairs;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        pairs.<span class="hljs-built_in">push</span>(&#123;num[i],i&#125;);  <br>    &#125;<br>    <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(),pairs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> j = pairs.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;pairs.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first&gt;target)	j--;<br>        <span class="hljs-keyword">if</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first==target)&#123;<br>            <span class="hljs-keyword">return</span> &#123;pairs[i],second , pairs[j].second&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;  <br></code></pre></td></tr></table></figure>



<h5 id="三数之和："><a href="#三数之和：" class="headerlink" title="三数之和："></a>三数之和：</h5><p>给定一个数组 <code>nums</code>，找出其中的三个数，使得它们的和为 0。可以假设数组中没有重复解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; jks = <span class="hljs-built_in">twoSum</span>(nums, i + <span class="hljs-number">1</span>, -nums[i]);<br>            <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; jk : jks) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], jk[<span class="hljs-number">0</span>], jk[<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--;<br>            <span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;numbers[i], numbers[j]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>优化与细节</strong>：</p>
<ul>
<li><strong>去重处理</strong>：为了避免重复解，固定数和双指针都需要跳过重复的元素。例如，固定数 <code>nums[i]</code> 相同的情况不再处理，双指针的 <code>nums[j]</code> 和 <code>nums[k]</code> 也需要处理重复的情况。</li>
<li><strong>时间复杂度</strong>：排序时间复杂度为 O(nlogn)，之后遍历和双指针查找的时间复杂度是 O(n²)，总体复杂度为 O(n²)。</li>
</ul>
<h5 id="盛水最多的容器："><a href="#盛水最多的容器：" class="headerlink" title="盛水最多的容器："></a>盛水最多的容器：</h5><p>给定一个数组 <code>height</code>，其中每个元素代表容器壁的高度，找到两个容器壁，使得它们与 X 轴构成的容器能盛最多的水。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>        <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) i++;<br>        <span class="hljs-keyword">else</span> j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="离散化问题"><a href="#离散化问题" class="headerlink" title="离散化问题"></a>离散化问题</h3><p>将一个区间内的连续的、可能是非常大的数值范围（例如整数或浮点数）映射到一个较小的、连续的整数区间   数据范围在十的九次方左右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br>sort(alls.begin(), alls.end()); <span class="hljs-comment">// 将所有值排序</span><br>alls.erase(unique(alls.begin(), alls.end()), alls.end());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span><br>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br><br>find调用后返回新数组的下标<br></code></pre></td></tr></table></figure>

<h3 id="区间合并问题"><a href="#区间合并问题" class="headerlink" title="区间合并问题"></a>区间合并问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;PII&gt; &amp;segs)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;PII&gt; res;<br><br>    sort(segs.begin(), segs.end());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)&#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = max(ed, seg.second);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.push_back(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况"><a href="#比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况" class="headerlink" title="比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况"></a>比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况</h3><ol>
<li>前缀和（Prefix Sum）<br>适用情况：<br>快速计算数组某个子区间的和：适用于需要多次计算数组某个区间和的场景。<br>区间查询和更新较少：适合静态数组或查询操作远多于更新操作的情况。</li>
<li>差分（Difference Array）<br>适用情况：<br>快速进行区间修改：适用于需要频繁对数组某个区间进行加减操作的场景。<br>需要高效进行批量更新：适合大规模区间更新操作。</li>
<li>双指针（Two Pointers）<br>适用情况：<br>处理有序数组：适用于需要在有序数组或链表中查找、遍历等操作。<br>解决滑动窗口问题：适合在数组或字符串上维护动态区间的问题。</li>
<li>滑动窗口（Sliding Window）<br>适用情况：<br>子数组问题：适用于需要找到数组中满足特定条件的子数组或子字符串的问题。<br>连续子区间：适合处理需要计算连续子区间的问题。</li>
<li>单调栈（Monotonic Stack）<br>适用情况：<br>找到数组中每个元素的下一个更大（或更小）元素：适用于需要在数组中找到特定方向上的极值问题。<br>维护区间单调性：适合处理需要保持区间单调性的问题。</li>
</ol>
<hr>
<h2 id="九-优先列队-堆"><a href="#九-优先列队-堆" class="headerlink" title="九.优先列队&#x2F;堆"></a>九.优先列队&#x2F;堆</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><br>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        heap_swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        heap_swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) down(i);<br><br></code></pre></td></tr></table></figure>







<hr>
<h2 id="十-哈希表"><a href="#十-哈希表" class="headerlink" title="十. 哈希表"></a>十. 哈希表</h2><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="找到两数之和"><a href="#找到两数之和" class="headerlink" title="找到两数之和"></a>找到两数之和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; h;  <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 遍历数组 nums</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;                    <br>            <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">find</span>(target-num[i]) != h.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;h[target-num[i]], i&#125;;  <span class="hljs-comment">// 找到两数之和，返回其索引</span><br>            &#125;<br>            <span class="hljs-comment">// 如果不存在，将当前元素和索引存入哈希表</span><br>            h[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果未找到符合条件的数对，返回空数组</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="模拟行走机器人"><a href="#模拟行走机器人" class="headerlink" title="模拟行走机器人"></a>模拟行走机器人</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">robotSim</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; commands, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacles)</span> &#123;<br>        <span class="hljs-type">int</span> dirs[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 四个方向: 北(0,1), 东(1,0), 南(0,-1), 西(-1,0)</span><br>        <span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">60010</span> + y; &#125;;  <span class="hljs-comment">// 将障碍物位置映射为唯一的值</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : obstacles) &#123;<br>            s.insert(f(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : commands) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-2</span>) &#123;<br>                k = (k + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向左转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-1</span>) &#123;<br>                k = (k + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向右转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (c-- &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> nx = x + dirs[k], ny = y + dirs[k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (s.count(f(nx, ny))) &#123;<br>                        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 遇到障碍物</span><br>                    &#125;<br>                    x = nx;<br>                    y = ny;<br>                    ans = <span class="hljs-built_in">std</span>::max(ans, x * x + y * y);  <span class="hljs-comment">// 计算离原点的距离的平方</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; groupAnagrams(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; strs) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; h;  <span class="hljs-comment">// 哈希表，键是排序后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strs) &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> key = str;<br>            <span class="hljs-built_in">std</span>::sort(key.begin(), key.end());  <span class="hljs-comment">// 将字符串排序</span><br>            h[key].push_back(str);  <span class="hljs-comment">// 将原始字符串加入哈希表</span><br>        &#125;<br>        <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : h) &#123;<br>            result.push_back(p.second);  <span class="hljs-comment">// 收集结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<p>++++</p>
<h2 id="十一-并查集"><a href="#十一-并查集" class="headerlink" title="十一.并查集"></a>十一.并查集</h2><p>1.返回两个集合是否相同：查上游是否是一个节点，最后一个节点指向自己</p>
<p>2.取并集：小挂大上</p>
<h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">4</span> <span class="hljs-number">5</span><br>U <span class="hljs-number">1</span> <span class="hljs-number">2</span><br>U <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>F <span class="hljs-number">1</span> <span class="hljs-number">3</span><br>U <span class="hljs-number">2</span> <span class="hljs-number">3</span><br>F <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 假设节点数的最大值</span><br><span class="hljs-type">int</span> p[N];  <span class="hljs-comment">// 存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) &#123;<br>        p[x] = find(p[x]);  <span class="hljs-comment">// 路径压缩</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;  <span class="hljs-comment">// n:节点数, m:操作数</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        p[i] = i;  <span class="hljs-comment">// 每个节点的祖宗节点是自己</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op;  <span class="hljs-comment">// 操作类型，&#x27;U&#x27; 表示 Union，&#x27;F&#x27; 表示 Find</span><br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op &gt;&gt; a &gt;&gt; b;<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 合并操作</span><br>            p[find(a)] = find(b);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;F&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 查询操作，输出a和b是否属于同一个集合</span><br>            <span class="hljs-keyword">if</span> (find(a) == find(b)) &#123;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// a 和 b 在同一集合</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// a 和 b 不在同一集合</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="维护size的并查集："><a href="#维护size的并查集：" class="headerlink" title="维护size的并查集："></a>维护size的并查集：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">//  p = [2, 2, 3, 4, 5]   // 1 挂到 2 下  size = [1, 2, 1, 1, 1] // 2 变成祖宗，大小变为 2</span><br><br><br><br><span class="hljs-type">int</span> p[N], size[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[find(a)] = find(b);<br>    size[b] += size[a];<br></code></pre></td></tr></table></figure>

<h3 id="维护到祖宗节点距离的并查集："><a href="#维护到祖宗节点距离的并查集：" class="headerlink" title="维护到祖宗节点距离的并查集："></a>维护到祖宗节点距离的并查集：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//p = [2, 2, 3, 4, 5]   // 1 → 2   d = [3, 0, 0, 0, 0]   // d[1] = 3（1 到 2 的偏移量）</span><br><br><span class="hljs-type">int</span> p[N], d[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        &#123;<br>            <span class="hljs-type">int</span> u = find(p[x]);<br>            d[x] += d[p[x]];<br>            p[x] = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        d[I] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[find(a)] = find(b);<br>    d[find(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure>

<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h4 id="朋友圈问题"><a href="#朋友圈问题" class="headerlink" title="朋友圈问题"></a>朋友圈问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">205</span>; <span class="hljs-comment">// 假设最多有 200 个城市</span><br><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 记录每个城市的祖宗节点</span><br><span class="hljs-comment">// 查找 x 的祖宗节点（带路径压缩）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]); <span class="hljs-comment">// 让 x 直接指向根，优化查询速度</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 合并 a 和 b 所在的集合</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    p[find(a)] = find(b); <span class="hljs-comment">// 让 a 的祖宗指向 b 的祖宗，合并两个集合</span><br>&#125;<br><span class="hljs-comment">// 计算省份数量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> &#123;<br>    <span class="hljs-type">int</span> n = isConnected.size(); <span class="hljs-comment">// 城市数量</span><br>    <span class="hljs-comment">// 初始化并查集，每个城市的祖宗是自己</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) p[i] = i;<br>    <span class="hljs-comment">// 遍历上三角矩阵，合并相连的城市</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[i][j]) &#123;<br>                unite(i, j); <span class="hljs-comment">// 直接连接的城市合并到同一集合</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 统计不同的祖宗节点数量</span><br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt; provinces;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        provinces.insert(find(i)); <span class="hljs-comment">// 找到 i 的祖宗节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> provinces.size(); <span class="hljs-comment">// 祖宗节点的个数就是省份数</span><br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; isConnected = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; findCircleNum(isConnected) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出省份数量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> p[N], size[N];  <span class="hljs-comment">// p[] 记录父节点, size[] 记录集合大小</span><br><span class="hljs-type">int</span> count;  <span class="hljs-comment">// 记录当前岛屿数量</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);  <span class="hljs-comment">// 路径压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">int</span> fx = find(x), fy = find(y);<br>    <span class="hljs-keyword">if</span> (fx != fy) &#123;<br>        p[fx] = fy;<br>        count--;  <span class="hljs-comment">// 合并后岛屿数减少</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> &#123;<br>    <span class="hljs-keyword">if</span> (grid.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> rows = grid.size(), cols = grid[<span class="hljs-number">0</span>].size();<br>    count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows * cols; i++) p[i] = i;<br><br>    <span class="hljs-comment">// 遍历矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                count++;  <span class="hljs-comment">// 发现一个新的岛屿</span><br>                <span class="hljs-type">int</span> idx = i * cols + j;<br>                <span class="hljs-comment">// 向右合并</span><br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; cols &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) unite(idx, idx + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 向下合并</span><br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; rows &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) unite(idx, idx + cols);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;&gt; grid = &#123;<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;<br>    &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; numIslands(grid) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<hr>
<h2 id="十二-树状数组"><a href="#十二-树状数组" class="headerlink" title="十二.树状数组"></a>十二.树状数组</h2><hr>
<h2 id="十三-线段树"><a href="#十三-线段树" class="headerlink" title="十三.线段树"></a>十三.线段树</h2><hr>
<h2 id="十四-递归"><a href="#十四-递归" class="headerlink" title="十四.递归"></a>十四.递归</h2><p>汉罗塔问题</p>
<p>只要将主过程想好，也就是</p>
<p>一.12从左到中   二.3从左到右   三.12从中到右    如果是n个数呢，就简化为1<del>n-1从左到中，n从左到右，1</del>n-1从中到右就如此简化下去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">f（x）&#123;<br>    <span class="hljs-type">int</span> x;      <span class="hljs-comment">//这里是局部变量，还会再开一次int x。所以就是由每个f各自都有一	f(n-1) 份儿  ，所以这些就是如果说非局部的变量。  你不能说某一次f把它改了之后算别的f的时候诶, 它们需要注意保护跟还原这                                                      </span><br>&#125;                                                                                            <br></code></pre></td></tr></table></figure>

<p>基本框架：</p>
<ul>
<li>设计一个黑盒,即这个函数解决的问题,这些代码在当前进程的操作,调用函数相当于开了一个新进程（树）,数学上就像数列f（x），每一个小块即fx都要做什么</li>
<li>定义递归的边界</li>
<li>保护还原现场</li>
</ul>
<h3 id="三个模版"><a href="#三个模版" class="headerlink" title="三个模版"></a>三个模版</h3><h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><p>给定一个数组 <code>nums</code>，要求生成所有的子集。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">recur</span>(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == n) &#123; <span class="hljs-comment">// 递归终止条件</span><br>            ans.<span class="hljs-built_in">push_back</span>(chosen);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归不选当前元素</span><br>        <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归选择当前元素</span><br>        chosen.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择，还原现场，这里的chosen属于非局部变量</span><br>        chosen.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br></code></pre></td></tr></table></figure>





<hr>
<h4 id="组合问题："><a href="#组合问题：" class="headerlink" title="组合问题："></a>组合问题：</h4><p>给定整数 <code>n</code> 和 <code>k</code>，从 <code>[1, 2, ..., n]</code> 中选择 <code>k</code> 个数的所有组合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n; <span class="hljs-comment">//将函数参数 n 的值赋给类的成员变量 n</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-built_in">recur</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-comment">// 剪枝条件</span><br>        <span class="hljs-keyword">if</span> (chosen.<span class="hljs-built_in">size</span>() + (n - i + <span class="hljs-number">1</span>) &lt; k) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (i == n + <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(chosen);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不选当前元素</span><br>        <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 选择当前元素</span><br>        chosen.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        chosen.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> n, k;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br></code></pre></td></tr></table></figure>





<hr>
<h4 id="全排列问题："><a href="#全排列问题：" class="headerlink" title="全排列问题："></a><strong>全排列问题</strong>：</h4><p>给定一个不包含重复数字的数组 <code>nums</code>，要求生成所有可能的全排列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    used = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; (n,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">recur</span>(nums,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">private</span>：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos == n) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(a);  <span class="hljs-comment">// 找到一个排列</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!used[i]) &#123;        <span class="hljs-comment">//过滤used用过的</span><br>            a.<span class="hljs-built_in">push_back</span>(num[i]);<br>            used[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为使用</span><br>            <span class="hljs-built_in">recur</span>(nums, pos + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 递归下一层</span><br>            used[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记为未使用</span><br>            a.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    <span class="hljs-type">int</span> n;<br>    vector &lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<p>以上三个问题都是递归实现的“暴力搜索”(或者叫枚举、回溯等)可以总结为以下三种基本形式<br>递归形式<br>指数型	排列型	组合型<br>时间复杂度规模:kn	n!	n!&#x2F;m!(n-m)!<br>子集、大体积背包	全排列、旅行商、N 皇后找顺序的题目	组合选数</p>
<h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><h4 id="反转二叉树："><a href="#反转二叉树：" class="headerlink" title="反转二叉树："></a><strong>反转二叉树</strong>：</h4><p>该问题要求对一个二叉树进行左右子树的交换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 空节点返回</span><br>    TreeNode* temp = root-&gt;left;  <span class="hljs-comment">// 交换左右子树</span><br>    root-&gt;left = root-&gt;right;<br>    root-&gt;right = temp;<br>    <span class="hljs-built_in">invertTree</span>(root-&gt;left);  <span class="hljs-comment">// 递归反转左子树</span><br>    <span class="hljs-built_in">invertTree</span>(root-&gt;right);  <span class="hljs-comment">// 递归反转右子树</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="翻转一棵二叉树"><a href="#翻转一棵二叉树" class="headerlink" title="翻转一棵二叉树"></a>翻转一棵二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义二叉树节点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br><br>    <span class="hljs-comment">// 构造函数：初始化节点</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 翻转二叉树的递归函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 基础条件：节点为空时直接返回</span><br><br>        <span class="hljs-comment">// 交换左右子树</span><br>        TreeNode* temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br><br>        <span class="hljs-comment">// 递归处理左右子树</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> root;  <span class="hljs-comment">// 返回翻转后的根节点</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 辅助函数：先序遍历输出二叉树的节点值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>思路一 (自底向上统计信息，分治思想) 最大深度 &#x3D;max(左子树最大深度，右子树最大深度)+1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 递归计算二叉树的最大深度</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 如果节点为空，深度为0</span><br>        <span class="hljs-comment">// 递归计算左右子树的深度，并返回较大的深度加1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>思路二(自顶向下维护信息)<br>把“深度”作为一个全局变量–一个跟随结点移动而动态变化的信息递归一层，变量+1，在叶子处更新答案这种写法需要注意保护和还原现场</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() : <span class="hljs-built_in">depth</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">ans</span>(<span class="hljs-number">0</span>) &#123;&#125;  <span class="hljs-comment">// 构造函数初始化</span><br>    <span class="hljs-comment">// 计算二叉树最大深度的主函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">calc</span>(root);  <span class="hljs-comment">// 调用递归函数</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> depth;  <span class="hljs-comment">// 当前递归深度</span><br>    <span class="hljs-type">int</span> ans;    <span class="hljs-comment">// 存储最大深度</span><br><br>    <span class="hljs-comment">// 递归计算深度的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 空节点返回</span><br>        <span class="hljs-comment">// 更新最大深度</span><br>        ans = <span class="hljs-built_in">max</span>(ans, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 深度增加，递归遍历左子树和右子树</span><br>        depth++;<br>        <span class="hljs-built_in">calc</span>(root-&gt;left);<br>        <span class="hljs-built_in">calc</span>(root-&gt;right);<br>        <span class="hljs-comment">// 回溯时减少深度</span><br>        depth--;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="递归实现-pow-x-n-问题："><a href="#递归实现-pow-x-n-问题：" class="headerlink" title="递归实现 pow(x, n) 问题：****"></a><strong>递归实现 <code>pow(x, n)</code> 问题</strong>：****</h4><p>计算 <code>x</code> 的 <code>n</code> 次方。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li><strong>递归公式</strong>：<ul>
<li>如果 <code>n</code> 为偶数，<code>pow(x, n) = pow(x, n / 2) * pow(x, n / 2)</code>。</li>
<li>如果 <code>n</code> 为奇数，<code>pow(x, n) = pow(x, (n - 1) / 2) * pow(x, (n - 1) / 2) * x</code>。</li>
<li>如果 <code>n</code> 为负数，则 <code>pow(x, n) = 1 / pow(x, -n)</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 任何数的 0 次方都等于 1</span><br>    <span class="hljs-keyword">if</span> (n == INT_MIN) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">myPow</span>(x, -(n<span class="hljs-number">+1</span>)) * x);  <span class="hljs-comment">// 处理 n 为最小负数的特殊情况</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-built_in">myPow</span>(x, -n);  <span class="hljs-comment">// 负数次幂</span><br>    <span class="hljs-type">double</span> temp = <span class="hljs-built_in">myPow</span>(x, n / <span class="hljs-number">2</span>);  <span class="hljs-comment">// 递归计算</span><br>    <span class="hljs-type">double</span> ans = temp * temp;  <span class="hljs-comment">// 平方</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ans *= x;  <span class="hljs-comment">// 处理奇数次幂</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(log n)，递归每次将 <code>n</code> 减半。</li>
<li><strong>空间复杂度</strong>：O(log n)，递归调用栈的深度。</li>
</ul>
<hr>
<h4 id="括号生成问题："><a href="#括号生成问题：" class="headerlink" title="括号生成问题：****"></a><strong>括号生成问题</strong>：****</h4><p>给定整数 <code>n</code>，生成所有可能的包含 <code>n</code> 对括号的有效组合。</p>
<p><strong>算法思路</strong>：</p>
<ul>
<li>使用递归生成所有括号组合，依次生成 <code>k</code> 对括号与 <code>n-k</code> 对括号的组合，再将它们合并。</li>
<li><strong>递归优化</strong>：通过 <code>unordered_map</code> 缓存中间结果，避免重复计算（记忆化搜索）。</li>
<li>设生成的括号组合可以看作 <code>S = (A)B</code>其中 <code>A</code> 是在 <code>k-1</code> 对括号的基础上生成的组合，<code>B</code> 是在 <code>n-k</code> 对括号的基础上生成的组合。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;  <span class="hljs-comment">// 基本情况，n=0时返回空字符串</span><br>    <span class="hljs-keyword">if</span> (store.<span class="hljs-built_in">find</span>(n) != store.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> store[n];  <span class="hljs-comment">// 如果已经计算过，直接返回缓存的结果</span><br>    <br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;  <span class="hljs-comment">// 遍历所有可能的 k 值(A)B</span><br>        vector&lt;string&gt; A = <span class="hljs-built_in">generateParenthesis</span>(k - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 生成 k-1 对括号</span><br>        vector&lt;string&gt; B = <span class="hljs-built_in">generateParenthesis</span>(n - k);  <span class="hljs-comment">// 生成 n-k 对括号</span><br>        <span class="hljs-keyword">for</span> (string&amp; a : A) &#123;<br>            <span class="hljs-keyword">for</span> (string&amp; b : B) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;(&quot;</span> + a + <span class="hljs-string">&quot;)&quot;</span> + b);  <span class="hljs-comment">// 将两部分组合</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    store[n] = ans;  <span class="hljs-comment">// 缓存当前 n 对括号的所有组合</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;string&gt;&gt; store;  <span class="hljs-comment">// 用于记忆化搜索，避免重复计算</span><br></code></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><strong>记忆化搜索</strong>：通过 <code>unordered_map</code> 缓存递归中间结果，避免重复计算，提升效率。</li>
<li><strong>时间复杂度</strong>：理论上为 O(4^n &#x2F; sqrt(n))，因为每次递归生成所有可能的括号组合。</li>
</ul>
<hr>
<h2 id="十五-二叉树"><a href="#十五-二叉树" class="headerlink" title="十五.二叉树"></a>十五.二叉树</h2><p>二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。</p>
<p><strong>遍历方式</strong>：</p>
<ul>
<li><strong>前序遍历</strong>（Pre-order Traversal）：按根节点 -&gt; 左子树 -&gt; 右子树的顺序遍历。</li>
<li><strong>中序遍历</strong>（In-order Traversal）：按左子树 -&gt; 根节点 -&gt; 右子树的顺序遍历。</li>
<li><strong>后序遍历</strong>（Post-order Traversal）：按左子树 -&gt; 右子树 -&gt; 根节点的顺序遍历。</li>
<li><strong>层次遍历</strong>（Level-order Traversal）：按层从上到下、从左到右的顺序遍历树节点。</li>
</ul>
<h4 id="遍历方式总结："><a href="#遍历方式总结：" class="headerlink" title="遍历方式总结："></a><strong>遍历方式总结</strong>：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 二叉树节点定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 前序遍历 (根-左-右)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preorder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 中序遍历 (左-根-右)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">// 后序遍历 (左-右-根)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postorder</span>(root-&gt;right);<br>    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 层序遍历 (广度优先遍历)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>&#125;<br>              a<br>            /  \<br>           b      c<br>         / \    / \<br>        d   e   f   g<br>                 <br>递归序：  a b d d d b e e e b a c f f f c g g g c a   这是计算机解决的流程即左右和本身               <br>前中后序就是挑哪个是：第一二三次出现排序            <br>规律：先序:abdec | fg <br>        后序:debf | gca     任意选一个字母例如f，先序前和后序后的交集ca就是它全部的祖先<br></code></pre></td></tr></table></figure>

<h3 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h3><p>树形dp——从左树底端开始左右孩子都要info信息然后整合成一个信息成为孩子给父信息</p>
<p>step1.想以x为头（答案）怎么实现，不是x头又怎么实现，把这些实现需要的状态空间info列出求全集</p>
<p>step2.这些信息初始化在 Info process ，将这些信息在Info process这个函数里实现，如果这个信息涉及之前的分类讨论，就分多条件讨论</p>
<h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><h4 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断是否为完全二叉树，第一，此题不用区分是不是头，判断需要看左右孩子是否是平衡二叉树，做到这里需要知道左右孩子的高度，所以info信息里需要知道是不是平衡二叉树和高度是几就行。然后就是如何判断是否为二叉树的算法，如何得到高度的算法Info process写在这个函数里,要么穷举出所有可能，要么写算法判断</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span>   <span class="hljs-comment">//每个节点需要的信息收集</span><br>    <span class="hljs-type">bool</span> isCBT;<br>    <span class="hljs-type">int</span> height;<br>    Info(<span class="hljs-type">bool</span> cbt, <span class="hljs-type">int</span> h) : isCBT(cbt), height(h) &#123;&#125;<br>&#125;;<br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* X)</span> &#123;   <span class="hljs-comment">//判断逻辑返回信息</span><br>    <span class="hljs-keyword">if</span> (!X) <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);<br>    Info leftInfo = process(X-&gt;left);<br>    Info rightInfo = process(X-&gt;right);<br>    <span class="hljs-type">int</span> height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> isCBT = leftInfo.isCBT &amp;&amp; rightInfo.isCBT &amp;&amp;<br>                 (leftInfo.height == rightInfo.height || leftInfo.height == rightInfo.height + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> Info(isCBT, height);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isCBT</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process(head).isCBT : <span class="hljs-literal">true</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="是否是二叉搜索树"><a href="#是否是二叉搜索树" class="headerlink" title="是否是二叉搜索树"></a>是否是二叉搜索树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//是否是二叉搜索树</span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 定义宏将 int 替换为 long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MIN LLONG_MIN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MAX LLONG_MAX</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">bool</span> isBST;<br>    INT max;  <span class="hljs-comment">// 使用 long long 类型</span><br>    INT min;  <span class="hljs-comment">// 使用 long long 类型</span><br>    Info(<span class="hljs-type">bool</span> i, INT ma, INT mi) : isBST(i), max(ma), min(mi) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">true</span>, INT_MIN, INT_MAX);  <span class="hljs-comment">// 空节点是合法的 BST</span><br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br>    <br>    INT max = x-&gt;value;  <span class="hljs-comment">// 使用 long long 类型</span><br>    <span class="hljs-keyword">if</span> (leftInfo.isBST) max = max(max, leftInfo.max);<br>    <span class="hljs-keyword">if</span> (rightInfo.isBST) max = max(max, rightInfo.max);<br><br>    INT min = x-&gt;value;  <span class="hljs-comment">// 使用 long long 类型</span><br>    <span class="hljs-keyword">if</span> (leftInfo.isBST) min = min(min, leftInfo.min);<br>    <span class="hljs-keyword">if</span> (rightInfo.isBST) min = min(min, rightInfo.min);<br><br>    <span class="hljs-type">bool</span> isBST = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!leftInfo.isBST || !rightInfo.isBST) isBST = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (leftInfo.isBST &amp;&amp; leftInfo.max &gt;= x-&gt;value) isBST = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (rightInfo.isBST &amp;&amp; rightInfo.min &lt;= x-&gt;value) isBST = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> Info(isBST, maxVal, minVal);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isBST</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process(head).isBST : <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 处理空树的情况</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="判断是否为平衡二叉树"><a href="#判断是否为平衡二叉树" class="headerlink" title="判断是否为平衡二叉树"></a>判断是否为平衡二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">bool</span> isBalanced;<br>    INT height;<br>    Info(<span class="hljs-type">bool</span> i, INT h) : isBalanced(i), height(h) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 空节点是平衡的，高度为 0</span><br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br>    <span class="hljs-comment">// 计算当前节点的高度</span><br>    INT height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;  <br>   <br>    <span class="hljs-type">bool</span> isBalanced = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!leftInfo.isBalanced || !rightInfo.isBalanced) &#123;<br>        isBalanced = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果左子树或右子树不平衡，当前节点也不平衡</span><br>    &#125;   <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftInfo.height - rightInfo.height) &gt; <span class="hljs-number">1</span>) &#123;<br>        isBalanced = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果左右子树高度差大于 1，当前节点不平衡</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> Info(isBalanced, height);  <span class="hljs-comment">// 返回当前节点是否平衡和它的高度</span><br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process(head).isBalanced : <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 处理空树的情况</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="判断是否为满二叉树"><a href="#判断是否为满二叉树" class="headerlink" title="判断是否为满二叉树"></a>判断是否为满二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 左树满 &amp;&amp; 右树满 &amp;&amp; 左右树高度一样 -&gt; 整棵树是满的</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 定义宏将 int 替换为 long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MIN LLONG_MIN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_MAX LLONG_MAX</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info2</span> &#123;</span><br>    <span class="hljs-type">bool</span> isFull;<br>    INT height;<br>    Info2(<span class="hljs-type">bool</span> f, INT h) : isFull(f), height(h) &#123;&#125;<br>&#125;;<br><br>Info2 <span class="hljs-title function_">process2</span><span class="hljs-params">(Node* h)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!h) <span class="hljs-keyword">return</span> Info2(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 空节点是满的，高度为 0</span><br>    Info2 leftInfo = process2(h-&gt;left);<br>    Info2 rightInfo = process2(h-&gt;right);<br>    <br>    <span class="hljs-type">bool</span> isFull = leftInfo.isFull &amp;&amp; rightInfo.isFull &amp;&amp; leftInfo.height == rightInfo.height;<br>    INT height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点的高度</span><br>    <span class="hljs-keyword">return</span> Info2(isFull, height);  <span class="hljs-comment">// 返回当前节点是否满和它的高度</span><br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head ? process2(head).isFull : <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 处理空树的情况，空树为满树</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="找最大二叉搜索子树"><a href="#找最大二叉搜索子树" class="headerlink" title="找最大二叉搜索子树"></a>找最大二叉搜索子树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//最大二叉搜索子树，当x不做头时要统计左右孩子最大二叉搜索子树的大小，当x做头时，左右是不是搜索二叉树，左右maxmin，左右树大小size，</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-type">int</span> x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">int</span> maxBSTSubtreeSize; <br>    <span class="hljs-type">int</span> allSize;  <span class="hljs-comment">//原本应该有isBST但是当allSize==maxBSTSubtreeSize，isBST就是true所以省略</span><br>    <span class="hljs-type">int</span> max;<br>    <span class="hljs-type">int</span> min;<br>    Info(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> ma, <span class="hljs-type">int</span> mi) : maxBSTSubtreeSize(m), allSize(a), max(ma), min(mi) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(TreeNode* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) &#123;<br>        <span class="hljs-keyword">return</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, INT_MIN, INT_MAX);  <span class="hljs-comment">// 空节点，大小为0，最大值最小值分别为 INT_MIN 和 INT_MAX</span><br>    &#125;<br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br><br>    <span class="hljs-comment">//初始值设置</span><br>    <span class="hljs-type">int</span> max = x-&gt;val;<br>    <span class="hljs-type">int</span> min = x-&gt;val;  <br>    <span class="hljs-type">int</span> allSize = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点算一个</span><br>    <span class="hljs-keyword">if</span> (leftInfo != null) &#123;<br>        maxVal = max(max, leftInfo.max);<br>        minVal = min(min, leftInfo.min);<br>        allSize += leftInfo.allSize;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rightInfo != null) &#123;<br>        max = max(max, rightInfo.max);<br>        min = min(min, rightInfo.min);<br>        allSize += rightInfo.allSize;<br>    &#125;<br>	<span class="hljs-comment">//p123是三种可能性，取出最大可能</span><br>    <span class="hljs-type">int</span> <span class="hljs-type">int</span> p1 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (leftInfo != null) p1 = leftInfo.maxBSTSubtreeSize;<br>    <span class="hljs-type">int</span> p2 = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (rightInfo != null) p2 = rightInfo.maxBSTSubtreeSize;<br>    <span class="hljs-type">int</span> p3 = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//接下来是一堆coding问题</span><br>    <span class="hljs-type">bool</span> leftBST = leftInfo == null ? <span class="hljs-literal">true</span> : (leftInfo.maxBSTSubtreeSize == leftInfo.allSize);<br>    <span class="hljs-type">bool</span> rightBST = rightInfo == null ? <span class="hljs-literal">true</span> : (rightInfo.maxBSTSubtreeSize == rightInfo.allSize);<br>    <span class="hljs-keyword">if</span> (leftBST &amp;&amp; rightBST) &#123;<br>        <span class="hljs-type">bool</span> leftMaxLessX = leftInfo == null ? <span class="hljs-literal">true</span> : (leftInfo.max &lt; x.val); <span class="hljs-comment">//左数小于x</span><br>        <span class="hljs-type">bool</span> rightMinMoreX = rightInfo == null ? <span class="hljs-literal">true</span> : (x.val &lt; rightInfo.min);<br>        <span class="hljs-keyword">if</span> (leftMaxLessX &amp;&amp; rightMinMoreX) &#123;<br>            <span class="hljs-type">int</span> leftSize = leftInfo == null ? <span class="hljs-number">0</span> : leftInfo.allSize;<br>            <span class="hljs-type">int</span> rightSize = rightInfo == null ? <span class="hljs-number">0</span> : rightInfo.allSize;<br>            p3 = leftSize + rightSize + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点也是BST子树的一部分</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Info(max(p1, max(p2, p3)), allSize, max, min);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">largestBSTSubtree</span><span class="hljs-params">(TreeNode* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> process(head).maxBSTSubtreeSize;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//最近公共祖先</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 定义树节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-type">int</span> x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 用于存储返回信息的结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">bool</span> findA;<br>    <span class="hljs-type">bool</span> findB;<br>    TreeNode* ans;<br><br>    Info(<span class="hljs-type">bool</span> fA, <span class="hljs-type">bool</span> fB, TreeNode* an) : findA(fA), findB(fB), ans(an) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 处理树节点的递归函数</span><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(TreeNode* x, TreeNode* a, TreeNode* b)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x == nullptr) &#123;<br>        <span class="hljs-keyword">return</span> Info(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, nullptr);<br>    &#125;<br><br>    <span class="hljs-comment">// 递归处理左右子树</span><br>    Info leftInfo = process(x-&gt;left, a, b);<br>    Info rightInfo = process(x-&gt;right, a, b);<br><br>    <span class="hljs-comment">// 当前节点是否是a或b</span><br>    <span class="hljs-type">bool</span> findA = (x == a) || leftInfo.findA || rightInfo.findA;<br>    <span class="hljs-type">bool</span> findB = (x == b) || leftInfo.findB || rightInfo.findB;<br><br>    TreeNode* ans = nullptr;<br><br>    <span class="hljs-comment">// 如果左子树或右子树已经找到了结果，则返回相应的结果</span><br>    <span class="hljs-keyword">if</span> (leftInfo.ans != nullptr) &#123;<br>        ans = leftInfo.ans;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightInfo.ans != nullptr) &#123;<br>        ans = rightInfo.ans;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果当前节点是a和b的共同祖先，则返回当前节点</span><br>        <span class="hljs-keyword">if</span> (findA &amp;&amp; findB) &#123;<br>            ans = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Info(findA, findB, ans);<br>&#125;<br><br><span class="hljs-comment">// 获取最低公共祖先</span><br>TreeNode* <span class="hljs-title function_">lowestAncestor</span><span class="hljs-params">(TreeNode* head, TreeNode* a, TreeNode* b)</span> &#123;<br>    <span class="hljs-keyword">return</span> process(head, a, b).ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="根据前序遍历和中序遍历重建二叉树："><a href="#根据前序遍历和中序遍历重建二叉树：" class="headerlink" title="根据前序遍历和中序遍历重建二叉树："></a>根据前序遍历和中序遍历重建二叉树：</h4><p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; preorder;<br>    vector&lt;<span class="hljs-type">int</span>&gt; inorder;<br><br>    <span class="hljs-comment">// 主函数：传入前序和中序遍历数组，开始构建二叉树</span><br>    TreeNode* buildTree(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder) &#123;<br>        <span class="hljs-built_in">this</span>-&gt;preorder = preorder;<br>        <span class="hljs-built_in">this</span>-&gt;inorder = inorder;<br>        <span class="hljs-keyword">return</span> build(<span class="hljs-number">0</span>, preorder.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 递归构建二叉树</span><br>    TreeNode* build(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2) &#123;<br>        <span class="hljs-keyword">if</span> (l1 &gt; r1) <span class="hljs-keyword">return</span> nullptr; <span class="hljs-comment">// 递归结束条件</span><br><br>        <span class="hljs-comment">// 构建当前子树的根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[l1]);<br><br>        <span class="hljs-comment">// 在中序遍历中找到根节点的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l2;<br>        <span class="hljs-keyword">while</span> (inorder[mid] != root-&gt;val) ++mid;<br><br>        <span class="hljs-comment">// 计算左子树的长度，并递归构建左右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftTreeSize</span> <span class="hljs-operator">=</span> mid - l2;<br>        root-&gt;left = build(l1 + <span class="hljs-number">1</span>, l1 + leftTreeSize, l2, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = build(l1 + leftTreeSize + <span class="hljs-number">1</span>, r1, mid + <span class="hljs-number">1</span>, r2);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//找到二叉树中最大距离</span><br><span class="hljs-comment">//x作为头节点时，要左右最大高度，x不作为头节点时，要左和右统计出来的最大距离，总结要高度和最大距离，最大距离的计算：x左右的最大距离，x高度得出来的距离取max</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* left;<br>    Node* right;<br>    Node(<span class="hljs-type">int</span> data) : value(data), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span> &#123;</span><br>    <span class="hljs-type">int</span> maxDistance;<br>    <span class="hljs-type">int</span> height;<br>    Info(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> h) : maxDistance(m), height(h) &#123;&#125;<br>&#125;;<br><br>Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node* x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!x) &#123;<br>        <span class="hljs-keyword">return</span> Info(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果是空节点，最大距离为0，高度为0</span><br>    &#125;<br>    Info leftInfo = process(x-&gt;left);<br>    Info rightInfo = process(x-&gt;right);<br>    <br>    <span class="hljs-type">int</span> height = max(leftInfo.height, rightInfo.height) + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 计算三种情况的最大值</span><br>    <span class="hljs-type">int</span> p1 = leftInfo.maxDistance;<br>    <span class="hljs-type">int</span> p2 = rightInfo.maxDistance;<br>    <span class="hljs-type">int</span> p3 = leftInfo.height + rightInfo.height + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点的最大距离为左子树高度 + 右子树高度 + 1</span><br><br>    <span class="hljs-type">int</span> maxDistance = max(&#123;p1, p2, p3&#125;);<br>    <span class="hljs-keyword">return</span> Info(maxDistance, height);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxDistance</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-keyword">return</span> process(head).maxDistance;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>- </p>
<ul>
<li><strong>分析</strong>：<ul>
<li>前序遍历的第一个元素是当前子树的根节点。</li>
<li>在中序遍历中找到根节点，划分出左子树和右子树。</li>
<li>递归地对左右子树进行同样的处理。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h4 id="找到两个节点的最近公共祖先："><a href="#找到两个节点的最近公共祖先：" class="headerlink" title="找到两个节点的最近公共祖先："></a><strong>找到两个节点的最近公共祖先</strong>：</h4><p><strong>问题描述</strong>：                                                                                                                                                           </p>
<p> 先求出父结点，然后用向上标记法<br>p 向上一直到 root 标红色<br>q向上，第一次遇到红色时，就找到了LCA</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;iostream&gt;<br>using namespace std;<br><br><span class="hljs-comment">// 树的节点结构</span><br>struct TreeNode &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-type">int</span> x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* p = nullptr;<br>    TreeNode* q = nullptr;<br>    TreeNode* ans = nullptr;<br><br>    <span class="hljs-comment">// 寻找二叉树中两个节点的最近公共祖先</span><br>    TreeNode* Ansestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-built_in">this</span>-&gt;p = p;<br>        <span class="hljs-built_in">this</span>-&gt;q = q;<br>        ans = nullptr;  <span class="hljs-comment">// 确保 ans 在每次调用时都为 nullptr</span><br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 深度优先搜索辅助函数，返回包含 p 和 q 的标记</span><br>    pair&lt;bool, bool&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;<br><br>        <span class="hljs-comment">// 递归查找左子树和右子树</span><br>        pair&lt;bool, bool&gt; leftResult = dfs(root-&gt;left);<br>        pair&lt;bool, bool&gt; rightResult = dfs(root-&gt;right);<br><br>        <span class="hljs-comment">// 当前节点是否包含 p 或 q 的状态</span><br>        pair&lt;bool, bool&gt; result;<br>        result.first = leftResult.first || rightResult.first || root == p;<br>        result.second = leftResult.second || rightResult.second || root == q;<br><br>        <span class="hljs-comment">// 若当前节点同时包含 p 和 q 且 ans 尚未被设置，则将当前节点设置为答案</span><br>        <span class="hljs-keyword">if</span> (result.first &amp;&amp; result.second &amp;&amp; ans == nullptr) &#123;<br>            ans = root;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="十六-图"><a href="#十六-图" class="headerlink" title="十六.图"></a>十六.图</h2><h3 id="图的写法"><a href="#图的写法" class="headerlink" title="图的写法"></a>图的写法</h3><p>其他形式的图全抽象为————出边数组实现</p>
<p>无向图版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// edges = &#123;&#123;0, 1&#125;,&#123;1, 2&#125;,&#123;2, 3&#125;,&#123;0, 2&#125;,&#123;3, 4&#125;&#125;;</span><br><span class="hljs-comment">//to = &#123; &#123;1, 2&#125;, &#123;0, 2&#125;, &#123;1, 3, 0&#125;, &#123;2, 4&#125;, &#123;3&#125; &#125;;</span><br>          <span class="hljs-number">0</span>         <span class="hljs-number">1</span>         <span class="hljs-number">2</span>        <span class="hljs-number">3</span>     <span class="hljs-number">4</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge:edges)&#123; <span class="hljs-comment">//找到最大编号</span><br>    <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>    n = <span class="hljs-built_in">max</span>(n,<span class="hljs-built_in">max</span>(x,y));<br>&#125;<br>n++;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(n);  <span class="hljs-comment">// 每个节点对应一个空的 vector&lt;int&gt;</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge:edges)&#123;<br>    <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>    to[x].<span class="hljs-built_in">push_back</span>(y);  <br>    to[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有向图带路径版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0</span>: (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)      matrix<br><span class="hljs-number">1</span>: (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <br><span class="hljs-number">2</span>: (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <br><span class="hljs-number">3</span>: <br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; convertToAdjacencyListWithWeights(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : matrix) &#123;<br>        <span class="hljs-type">int</span> from = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 起始节点</span><br>        <span class="hljs-type">int</span> to = edge[<span class="hljs-number">2</span>];    <span class="hljs-comment">// 目标节点</span><br>        n = max(n, max(from, to));  <span class="hljs-comment">// 找到最大的节点编号</span><br>    &#125;<br>    n++; <span class="hljs-comment">// 因为节点编号是从 0 开始的，所以图的大小应该是最大编号 + 1</span><br>    <br>    <span class="hljs-comment">// 第二步：初始化邻接表，用 pair 存储目标节点和边的权重</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; adjList(n);<br>    <br>    <span class="hljs-comment">// 第三步：根据输入的矩阵填充邻接表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge : matrix) &#123;<br>        <span class="hljs-type">int</span> weight = edge[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 边的权重</span><br>        <span class="hljs-type">int</span> from = edge[<span class="hljs-number">1</span>];    <span class="hljs-comment">// 起始节点</span><br>        <span class="hljs-type">int</span> to = edge[<span class="hljs-number">2</span>];      <span class="hljs-comment">// 目标节点</span><br>        adjList[from].push_back(&#123;to, weight&#125;);  <span class="hljs-comment">// 将边加入邻接表</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> adjList;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p><strong>DFS</strong>：判断</p>
<p>DFS 是一种图或树的遍历算法，它沿着一条路径尽可能深入，然后回溯，继续探索其他路径。</p>
<p>DFS 的实现方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//记得初始化</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to; <span class="hljs-comment">//构建出边数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n,<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    visited[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>        <span class="hljs-keyword">if</span>(y == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!visited[y]) &#123;<br>            <span class="hljs-built_in">dfs</span>(y,x);  <span class="hljs-comment">// 递归访问未访问的邻居</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            hasClcye = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>BFS</strong>：</p>
<p>BFS 的实现方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);  <span class="hljs-comment">// 将起点加入队列</span><br>    depth[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 标记起点已访问</span><br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 从队列中取出一个节点</span><br><br>        <span class="hljs-comment">// 访问该节点的所有邻居</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>            <span class="hljs-keyword">if</span>(depth[y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            depth[y] = depth[x] + <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>BFS 有向图————拓扑排序 </p>
<p>来验证是否能正确排序版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(n);  <span class="hljs-comment">// 这里是已经构建好的to</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDeg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// 创建并初始化 inDeg</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123; <br>    <span class="hljs-type">int</span> from = edge[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> toNode = edge[<span class="hljs-number">0</span>];<br>    to[from].<span class="hljs-built_in">push_back</span>(toNode);<br>    inDeg[toNode]++;<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; sortOrder;  <span class="hljs-comment">// 修改为正确的变量名</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();  <br>    sortOrder.<span class="hljs-built_in">push_back</span>(x);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>        inDeg[y]--;<br>        <span class="hljs-keyword">if</span> (inDeg[y] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> sortOrder.<span class="hljs-built_in">size</span>() == n;<br><span class="hljs-comment">// 输出最终的排序结果</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : sortOrder) &#123;<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>cout &lt;&lt; endl;  <span class="hljs-comment">// 换行，输出结束</span><br><br></code></pre></td></tr></table></figure>

<p>输出所有拓扑排序版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">// 回溯生成所有拓扑排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">allTopologicalSorts</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; inDeg, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; sortOrder)</span> &#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 用来检查是否有入度为 0 的节点</span><br><br>    <span class="hljs-comment">// 遍历所有节点，查找入度为 0 且未访问的节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span> &amp;&amp; !visited[i]) &#123;<br>            <span class="hljs-comment">// 标记该节点已访问</span><br>            visited[i] = <span class="hljs-literal">true</span>;<br>            sortOrder.push_back(i);  <span class="hljs-comment">// 将该节点加入拓扑排序</span><br>            <span class="hljs-comment">// 将该节点的邻接节点的入度减 1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[i]) &#123;<br>                inDeg[y]--;<br>            &#125;<br>            <span class="hljs-comment">// 递归调用生成后续的拓扑排序</span><br>            allTopologicalSorts(n, to, inDeg, visited, sortOrder);<br>            <span class="hljs-comment">// 回溯过程：恢复状态</span><br>            visited[i] = <span class="hljs-literal">false</span>;<br>            sortOrder.pop_back();  <span class="hljs-comment">// 移除当前节点</span><br>            <span class="hljs-comment">// 恢复该节点邻接节点的入度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[i]) &#123;<br>                inDeg[y]++;<br>            &#125;<br>            flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记已经处理了一个入度为 0 的节点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有更多节点可以选择，说明已经生成了一个完整的拓扑排序</span><br>    <span class="hljs-keyword">if</span> (!flag) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : sortOrder) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出当前的拓扑排序</span><br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 主函数：执行拓扑排序</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">generateAllTopologicalSorts</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; to(n);  <br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">inDeg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>;    <span class="hljs-comment">// 入度数组</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title function_">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span>;  <span class="hljs-comment">// 访问标记数组</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; sortOrder;      <span class="hljs-comment">// 存储当前拓扑排序</span><br>    <span class="hljs-comment">// 构建图的邻接表和入度数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>        <span class="hljs-type">int</span> from = edge[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 边的起点</span><br>        <span class="hljs-type">int</span> toNode = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 边的终点</span><br>        to[from].push_back(toNode);  <span class="hljs-comment">// 添加边到邻接表</span><br>        inDeg[toNode]++;  <span class="hljs-comment">// 终点的入度加1</span><br>    &#125;<br>    <span class="hljs-comment">// 调用回溯函数生成所有拓扑排序</span><br>    allTopologicalSorts(n, to, inDeg, visited, sortOrder);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 返回成功</span><br>&#125;<br><span class="hljs-type">signed</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;  <span class="hljs-comment">// 节点数</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; edges = &#123;<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;  <span class="hljs-comment">// 边列表</span><br>    &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;All Topological Sorts: &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    generateAllTopologicalSorts(n, edges);  <span class="hljs-comment">// 生成并输出所有拓扑排序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="Kruskal-算法：生成最小生成树"><a href="#Kruskal-算法：生成最小生成树" class="headerlink" title="Kruskal 算法：生成最小生成树"></a>Kruskal 算法：生成最小生成树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> p[N];  <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-comment">// 存储图的边 &#123;权重, &#123;节点a, 节点b&#125;&#125;</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; edges;<br><br><span class="hljs-comment">// 并查集的核心操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> p[x] == x ? x : (p[x] = find(p[x]));<br>&#125;<br><br><span class="hljs-comment">// Kruskal 算法：生成最小生成树</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;  <span class="hljs-comment">// 初始化并查集</span><br><br>    sort(edges.begin(), edges.end());  <span class="hljs-comment">// 按权重排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>        <span class="hljs-type">int</span> w = edge.first, a = edge.second.first, b = edge.second.second;<br>        a = find(a), b = find(b);<br><br>        <span class="hljs-keyword">if</span> (a != b) &#123;  <span class="hljs-comment">// 如果不在同一连通块</span><br>            p[a] = b;  <span class="hljs-comment">// 合并</span><br>            res += w;<br>            <span class="hljs-keyword">if</span> (++cnt == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 已经形成最小生成树</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cnt == n - <span class="hljs-number">1</span> ? res : <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果不连通，返回 -1</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 输入边</span><br>    edges.resize(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        edges[i] = &#123;w, &#123;a, b&#125;&#125;;<br>    &#125;<br><br>    <span class="hljs-type">int</span> result = kruskal(n, m);<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无法生成最小生成树&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最小生成树的权重是: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>单起点多终点正权最短路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long  <span class="hljs-comment">// 定义为 long long 方便处理大数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;  <span class="hljs-comment">// 预设最大节点数</span><br><span class="hljs-type">int</span> n, m;                <span class="hljs-comment">// 节点数和边数</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; to;  <span class="hljs-comment">// 用邻接表存储图（出边数组）</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; dist;        <span class="hljs-comment">// 存储最短路径</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; st;         <span class="hljs-comment">// 存储每个点是否已经确定最短路径</span><br><br><span class="hljs-comment">// 图的构建函数：添加一条边</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> weight)</span> &#123;<br>    to[a].push_back(b); <span class="hljs-comment">// 有向图只添加 a -&gt; b</span><br>&#125;<br><br><span class="hljs-comment">// Dijkstra 算法：求 1 号点到 n 号点的最短路径</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">()</span> &#123;<br>    dist.assign(n, LLONG_MAX);  <span class="hljs-comment">// 初始化 dist 数组为无穷大</span><br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起点 0 的距离为 0</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  <span class="hljs-comment">// 最小堆</span><br>    heap.push(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);  <span class="hljs-comment">// 起点加入堆，&#123;距离, 节点&#125;</span><br><br>    <span class="hljs-keyword">while</span> (!heap.empty()) &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.top();<br>        heap.pop();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果已经访问过，则跳过</span><br>        st[ver] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点已访问</span><br><br>        <span class="hljs-comment">// 遍历当前节点的所有邻接点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : to[ver]) &#123;  <span class="hljs-comment">// 直接遍历出边数组</span><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 假设所有边权为 1</span><br>                dist[j] = distance + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 更新最短距离</span><br>                heap.push(&#123;dist[j], j&#125;);  <span class="hljs-comment">// 将更新后的邻接点加入堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回从 0 号点到 n-1 号点的最短距离</span><br>    <span class="hljs-keyword">if</span> (dist[n<span class="hljs-number">-1</span>] == LLONG_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果无法到达，返回 -1</span><br>    <span class="hljs-keyword">return</span> dist[n<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    to.resize(n);  <span class="hljs-comment">// 初始化邻接表</span><br><br>    <span class="hljs-comment">// 输入边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, weight;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; weight;<br>        add_edge(a, b, weight);  <span class="hljs-comment">// 添加边 a -&gt; b</span><br>    &#125;<br><br>    <span class="hljs-comment">// 执行 Dijkstra 算法</span><br>    <span class="hljs-type">int</span> result = dijkstra();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>单起点多终点负权最短路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>     // 边，<span class="hljs-title">a</span>表示出点，<span class="hljs-title">b</span>表示入点，<span class="hljs-title">w</span>表示边的权重</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bellman_ford</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="spfa-算法"><a href="#spfa-算法" class="headerlink" title="spfa 算法"></a>spfa 算法</h3><p>队列优化的Bellman-Ford算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">spfa</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.push(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.size())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.front();<br>        q.pop();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>spfa判断图中是否存在负环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">spfa</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.push(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.size())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.front();<br>        q.pop();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.push(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>多起点多终点最短路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">初始化：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>匈牙利算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-type">int</span> match[N];       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || find(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++ )<br>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-keyword">if</span> (find(i)) res ++ ;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>最小瓶颈路</p>
<h3 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h3><h4 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h4><p>edges &#x3D; [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5]]</p>
<p>算法实现</p>
<ol>
<li><strong>出边数组的构建</strong>：使用邻接表（出边数组）表示树的结构，方便遍历。</li>
<li>两次 BFS<ul>
<li>第一次 BFS 从任意节点出发（这里从节点 <code>0</code> 出发），找到距离最远的节点 <code>p</code>。</li>
<li>第二次 BFS 从 <code>p</code> 出发，找到距离最远的另一个节点，并返回此距离作为树的直径。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to; <span class="hljs-comment">// 出边数组</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">treeDiameter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>            n = <span class="hljs-built_in">max</span>(n, <span class="hljs-built_in">max</span>(x, y)); <span class="hljs-comment">// 计算最大节点编号</span><br>        &#125;<br>        n++; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++)	to.<span class="hljs-built_in">push_back</span>(&#123;&#125;); <span class="hljs-comment">//初始化</span><br>        <span class="hljs-comment">// 构建出边数组</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>            to[x].<span class="hljs-built_in">push_back</span>(y);<br>            to[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br><br>        <span class="hljs-comment">// 从任意节点 0 开始，找到最远的节点</span><br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">findFarthest</span>(<span class="hljs-number">0</span>).first;<br>        <span class="hljs-comment">// 从找到的最远节点 p 再次执行 BFS，求出树的直径</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFarthest</span>(p).second;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// &lt;点，距离&gt;</span><br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">findFarthest</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">depth</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 记录每个节点的深度，初始为 -1</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        depth[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起始节点的深度为 0</span><br>        <span class="hljs-comment">// BFS</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                <span class="hljs-keyword">if</span> (depth[y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过已访问节点</span><br>                depth[y] = depth[x] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新深度</span><br>                q.<span class="hljs-built_in">push</span>(y); <span class="hljs-comment">// 将该节点加入队列</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到距离最远的节点</span><br>        <span class="hljs-type">int</span> ans = start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (depth[i] &gt; depth[ans]) ans = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> &#123;ans, depth[ans]&#125;;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><p>输入: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]<br>输出: false<br>解释: 课程 1 依赖于课程 0，课程 0 也依赖于课程 1，形成循环，无法完成所有课程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化邻接表和入度表</span><br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        inDeg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 构建图</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre : prerequisites) &#123;<br>            <span class="hljs-type">int</span> ai = pre[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> bi = pre[<span class="hljs-number">1</span>];<br>            to[bi].<span class="hljs-built_in">push_back</span>(ai);<br>            inDeg[ai]++;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>       <span class="hljs-comment">//拓扑排序第一步:从零入度点出发</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; lessons;  <span class="hljs-comment">// 保存完成的课程</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            lessons.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-comment">// 第二步:扩展一个点，周围的点入度减一</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                inDeg[y]--;<br>                <span class="hljs-keyword">if</span> (inDeg[y] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);  <span class="hljs-comment">// 第三步:入度减为0，表示可以入队了</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果所有课程都能完成，返回true</span><br>        <span class="hljs-keyword">return</span> lessons.<span class="hljs-built_in">size</span>() == numCourses;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;   <span class="hljs-comment">// 邻接表</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; inDeg;        <span class="hljs-comment">// 入度表</span><br>&#125;;<br><span class="hljs-comment">//这个bfs就不用判重了。因为你有了indeg这个东西啊减为零才会入队。如果说有环，是不是根本就减不到零,他们就不会去访问啊，不会有重复，所以说这里我就不用判重</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设输入：</span><br><span class="hljs-comment">numCourses = 2</span><br><span class="hljs-comment">prerequisites = [[1, 0]]</span><br><span class="hljs-comment">这表示有 2 门课程，编号为 0 和 1。要完成课程 1，你必须先完成课程 0。</span><br><span class="hljs-comment">步骤 1：构建图和入度表</span><br><span class="hljs-comment">邻接表 to：这是一个二维向量，其中 to[bi] 保存了所有依赖于 bi 的课程，即 bi 的后续课程。在该例中：</span><br><span class="hljs-comment">to[0] 保存了课程 1，因为课程 1 依赖于课程 0。因此，to[0] = [1]，表示从课程 0 可以走到课程 1。</span><br><span class="hljs-comment">to[1] 没有后续课程，因此 to[1] 为空。</span><br><span class="hljs-comment">入度表 inDeg：这是一个一维向量，用来存储每个课程的入度，即需要先修多少门课程。在该例中：</span><br><span class="hljs-comment">课程 0 没有任何依赖，所以 inDeg[0] = 0。</span><br><span class="hljs-comment">课程 1 需要先修课程 0，所以 inDeg[1] = 1。</span><br><span class="hljs-comment">此时，邻接表和入度表如下：</span><br><span class="hljs-comment">to = [[1], []]</span><br><span class="hljs-comment">inDeg = [0, 1]</span><br><span class="hljs-comment">步骤 2：拓扑排序准备</span><br><span class="hljs-comment">我们需要找到所有入度为 0 的课程，也就是不需要先修课程就可以直接学习的课程。在该例中，课程 0 的入度为 0，因此我们将课程 0 加入队列 q。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = [0]</span><br><span class="hljs-comment">步骤 3：广度优先搜索（BFS）拓扑排序</span><br><span class="hljs-comment">处理课程 0：</span><br><span class="hljs-comment">从队列中取出课程 0 并将其标记为已完成（加入 lessons 列表）。</span><br><span class="hljs-comment">查看课程 0 的所有后续课程（在邻接表 to[0] 中查找），可以看到课程 1 依赖于课程 0。</span><br><span class="hljs-comment">减少课程 1 的入度（inDeg[1]--），此时课程 1 的入度变为 0，表示可以学习课程 1，将其加入队列。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = [1]</span><br><span class="hljs-comment">lessons = [0]</span><br><span class="hljs-comment">inDeg = [0, 0]</span><br><span class="hljs-comment">处理课程 1：</span><br><span class="hljs-comment">从队列中取出课程 1，并将其标记为已完成（加入 lessons 列表）。</span><br><span class="hljs-comment">课程 1 没有后续课程，因此队列处理完毕。</span><br><span class="hljs-comment">队列状态：</span><br><span class="hljs-comment">q = []</span><br><span class="hljs-comment">lessons = [0, 1]</span><br><span class="hljs-comment">步骤 4：判断结果 拓扑排序完成后，lessons 列表中包含了所有课程 [0, 1]，说明可以完成所有课程。 因此，最终返回 true。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总结： 这段代码使用的是拓扑排序算法，利用 BFS 来检测图中是否存在环： 如果所有课程都能在拓扑排序中被处理（即 lessons.size() == numCourses），说明没有循环依赖，可以完成所有课程。 如果存在环，则会有一些课程无法被处理，队列会提前结束，此时返回 false。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<h4 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        n = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化节点数</span><br>        <span class="hljs-comment">// 计算实际的最大节点编号（n）</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取当前边的两个节点</span><br>            n = <span class="hljs-built_in">max</span>(n, <span class="hljs-built_in">max</span>(x, y));  <span class="hljs-comment">// 更新最大节点编号</span><br>        &#125;<br><br>        <span class="hljs-comment">// 初始化邻接表和访问标记数组</span><br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        visited = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">// 遍历所有边，构建图并检查环</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取当前边的两个节点</span><br>            <br>            <span class="hljs-comment">// 添加边到邻接表中，构建无向图，邻接表的构建</span><br>            to[x].<span class="hljs-built_in">push_back</span>(y);<br>            to[y].<span class="hljs-built_in">push_back</span>(x);<br>            hasCycle = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 重置环标记</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 从节点1开始DFS，父节点设为0（不存在）</span><br><br>            <span class="hljs-comment">// 如果检测到环，返回当前边</span><br>            <span class="hljs-keyword">if</span> (hasCycle) <span class="hljs-keyword">return</span> edge;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果没有发现冗余边，返回空数组</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 深度优先搜索 (DFS) 用于检测是否形成环,dfs模版</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>        visited[x] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点已访问</span><br>        <span class="hljs-comment">// 遍历当前节点 x 的所有邻居节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>            <span class="hljs-keyword">if</span> (y == fa) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果是父节点，则跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[y]) &#123;<br>                <span class="hljs-comment">// 如果未访问，继续递归DFS</span><br>                <span class="hljs-built_in">dfs</span>(y, x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果已经访问过，说明存在环</span><br>                hasCycle = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;  <span class="hljs-comment">// 节点总数</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;  <span class="hljs-comment">// 邻接表，存储每个节点的邻居</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited;  <span class="hljs-comment">// 标记节点是否访问过</span><br>    <span class="hljs-type">bool</span> hasCycle;  <span class="hljs-comment">// 是否存在环的标记</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">遍历边 &#123;1, 2&#125;，图中没有环，继续。</span><br><span class="hljs-comment">遍历边 &#123;1, 3&#125;，图中没有环，继续。</span><br><span class="hljs-comment">遍历边 &#123;2, 3&#125;，此时检测到环，返回 &#123;2, 3&#125;。</span><br><span class="hljs-comment">假设输入：</span><br><span class="hljs-comment">edges = &#123;&#123;1, 2&#125;, &#123;1, 3&#125;, &#123;2, 3&#125;&#125;</span><br><span class="hljs-comment">这表示有 3 条边和 3 个节点，图的结构如下：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">复制代码</span><br><span class="hljs-comment">1 - 2</span><br><span class="hljs-comment">|   |</span><br><span class="hljs-comment">3 - -</span><br><span class="hljs-comment">我们需要找到一条冗余的边，这条边的加入会导致形成环。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">模拟执行过程：</span><br><span class="hljs-comment">第一步：初始化</span><br><span class="hljs-comment">初始化 n = 0，用于存储节点的最大编号。</span><br><span class="hljs-comment">遍历 edges，更新 n 为最大节点编号，最终得到 n = 3。</span><br><span class="hljs-comment">初始化邻接表 to 和访问标记数组 visited：</span><br><span class="hljs-comment">to = [[], [], [], []]  // 邻接表初始化，4 个空列表（因为节点编号从 1 开始）</span><br><span class="hljs-comment">visited = [false, false, false, false]  // 节点访问标记，全部为 false</span><br><span class="hljs-comment">第二步：开始遍历每一条边</span><br><span class="hljs-comment">我们依次处理每一条边，将其加入邻接表，并进行 DFS 检测是否有环。</span><br><span class="hljs-comment">处理边 &#123;1, 2&#125;：</span><br><span class="hljs-comment">将边 &#123;1, 2&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2], [1], []]  // 节点 1 和 2 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, false, false]</span><br><span class="hljs-comment">遍历节点 1 的邻居节点，发现节点 2 尚未访问，因此进入节点 2 的 DFS。</span><br><span class="hljs-comment">访问节点 2，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, false]</span><br><span class="hljs-comment">节点 2 的邻居是节点 1（父节点），跳过。</span><br><span class="hljs-comment">结束 DFS，没有发现环。</span><br><span class="hljs-comment">处理边 &#123;1, 3&#125;：</span><br><span class="hljs-comment">将边 &#123;1, 3&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2, 3], [1], [1]]  // 节点 1 和 3 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, false]</span><br><span class="hljs-comment">遍历节点 1 的邻居，发现节点 2 已访问过，跳过。</span><br><span class="hljs-comment">发现节点 3 尚未访问，进入节点 3 的 DFS。</span><br><span class="hljs-comment">访问节点 3，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, true]</span><br><span class="hljs-comment">节点 3 的邻居是节点 1（父节点），跳过。</span><br><span class="hljs-comment">结束 DFS，没有发现环。</span><br><span class="hljs-comment">处理边 &#123;2, 3&#125;：</span><br><span class="hljs-comment">将边 &#123;2, 3&#125; 加入邻接表：</span><br><span class="hljs-comment">to = [[], [2, 3], [1, 3], [1, 2]]  // 节点 2 和 3 互为邻居</span><br><span class="hljs-comment">重置 hasCycle = false，开始 DFS。</span><br><span class="hljs-comment">从节点 1 开始进行 DFS，父节点设为 0（不存在）。</span><br><span class="hljs-comment">DFS 过程：</span><br><span class="hljs-comment">访问节点 1，标记为已访问：</span><br><span class="hljs-comment">visited = [false, true, true, true]</span><br><span class="hljs-comment">遍历节点 1 的邻居，发现节点 2 已访问过，跳过。</span><br><span class="hljs-comment">发现节点 3 已访问过，跳过。</span><br><span class="hljs-comment">然后，节点 2 继续进行 DFS，发现节点 3 已访问过，但节点 3 不是父节点，说明形成环。</span><br><span class="hljs-comment">标记 hasCycle = true。</span><br><span class="hljs-comment">结束 DFS，发现环，冗余边是 &#123;2, 3&#125;。</span><br><span class="hljs-comment">第三步：返回结果</span><br><span class="hljs-comment">因为在处理边 &#123;2, 3&#125; 时发现了环，因此该边就是冗余边，返回：</span><br><span class="hljs-comment">&#123;2, 3&#125;</span><br><span class="hljs-comment">结果：</span><br><span class="hljs-comment">冗余边是 &#123;2, 3&#125;，这条边导致了环的出现。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">解释：</span><br><span class="hljs-comment">边 &#123;1, 2&#125; 和 &#123;1, 3&#125; 构建了图的主体结构，但在加入 &#123;2, 3&#125; 后，形成了一个环 1 → 2 → 3 → 1，因此 &#123;2, 3&#125; 是冗余边。</span><br><span class="hljs-comment">代码通过 DFS 递归检测邻居节点，如果发现某个已访问的节点不是当前节点的父节点，则说明有环出现。    </span><br><span class="hljs-comment">*/</span><br>    <br></code></pre></td></tr></table></figure>



<h4 id="环检测"><a href="#环检测" class="headerlink" title="环检测"></a><strong>环检测</strong></h4><p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; onPath)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点为已访问</span><br>    onPath[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点位于递归路径上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, to, visited, onPath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (onPath[v]) &#123;<br>            hasCycle = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 检测到环</span><br>        &#125;<br>    &#125;<br>    onPath[u] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 递归结束后，移除路径上的节点</span><br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="十七-搜索"><a href="#十七-搜索" class="headerlink" title="十七.搜索"></a>十七.搜索</h2><h3 id="状态与状态空间搜索"><a href="#状态与状态空间搜索" class="headerlink" title="状态与状态空间搜索"></a><strong>状态与状态空间搜索</strong></h3><ul>
<li><p><strong>状态</strong>：</p>
<p>什么是状态?题面中涉及的所有数学信息，你在纸上人力计算时，关注的所有数据，一个函数访问的所有变量，例如最简单的计票问题，给n个名字，统计每个名字出现了多少次，你在纸上画“正”字统计的时候，关注了哪些数据?名字(n个字符串)，统计到哪个名字了(第1≤i≤n个名字)，画的“正”字(一个用于计数的数据结构，例如 Hash Map，就是程序维护的所有动态数据构成的集合，我们关注动态变化的变量</p>
</li>
<li><p><strong>状态空间</strong></p>
<p>所有可能状态构成的集合就是一个问题的状态空间，把状态作为点，如果从一个状态可以到达另一个状态，就连一条边这样就把整，状态空间抽象为了一张有向图，对问题的求解，就是对这张图的遍历，计票问题的状态空间由n个状态组成，可以看作一张n个点，n-1条边的有向图，整张图是一条链，自然就可以用一维循环解决了</p>
</li>
<li><p><strong>搜索算法</strong>：</p>
<ul>
<li><strong>深度优先搜索（DFS）</strong>：优先探索当前路径，深入到不能继续为止，再进行回溯。适用于需要遍历整棵搜索树或图的场景。</li>
<li><strong>广度优先搜索（BFS）</strong>：按照层次逐步扩展所有状态，适用于最短路径等需要找到最早解的场景。</li>
<li>一般来说，每个状态只遍历一次所以当状态空间是“图”而不是“树”时，要判重(记忆化)</li>
</ul>
</li>
</ul>
<h3 id="状态搜索的步骤"><a href="#状态搜索的步骤" class="headerlink" title="状态搜索的步骤"></a><strong>状态搜索的步骤</strong></h3><p>搜索题的解题步骤<br>1.纸上模拟，提取信息<br>2.定义状态<br>3.确定遍历顺序(DFS、BFS)<br>4.定义搜索框架<br>    如果是DFS，状态作为参数，确定递归边界，注意还原现场<br>    如果是BFS，状态用队列保存<br>    考虑是否需要判重<br>5.程序实现</p>
<p><strong>DFS 和 BFS 的比较</strong>：</p>
<ul>
<li><strong>DFS</strong>：在找到目标解之前，会不断深入搜索某条路径。适用于找到所有解，或不关心最优解的场景。</li>
<li><strong>BFS</strong>：逐层扩展搜索，通常用于寻找最优解或最短路径。解决等权值最小路径问题</li>
</ul>
<hr>
<h3 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h3><h4 id="电话号码的字母组合问题："><a href="#电话号码的字母组合问题：" class="headerlink" title="电话号码的字母组合问题："></a>电话号码的字母组合问题：</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话按键一致。</p>
<p>例如：</p>
<ul>
<li>输入：”23”</li>
<li>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li>
</ul>
<p><strong>思路</strong>：</p>
<ul>
<li><strong>递归（DFS）实现</strong>：该问题可以被看作是一个递归问题，每个数字对应多个字母，每个数字的字母组合都与前一个数字的字母组合进行全排列。</li>
<li><strong>状态转移</strong>：每个状态表示当前递归到第几个数字，每次递归时选择对应数字所映射的字母，生成所有可能的字母组合。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">L</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;digits = digits;<br>        alphabet[<span class="hljs-string">&#x27;2&#x27;</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;3&#x27;</span>] = <span class="hljs-string">&quot;def&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;4&#x27;</span>] = <span class="hljs-string">&quot;ghi&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;5&#x27;</span>] = <span class="hljs-string">&quot;jkl&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;6&#x27;</span>] = <span class="hljs-string">&quot;mno&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;7&#x27;</span>] = <span class="hljs-string">&quot;pqrs&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;8&#x27;</span>] = <span class="hljs-string">&quot;tuv&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;9&#x27;</span>] = <span class="hljs-string">&quot;wxyz&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">length</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : alphabet[digits[index]]) &#123;<br>            <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, str + ch);<br>        &#125;<br>    &#125;<br><br>    string digits;<br>    vector&lt;string&gt; ans;<br>    unordered_map&lt;<span class="hljs-type">char</span>, string&gt; alphabet;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n 皇后问题"></a>n 皇后问题</h4><p>给你一个整数 n，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>输入：n &#x3D; 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”], [“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        used = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        vector&lt;vector&lt;string&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; p : ans) &#123;<br>            <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">pattern</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; n; row++)<br>                pattern[row][p[row]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            result.<span class="hljs-built_in">push_back</span>(pattern);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(p);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-keyword">if</span> (!used[col] &amp;&amp; !usedPlus[row + col] &amp;&amp; !usedMinus[row - col]) &#123;<br>                p.<span class="hljs-built_in">push_back</span>(col);<br>                used[col] = <span class="hljs-literal">true</span>;<br>                usedPlus[row + col] = <span class="hljs-literal">true</span>;<br>                usedMinus[row - col] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>);<br>                usedMinus[row - col] = <span class="hljs-literal">false</span>;<br>                usedPlus[row + col] = <span class="hljs-literal">false</span>;<br>                used[col] = <span class="hljs-literal">false</span>;<br>                p.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; p;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; usedPlus;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; usedMinus;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;grid = grid;<br>        m = grid.<span class="hljs-built_in">length</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>();<br>        visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !visited[i][j]) &#123;<br>                    ans++;<br>                    <span class="hljs-built_in">bfs</span>(i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy)</span> </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>        q.<span class="hljs-built_in">push</span>(&#123;sx, sy&#125;);<br>        visited[sx][sy] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;<br>            <span class="hljs-type">int</span> y = q.<span class="hljs-built_in">front</span>().second;<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-type">int</span> nx = x + dx[i];<br>                <span class="hljs-type">int</span> ny = y + dy[i];<br>                <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= m || ny &lt; <span class="hljs-number">0</span> || ny &gt;= n) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (grid[nx][ny] != <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (visited[nx][ny]) <span class="hljs-keyword">continue</span>;<br>                q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>                visited[nx][ny] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited;<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h4 id="基因突变问题"><a href="#基因突变问题" class="headerlink" title="基因突变问题"></a>基因突变问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        depth[start] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (string seq : bank) hasBank.<span class="hljs-built_in">insert</span>(seq);<br>        <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(end) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        queue&lt;string&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> gene[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            string s = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (s[i] != gene[j]) &#123;<br>                        string ns = s;<br>                        ns[i] = gene[j];<br>                        <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(ns) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span> (depth.<span class="hljs-built_in">find</span>(ns) != depth.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br><br>                        depth[ns] = depth[s] + <span class="hljs-number">1</span>;<br>                        q.<span class="hljs-built_in">push</span>(ns);<br>                        <span class="hljs-keyword">if</span> (ns == end)<br>                            <span class="hljs-keyword">return</span> depth[ns];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;string&gt; hasBank;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; depth;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a><strong>矩阵中的最长递增路径</strong></h4><p>matrix &#x3D; [<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]</p>
<p><strong>最长路径计算</strong>：通过 BFS 遍历所有节点，记录每个节点的最长递增路径长度，最终获取最大值作为结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        m = matrix.<span class="hljs-built_in">size</span>();<br>        n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m * n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                    <span class="hljs-type">int</span> ni = i + dx[k];<br>                    <span class="hljs-type">int</span> nj = j + dy[k];<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(ni, nj) &amp;&amp; matrix[ni][nj] &gt; matrix[i][j]) &#123;<br>                        <span class="hljs-built_in">addEdge</span>(<span class="hljs-built_in">num</span>(i, j), <span class="hljs-built_in">num</span>(ni, nj));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(i);<br>                dist[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                deg[y]--;<br>                dist[y] = <span class="hljs-built_in">max</span>(dist[y], dist[x] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (deg[y] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * n; i++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, dist[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m, n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;<br>    vector&lt;<span class="hljs-type">int</span>&gt; deg;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dist;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>], dy[<span class="hljs-number">4</span>];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        deg[v]++;<br>        to[u].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i * n + j;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<p>我们就知道了，在一张有效无环图上，不管是球最长啊。统计什么别的信息，只要这个信息需要对所有的哎入编做统计，比如取max，下求和等等，我们就可以使用。图排序来进行这样一个信息统计。</p>
<p>另一种方法：dfs记忆化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;matrix = matrix;<br>        m = matrix.<span class="hljs-built_in">size</span>();<br>        n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        dist = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// default value: 0 表示还没计算过</span><br><br>        dx = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        dy = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(i, j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dist[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dist[x][y]; <span class="hljs-comment">// 如果已经计算过，则返回</span><br>        dist[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化当前路径长度</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>            <span class="hljs-type">int</span> nx = x + dx[k];<br>            <span class="hljs-type">int</span> ny = y + dy[k];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(nx, ny) &amp;&amp; matrix[nx][ny] &gt; matrix[x][y]) &#123;<br>                dist[x][y] = <span class="hljs-built_in">max</span>(dist[x][y], <span class="hljs-built_in">dfs</span>(nx, ny) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist[x][y];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix;<br>    <span class="hljs-type">int</span> m, n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dx, dy;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dist;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h3 id="二进制枚举-填空题"><a href="#二进制枚举-填空题" class="headerlink" title="二进制枚举(填空题)"></a>二进制枚举(填空题)</h3><hr>
<h2 id="十八-贪心"><a href="#十八-贪心" class="headerlink" title="十八. 贪心"></a>十八. 贪心</h2><p>1)最自然智慧的算法<br>2)用一种局部最功利的标准，总是做出在当前看来是最好的选择<br>3)难点在于证明局部最功利的标准可以得到全局最优解<br>4)对于贪心算法的学习主要以增加阅历和经验为主</p>
<p>只要举出一个错误解就是无效的，我们每个人都会对局部定义一个比较好的状况，然后我们想一步一步按照我们的想法执行，那么你每一步定的那个策略，它就属属于你的贪心策略。他能够推出最终的最优解，那贪心策略就是有效的，他是贪不出来他那最最终策略就是无效的，</p>
<p>但是证明是不可能证明的，要用对数器，写一个暴力解比对贪心策略,也不用太研究，就记住以下例题就行</p>
<h3 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h3><h4 id="会议室"><a href="#会议室" class="headerlink" title="会议室"></a>会议室</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//贪心策略是先完成结束时间早的</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Program</span> &#123;</span><br>    <span class="hljs-type">int</span> start, end;<br>&#125;;<br><br><span class="hljs-comment">// 自定义排序规则，按照会议的结束时间升序排序</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(Program&amp; a,Program&amp; b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a.end &lt; b.end;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bestArrange2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Program&gt;&amp; programs)</span> &#123;<br>    sort(programs.begin(), programs.end(), cmp);<br>    <span class="hljs-type">int</span> timeLine = <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p : programs) &#123;<br>        <span class="hljs-keyword">if</span> (timeLine &lt;= p.start) &#123;<br>            result++;<br>            timeLine = p.end;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h4><p>假设你是一位很慷慨的家长，想要给孩子们一些小饼干。但是，每个孩子最多只能得到一块饼干。</p>
<ul>
<li>每个孩子都有一个胃口值 <code>g[i]</code>，代表满足这个孩子所需的饼干大小。</li>
<li>每块饼干的大小用 <code>s[j]</code> 表示。</li>
<li>只有当饼干的大小 <code>s[j] &gt;= g[i]</code> 时，这块饼干才能满足孩子的胃口。</li>
</ul>
<p><strong>示例 1</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>g = [1, 2, 3]</code>, <code>s = [1, 1]</code></li>
<li><strong>输出</strong>：<code>1</code></li>
<li><strong>解释</strong>：你有 3 个孩子，胃口值分别是 1、2、3，有 2 块饼干，大小都是 1。只能满足胃口值为 1 的孩子，所以输出 1。</li>
</ul>
<p><strong>示例 2</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>g = [1, 2]</code>, <code>s = [1, 2, 3]</code></li>
<li><strong>输出</strong>：<code>2</code></li>
<li><strong>解释</strong>：你有 2 个孩子，胃口值分别是 1、2，有 3 块饼干，大小分别是 1、2、3。可以满足所有孩子的需求，所以输出 2。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贪心策略是小饼干先喂饱小胃口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>; <br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对孩子的胃口值排序</span><br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对饼干的大小排序</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 饼干索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> child : g) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] &lt; child) j++; <span class="hljs-comment">// 找到满足当前孩子胃口的饼干</span><br>            <span class="hljs-keyword">if</span> (j &lt; s.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 如果找到满足条件的饼干</span><br>                ans++; <span class="hljs-comment">// 满足一个孩子</span><br>                j++; <span class="hljs-comment">// 使用一块饼干</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*贪心算法成立的条件：</span><br><span class="hljs-comment">问题类型：本题属于资源分配问题，与零钱找零问题类似，目标是尽可能满足需求。贪心算法在这种情况下有效，因为我们希望通过合理分配资源来满足尽可能多的孩子。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">条件满足：在本题中，每个孩子只能得到一块饼干，并且不同饼干大小是可以互相满足的（一个大饼干既可以满足小胃口的孩子，也可以满足大胃口的孩子）。因此，通过贪心算法优先满足小胃口的孩子，就能将剩余的大饼干留给更需要的大胃口孩子，提升满足总人数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">面值分析（在本题中的对应）：</span><br><span class="hljs-comment">胃口大小与饼干大小分析：</span><br><span class="hljs-comment">孩子的胃口值数组 g 和饼干大小数组 s 都按从小到大的顺序排序。</span><br><span class="hljs-comment">如果能够用一个较小的饼干满足小胃口的孩子，那么这块饼干必然也能满足所有比该孩子胃口更小的孩子。因此，优先使用小饼干满足小胃口的孩子可以最大化满足需求，并留出更多大的饼干给大胃口的孩子。</span><br><span class="hljs-comment">决策包容性：</span><br><span class="hljs-comment">包容性分析：</span><br><span class="hljs-comment">在选择分配饼干时，优先选择满足小胃口的孩子，确保我们把最小的饼干分配给最适合的孩子。这样即使后续需求更大，我们仍然保有较大饼干以满足较高的需求。</span><br><span class="hljs-comment">这种选择包含了未来的可能性（即更大胃口的孩子仍能得到较大的饼干），确保资源利用最大化，增加整体满足的可能性。</span><br><span class="hljs-comment">贪心策略：</span><br><span class="hljs-comment">贪心策略：在分配时，优先分配小饼干给小胃口的孩子，尽可能满足最小需求，从而将较大的资源保留给更高需求的情况。这样可以提高整体满足率，实现题目目标。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><p>给定一个数组 <code>prices</code>，其中 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格。 你可以尽可能多次买卖股票（多次买入和卖出）。但在再次买入之前，必须先卖出股票。</p>
<p>目标是设计一个算法来计算能够获得的最大利润。</p>
<p>示例</p>
<p><strong>示例 1</strong>：</p>
<ul>
<li><p><strong>输入</strong>：<code>prices = [7, 1, 5, 3, 6, 4]</code></p>
</li>
<li><p><strong>输出</strong>：<code>7</code></p>
</li>
<li><p>解释：</p>
<ul>
<li>第 2 天买入（价格 &#x3D; 1），第 3 天卖出（价格 &#x3D; 5），利润 &#x3D; 5 - 1 &#x3D; 4。</li>
<li>第 4 天买入（价格 &#x3D; 3），第 5 天卖出（价格 &#x3D; 6），利润 &#x3D; 6 - 3 &#x3D; 3。</li>
<li>总利润 &#x3D; 4 + 3 &#x3D; 7。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//贪心策略是只要股票价格上涨，就进行一次卖出，把所有上涨的利润都累加起来，每次在价格上涨的前一天买入（隐藏）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.size(); i++)<br>            ans += max(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果今天价格比前一天高，累加差价</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><p>给定一个非负整数数组 <code>nums</code>，你最初位于数组的第一个位置。数组中的每个元素表示你在该位置可以跳跃的最大长度。目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例</p>
<p><strong>示例 1</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>nums = [2,3,1,1,4]</code>   </li>
<li><strong>输出</strong>：<code>2</code></li>
<li><strong>解释</strong>：跳到最后一个位置的最小跳跃数是 2。可以先从索引 0 跳到索引 1，再从索引 1 跳到最后一个位置。</li>
</ul>
<p><strong>示例 2</strong>：</p>
<ul>
<li><strong>输入</strong>：<code>nums = [2,3,0,1,4]</code></li>
<li><strong>输出</strong>：<code>2</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贪心策略，每一次只需要跳到再一次中最远的点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span> (now &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> right = now + nums[now]; <span class="hljs-comment">// 当前能跳到的最远范围</span><br>            <span class="hljs-keyword">if</span> (right &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果可以直接跳到最后，返回答案+1</span><br>            <br>            <span class="hljs-type">int</span> nextRight = right;<br>            <span class="hljs-type">int</span> next = now;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123; <span class="hljs-comment">// 在当前能跳到的范围内选择最优的下一跳位置</span><br>                <span class="hljs-keyword">if</span> (i + nums[i] &gt; nextRight) &#123; <span class="hljs-comment">// 更新最远跳跃位置</span><br>                    nextRight = i + nums[i];<br>                    next = i;<br>                &#125;<br>            &#125;<br>            now = next; <span class="hljs-comment">// 更新当前位置</span><br>            ans++; <span class="hljs-comment">// 增加跳跃次数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*贪心策略：</span><br><span class="hljs-comment">在每一步跳跃中，选择当前可以跳到的范围内的最远位置，从而确保每次跳跃后可以达到更大的范围。</span><br><span class="hljs-comment">假设位置 a 可以跳到 b1、b2、b3，而这些位置 b1、b2、b3 各自的最远跳跃位置为 c1、c2、c3。此时应该从 a 跳到能够达到最远位置的那个 b，这样可以保证未来的跳跃范围最大。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">决策包容性：</span><br><span class="hljs-comment">选择从 a 跳到“能跳得更远”的 b，因为这个选择确保未来的可达集合包含了其他跳跃选择的可达位置。这种策略即使不考虑未来的所有可能情况，也能保证当前选择的合理性。</span><br><span class="hljs-comment">简单来说，这种局部最优的决策能够带来全局最优的结果。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">贪心策略</span><br><span class="hljs-comment">贪心策略：本题的贪心策略是在每一步中选择能够跳到最远的范围。通过这种逐步扩展跳跃范围的方式，每一步都接近终点，从而减少总的跳跃次数，实现最小步数。</span><br></code></pre></td></tr></table></figure>



<h4 id="哈弗曼编码下的问题"><a href="#哈弗曼编码下的问题" class="headerlink" title="哈弗曼编码下的问题"></a>哈弗曼编码下的问题</h4><p>通过每次选择最小的元素合并，确保得到最优的结果</p>
<p>1.冶金问题</p>
<p>{10, 20, 30} 我们需要这些长度的金块，总长度为数组之和，每次切割会消费这个和，怎么切割会让输出最小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lessMoney</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq(arr.begin(), arr.end()); <span class="hljs-comment">// 小根堆</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        cur = pq.top(); pq.pop();   <span class="hljs-comment">//哈夫曼编码流程</span><br>        cur += pq.top(); pq.pop();<br>        sum += cur;<br>        pq.push(cur);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; lessMoney(arr) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 90</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.最小代价合并木棍问题</p>
<p>问题描述：<br>给定 <code>n</code> 根木棍，每次可以合并两根木棍，合并两根木棍的长度之和<strong>。最终我们要把所有木棍合并成一根，求</strong>最小的总合并代价</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minCostToMergeSticks</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; sticks)</span> &#123;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq(sticks.begin(), sticks.end()); <span class="hljs-comment">// 小根堆</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (pq.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> a = pq.top(); pq.pop();   <br>        <span class="hljs-type">int</span> b = pq.top(); pq.pop();<br>        <span class="hljs-type">int</span> cost = a + b;<br>        sum += cost;<br>        pq.push(cost);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; sticks = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; minCostToMergeSticks(sticks) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出 14</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="项目安排问题"><a href="#项目安排问题" class="headerlink" title="项目安排问题"></a>项目安排问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-type">int</span> K, <span class="hljs-type">int</span> W, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; Profits, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; Capital)</span> &#123;<br>    <span class="hljs-comment">// 创建一个小根堆（根据资本排序），minCostQ存储资本和对应的利润</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; minCostQ;<br>    <br>    <span class="hljs-comment">// 创建一个大根堆（根据利润排序），maxProfitQ存储利润和对应的资本</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; maxProfitQ;<br><br>    <span class="hljs-comment">// 将所有项目按照资本大小加入minCostQ</span><br>    <span class="hljs-comment">// pair的第一个元素是资本，第二个是利润</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Profits.size(); i++) &#123;<br>        minCostQ.push(&#123;Capital[i], Profits[i]&#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 做K次投资，每次选择利润最大化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;<br>        <span class="hljs-comment">// 将所有资本不超过当前W的项目加入到maxProfitQ</span><br>        <span class="hljs-comment">// 注意：minCostQ是按照资本从小到大排序的</span><br>        <span class="hljs-keyword">while</span> (!minCostQ.empty() &amp;&amp; minCostQ.top().first &lt;= W) &#123;<br>            <span class="hljs-comment">// 如果当前项目资本小于等于W，就将其加入最大利润堆</span><br>            maxProfitQ.push(minCostQ.top());<br>            minCostQ.pop(); <span class="hljs-comment">// 从minCostQ中移除已选择的项目</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果maxProfitQ为空，表示没有可以投资的项目，返回当前资本</span><br>        <span class="hljs-keyword">if</span> (maxProfitQ.empty()) &#123;<br>            <span class="hljs-keyword">return</span> W;<br>        &#125;<br><br>        <span class="hljs-comment">// 从maxProfitQ中取出利润最大的项目，更新当前资本W</span><br>        W += maxProfitQ.top().second;<br>        maxProfitQ.pop(); <span class="hljs-comment">// 移除已选择的项目</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> W; <span class="hljs-comment">// 返回经过K次投资后的最大资本</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; Profits = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;     <span class="hljs-comment">// 每个项目的利润</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; Capital = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;     <span class="hljs-comment">// 每个项目所需的资本</span><br>    <span class="hljs-type">int</span> K = <span class="hljs-number">2</span>;                           <span class="hljs-comment">// 最多可以进行2次投资</span><br>    <span class="hljs-type">int</span> W = <span class="hljs-number">0</span>;                           <span class="hljs-comment">// 初始资本为0</span><br><br>    <span class="hljs-comment">// 调用函数获取经过K次投资后的最大资本</span><br>    <span class="hljs-type">int</span> result = findMaximizedCapital(K, W, Profits, Capital);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Maximized Capital: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 输出最大资本</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<hr>
<h2 id="十九-动态规划"><a href="#十九-动态规划" class="headerlink" title="十九.动态规划"></a>十九.动态规划</h2><p>动态规划如果让我总结就一句话。如果你发现你有重复调用的过程，动态规划在算过一次之后，把答案记下来，下回再遇到重复过程直接调。</p>
<p><strong>动态规划定义</strong>：</p>
<ul>
<li>动态规划是一种对问题的状态空间进行分阶段的、按顺序、无重复的遍历的决策性遍历算法。蛮力搜索 —(同类子问题)—&gt;分治 —(最优子结构)—&gt;动态规划，这才是一条自然的解题</li>
</ul>
<p><strong>动态规划的三大关键性质</strong>：</p>
<ul>
<li><strong>重叠子问题</strong>：与递归和分治相似，动态规划要解决的子问题是重复出现的，适合用状态表示和记录。</li>
<li><strong>最优子结构</strong>：状态应对应一个最优化目标，并且各个子目标之间存在推导关系，使得整体目标可以通过各子目标的最优解得出。</li>
<li><strong>无后效性</strong>：问题的状态空间是一个无向无环图，可以按一定的顺序遍历解决。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li>动态规划一般采用递推方式实现，也可以通过递归或记忆化搜索的方式进行。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//宇宙机器人</span><br><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">opt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化：兑换金额为0时，不需要任何硬币</span><br><br><span class="hljs-comment">// 阶段（线性增长）：从1逐步增加到目标金额amount</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>    opt[i] = INF; <span class="hljs-comment">// 设置当前金额i的最少硬币数量为一个极大值（用INF表示），方便后续比较取最小值</span><br><br>    <span class="hljs-comment">// 决策（找到子问题）：遍历每个硬币面值，找到凑成当前金额的最优方案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<br>        <span class="hljs-keyword">if</span> (i - coins[j] &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 判断是否可以用当前硬币凑成当前金额</span><br>            <span class="hljs-comment">// 状态（具有最优子结构）：选择最小的硬币数量，确保当前金额的最优解</span><br>            opt[i] = Math.<span class="hljs-built_in">min</span>(opt[i], opt[i - coins[j]] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*无论是递推实现还是记忆化搜索(递归实现)这种定义状态+最优子结构+推导关系的解题方法其实就是 动态规划 算法</span><br><span class="hljs-comment">1.问题定义：</span><br><span class="hljs-comment">设 opt[i] 表示凑成金额 i 所需的最少硬币数量。确定“状态”的原则:寻找变化信息</span><br><span class="hljs-comment">2.状态转移方程：</span><br><span class="hljs-comment">对于每个金额 i，我们可以通过以下公式计算 opt[i]：opt[i] = min&#123;opt[i - coin] + 1&#125; 确定“最优子结构”的原则:寻找代表</span><br><span class="hljs-comment">3.边界：opt[0]=0,opt[i]=+∞(i&gt;0)</span><br><span class="hljs-comment">4.目标：opt[amount]</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>人力模拟 &#x2F; 暴力搜索</strong>：</p>
<ul>
<li>目的是通过手动模拟问题解决过程，理解如何遍历所有可能的状态和情况。</li>
<li>关注点：<strong>轮廓变化</strong>，分析状态如何从一个转移到另一个。我们是不是考虑在列表时候就是一个行一个列，它们往后推移,因此ij作为一个状态。lcs呢?选哪个数刚选的这个末尾是不是一个位置把这个轮廓描述一下表示字符串 <code>text1</code> 的每个字符位置，列表示字符串 <code>text2</code> 的每个字符位置。每个格子 <code>(i, j)</code> 的值代表 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的LCS长度。我们从左上角 <code>(0, 0)</code> 开始计算，逐步填充整个矩阵，一直到右下角的 <code>(n, m)</code>，最终结果即 <code>f[n][m]</code>，作为一个状态之后，把决策写好，这个题目就做完了。它整体的一个变化情况就可以得到我们这个题目的转移方程了。</li>
</ul>
<p><strong>定义状态</strong>：递增循环每一维啊,</p>
<ul>
<li>确定用什么变量或数组来表示问题中的不同状态。</li>
<li>关注点：<strong>代表</strong>（如代表某个位置、子问题的解等），以及状态之间的推导关系。</li>
</ul>
<p><strong>确定最优子结构</strong>：</p>
<ul>
<li>通过找到小问题的最优解来组成大问题的最优解。</li>
<li>关注点：手动模拟时做出的决策，观察这些决策如何影响最终解。</li>
</ul>
<p><strong>写出状态转移方程</strong>：</p>
<ul>
<li>根据之前定义的状态，写出如何从一个状态转移到另一个状态，形成递推关系。</li>
</ul>
<p><strong>确定边界、目标和实现</strong>：</p>
<ul>
<li>确定边界条件（如起点和结束点）和不合法的状态。</li>
<li>目标是找到最终要求的解，并根据状态转移方程使用循环或递归来实现求解。</li>
</ul>
<p>例外</p>
<p>动态规划打印方案的原则</p>
<ol>
<li><strong>记录转移路径</strong>：在动态规划的计算过程中，我们不仅要记录每个状态的最优值，还需要记录每个状态的转移来源</li>
<li><strong>递归输出</strong>：在填完整个动态规划表格后，从终点（如 <code>f[n][m]</code>）开始，沿着记录的路径递归地输出最优方案</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// f[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// pre[i] 用于记录最长子序列中 nums[i] 的前一个元素的索引</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; f[i] &lt; f[j] + <span class="hljs-number">1</span>) &#123;<br>                    f[i] = f[j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新 f[i] 为以 nums[i] 结尾的最长子序列的长度</span><br>                    pre[i] = j; <span class="hljs-comment">// 记录转移路径，将 nums[i] 的前驱设置为 nums[j]</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, end = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (f[i] &gt; ans) &#123;<br>                ans = f[i];<br>                end = i; <span class="hljs-comment">// 记录最长子序列的最后一个元素的索引</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">print</span>(nums, pre, end); <span class="hljs-comment">// 输出最长递增子序列</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 基本情况：如果没有前驱，直接返回</span><br>        <span class="hljs-built_in">print</span>(nums, pre, pre[i]); <span class="hljs-comment">// 递归回溯，输出子序列</span><br>        std::cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出当前元素</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>空间的优化<br>仔细观察状态转移方程，fi?,?,?]总是从f[i-1)?,?,?]转移过来，与更早的i-2,i-3,…. 没有关系如果把每个 fi]看作一行，那么转移只在相邻两行之间发生这种情况下可以使用滚动数组优化,实现中，先不优化，写完以后在每个f的第一维加个&amp;1(and1，即 mod 2)注意初始化复用的空间</p>
<p>零钱兑换”的最优子结构</p>
<p><strong>目标</strong>：找到兑换某个金额所需的最少硬币数量，形成最优的硬币兑换方案。</p>
<p><strong>状态定义</strong>：</p>
<ul>
<li>记录当前的“剩余金额”和“已用硬币枚数”。</li>
<li>新状态目标为“剩余金额”以及在硬币数量最少的前提下达到目标。</li>
</ul>
<p><strong>推导关系</strong>：</p>
<ul>
<li>递推公式为：opt(n) &#x3D; min(opt(n - 1), opt(n - 9), opt(n - 10)) + 1。</li>
<li>其中，<code>opt(n)</code>表示兑换金额为n元时所需的最少硬币数，<code>opt(n - 1)</code>, <code>opt(n - 9)</code>, <code>opt(n - 10)</code>分别代表使用1元、9元和10元硬币时的剩余情况。</li>
</ul>
<p><strong>最优子结构</strong>：</p>
<ul>
<li>通过递推关系，可以在状态、最优化目标、最优解之间建立递归关系，实现零钱兑换的最优解。就是因为我们提炼搜索结构，不要去盲目的根据所有方案。而是我们去只遍历，只要那一个最有解的哎，</li>
</ul>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p><strong>定义</strong>：</p>
<ul>
<li>f[i,j]f[i, j]f[i,j] 表示 <code>text1</code> 的前 iii 个字符和 <code>text2</code> 的前 jjj 个字符能组成的最长公共子序列（LCS）的长度。</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li>当 <code>text1[i]</code> 等于 <code>text2[j]</code> 时：f[i,j]&#x3D;f[i−1,j−1]+1f[i, j] &#x3D; f[i-1, j-1] + 1f[i,j]&#x3D;f[i−1,j−1]+1。</li>
<li>当 <code>text1[i]</code> 不等于 <code>text2[j]</code> 时：f[i,j]&#x3D;max⁡(f[i−1,j],f[i,j−1])f[i, j] &#x3D; \max(f[i-1, j], f[i, j-1])f[i,j]&#x3D;max(f[i−1,j],f[i,j−1])。</li>
</ul>
<p><strong>边界处理技巧</strong>：</p>
<ul>
<li>方法一：将 f[0,0]&#x3D;0f[0, 0] &#x3D; 0f[0,0]&#x3D;0 作为初始条件，然后在递推过程中用 <code>if</code> 语句进行判断。</li>
<li>方法二：假设字符串下标从 1 开始，设置 f[i,0]&#x3D;0f[i, 0] &#x3D; 0f[i,0]&#x3D;0 和 f[0,j]&#x3D;0f[0, j] &#x3D; 0f[0,j]&#x3D;0 作为边界条件。</li>
</ul>
<p><strong>目标</strong>：</p>
<ul>
<li>计算 f[n,m]f[n, m]f[n,m]，即 <code>text1</code> 和 <code>text2</code> 的最长公共子序列的长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(std::string text1, std::string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text<span class="hljs-number">1.l</span>ength();<br>        <span class="hljs-type">int</span> n = text<span class="hljs-number">2.l</span>ength();<br>        std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    f[i][j] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p><strong>问题定义</strong>：</p>
<ul>
<li>设 <code>f[i]</code> 表示前 <code>i</code> 个数构成的、以 <code>a[i]</code> 为结尾的最长上升子序列的长度。</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li>对于每个位置 <code>i</code>，我们遍历之前的所有位置 <code>j</code>（<code>j &lt; i</code>），如果 <code>a[j] &lt; a[i]</code>，则可以将 <code>a[i]</code> 接在以 <code>a[j]</code> 结尾的上升子序列后面，公式如下： f[i]&#x3D;max⁡(f[i],f[j]+1)f[i] &#x3D; \max(f[i], f[j] + 1)f[i]&#x3D;max(f[i],f[j]+1)</li>
<li>其中，<code>f[i]</code> 是以 <code>a[i]</code> 结尾的最长上升子序列长度。</li>
</ul>
<p><strong>边界</strong>：</p>
<ul>
<li>初始情况下，每个位置的最长上升子序列长度至少为1，即 <code>f[i] = 1</code>。(0 ≤i&lt;n)</li>
</ul>
<p><strong>目标</strong>：</p>
<ul>
<li>找到所有 <code>f[i]</code> 中的最大值，即： max⁡0≤i&lt;nf[i]\max_{0 \leq i &lt; n} f[i]0≤i&lt;nmaxf[i]</li>
<li>这个最大值即为整个序列的最长上升子序列长度。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 初始化每个位置的最长上升子序列长度为1</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>; <span class="hljs-comment">// 最长上升子序列的最终结果</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>                    f[i] = std::<span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新f[i]为以nums[i]为结尾的最长上升子序列长度</span><br>                &#125;<br>            &#125;<br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[i]); <span class="hljs-comment">// 更新全局最长长度</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h4 id="路径计数"><a href="#路径计数" class="headerlink" title="路径计数"></a>路径计数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> &#123;<br>    <span class="hljs-type">int</span> n = grid.size();            <span class="hljs-comment">// 行数</span><br>    <span class="hljs-type">int</span> m = grid[<span class="hljs-number">0</span>].size();          <span class="hljs-comment">// 列数</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; f(n, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 创建二维数组f并初始化为0</span><br><br>    <span class="hljs-comment">// 遍历每个网格位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-comment">// 如果当前格子有障碍物，路径数为0</span><br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                f[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// 起点 (0, 0) 路径数为1（前提是没有障碍物）</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 第一行时，只能从左边到达</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 第一列时，只能从上面到达</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>            <span class="hljs-comment">// 其他情况，路径数等于从上方和左侧位置到达的路径数之和</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回到达终点 (n-1, m-1) 的路径数</span><br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>状态定义</p>
<ul>
<li>设 <code>f[i]</code> 表示<strong>以 <code>i</code> 为结尾</strong>的最大子序和。</li>
</ul>
<p>状态转移方程</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span> + nums<span class="hljs-selector-attr">[i]</span>, nums<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<p>其中，<code>f[i - 1] + nums[i]</code> 表示将 <code>nums[i]</code> 加入到前面的子序列中，继续延续子序和；<code>nums[i]</code> 表示以当前元素 <code>nums[i]</code> 开始一个新的子序列。</p>
<p>边界条件</p>
<p><code>f[0] = nums[0]</code>，因为以第一个元素结尾的最大子序和就是第一个元素的值。</p>
<p>目标</p>
<p>计算 max(f[i])</p>
<p>关于“包含结尾”的原因</p>
<ul>
<li>在这个问题中，状态 <code>f[i]</code> 是以 <code>i</code> 为结尾的子序列的最大和，这样可以确保子序列是连续的。</li>
<li>通过 <code>f[i - 1]</code> 决定是否延续之前的序列，从而达到最大和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// f[i] 表示以 nums[i] 结尾的最大子序和</span><br>        f[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 边界条件：以第一个元素结尾的最大子序和就是它自身</span><br>        <span class="hljs-type">int</span> ans = f[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最大子序和为第一个元素</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            f[i] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>) + nums[i]; <span class="hljs-comment">// 状态转移方程</span><br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[i]); <span class="hljs-comment">// 更新全局最大子序和</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><p>问题定义</p>
<ul>
<li>给定一个数组，找到一个具有最大乘积的连续子数组，返回该最大乘积。</li>
</ul>
<p>状态定义</p>
<ul>
<li><p>设 <code>fmax[i]</code> 表示以 <code>i</code> 为结尾的子数组的<strong>乘积最大值</strong>。</p>
</li>
<li><p>设 <code>fmin[i]</code> 表示以 <code>i</code> 为结尾的子数组的<strong>乘积最小值</strong>。</p>
<p>使用 <code>fmax</code> 和 <code>fmin</code> 一起作为代表，以保证每一步都能满足最优子结构。原因是，当当前数 <code>nums[i]</code> 为负数时，乘以之前的最小值可能会变成最大值，所以需要同时维护最大和最小值。</p>
</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><code>fmax[i] = max(fmax[i - 1] * nums[i], fmin[i - 1] * nums[i], nums[i])</code></li>
<li><code>fmin[i] = min(fmax[i - 1] * nums[i], fmin[i - 1] * nums[i], nums[i])</code><ul>
<li><code>fmax[i]</code> 是当前最大乘积，取决于前一个最大乘积乘以当前数、前一个最小乘积乘以当前数，或者当前数本身。</li>
<li><code>fmin[i]</code> 是当前最小乘积，原因是负数可能会将最小值转化为最大值，因此也需要考虑。</li>
</ul>
</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>fmax[0] = nums[0]</code></li>
<li><code>fmin[0] = nums[0]</code></li>
</ul>
<p>目标</p>
<ul>
<li>求 <code>max(fmax[i])</code>，其中 <code>0 &lt;= i &lt; n</code>，即最大乘积。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fmax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">fmin</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// fmax[i] 和 fmin[i] 分别表示以 nums[i] 结尾的最大和最小乘积</span><br>        fmax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        fmin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最大乘积为第一个元素</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            fmax[i] = std::<span class="hljs-built_in">max</span>(&#123;fmax[i - <span class="hljs-number">1</span>] * nums[i], fmin[i - <span class="hljs-number">1</span>] * nums[i], nums[i]&#125;);<br>            fmin[i] = std::<span class="hljs-built_in">min</span>(&#123;fmax[i - <span class="hljs-number">1</span>] * nums[i], fmin[i - <span class="hljs-number">1</span>] * nums[i], nums[i]&#125;);<br>            ans = std::<span class="hljs-built_in">max</span>(ans, fmax[i]); <span class="hljs-comment">// 更新全局最大乘积</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h4><p>状态定义</p>
<p>设 f[i][j][k]表示在第 i 天结束时，持有 j 股股票（j为 0 或 1），已经完成了 k次交易的最大收益。</p>
<ul>
<li><code>i</code>：第几天。</li>
<li><code>j</code>：是否持有股票（0 表示不持有，1 表示持有）。</li>
<li><code>k</code>：已经完成的交易次数。</li>
</ul>
<p>决策转移</p>
<ul>
<li><p>买入</p>
<p>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span>, f<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k-1]</span> - prices<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>如果在第 <code>i</code> 天选择买入股票，那么前一天的状态应该是不持有股票且已完成 <code>k-1</code> 次交易，并减去当天的价格 <code>prices[i]</code>。</li>
</ul>
</li>
<li><p>卖出</p>
<p>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[k]</span>, f<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[k]</span> + prices<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>如果在第 <code>i</code> 天选择卖出股票，那么前一天的状态应该是持有股票且已完成 <code>k</code> 次交易，卖出后增加当天的价格 <code>prices[i]</code>。</li>
</ul>
</li>
<li><p>保持</p>
<p>：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[k]</span> = f<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span><span class="hljs-comment">[k]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>不进行买卖操作，保持前一天的状态。</li>
</ul>
</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>f[0][0][0] = 0</code> 表示在第 0 天，没有进行任何交易且不持有股票的情况下，利润为 0。</li>
<li>其余的边界值都初始化为负无穷，表示在开始时这些状态不合法或不可达。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> c, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 移动索引到1开始</span><br>        prices.<span class="hljs-built_in">insert</span>(prices.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 定义 f 数组并初始化为负无穷</span><br>        <span class="hljs-comment">// f[i][j][k] 表示第 i 天，持有 j (0 或 1) 股股票，已经交易了 k 次的最大收益</span><br>        std::vector&lt;std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">2</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c + <span class="hljs-number">1</span>, <span class="hljs-number">-1e9</span>)));<br>        <br>        <span class="hljs-comment">// 边界条件</span><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历所有状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= c; k++) &#123;<br>                    <span class="hljs-comment">// 决策：不操作</span><br>                    f[i][j][k] = std::<span class="hljs-built_in">max</span>(f[i][j][k], f[i - <span class="hljs-number">1</span>][j][k]);<br>                    <br>                    <span class="hljs-comment">// 决策：买入</span><br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                        f[i][<span class="hljs-number">1</span>][k] = std::<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">1</span>][k], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k - <span class="hljs-number">1</span>] - prices[i]);<br>                    &#125;<br>                    <br>                    <span class="hljs-comment">// 决策：卖出</span><br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;<br>                        f[i][<span class="hljs-number">0</span>][k] = std::<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>][k], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k] + prices[i]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到最大的收益</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= c; k++) &#123;<br>            ans = std::<span class="hljs-built_in">max</span>(ans, f[n][<span class="hljs-number">0</span>][k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><p>问题描述</p>
<ul>
<li>给定一排房子，每个房子都有一定的现金。如果两个相邻的房子都被盗，就会触发报警系统。求在不触发报警的情况下能够盗取的最大金额。</li>
</ul>
<p>状态定义</p>
<ul>
<li>设 f[i][j] 表示在第 i个房子时的最大收益：<ul>
<li><code>j = 0</code> 表示未盗窃第 <code>i</code> 个房子。</li>
<li><code>j = 1</code> 表示盗窃第 <code>i</code> 个房子。</li>
</ul>
</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><code>f[i][0] = max(f[i - 1][0], f[i - 1][1])</code>：如果第 <code>i</code> 个房子没有被盗窃，那么最大收益就是前一个房子的状态（不管前一个房子是否被盗）。</li>
<li><code>f[i][1] = f[i - 1][0] + nums[i]</code>：如果第 <code>i</code> 个房子被盗窃，那么前一个房子一定没有被盗窃。</li>
</ul>
<p>边界条件</p>
<ul>
<li><code>f[0][0] = 0</code>：第一个房子不偷的收益为 0。</li>
<li><code>f[0][1] = nums[0]</code>：第一个房子偷的收益为 <code>nums[0]</code>。</li>
</ul>
<p>目标</p>
<ul>
<li>计算 <code>max(f[n][0], f[n][1])</code>，其中 <code>n</code> 是房子的数量，这样可以得到在最后一个房子时的最大收益。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 为方便使用1基索引，我们在开头插入0</span><br>        nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 定义f数组，并初始化为负无穷大（表示不可达状态）</span><br>        std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1e9</span>));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界条件，第0天不偷的收益为0</span><br><br>        <span class="hljs-comment">// 动态规划填表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 不偷第i个房子</span><br>            f[i][<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// 偷第i个房子</span><br>            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最后一天不偷或偷的最大收益</span><br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(f[n][<span class="hljs-number">0</span>], f[n][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><p>给定两个字符串 <code>word1</code> 和 <code>word2</code>，计算将 <code>word1</code> 转换成 <code>word2</code> 所使用的最小操作数。可以对字符串执行以下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p>状态定义</p>
<p>设 <code>f[i][j]</code> 表示 <code>word1</code> 前 <code>i</code> 个字符和 <code>word2</code> 前 <code>j</code> 个字符之间的编辑距离（最小操作数）。</p>
<p>状态转移方程</p>
<ul>
<li><strong>插入操作</strong>：<code>f[i][j] = f[i][j - 1] + 1</code><ul>
<li>相当于在 <code>word1</code> 中第 <code>i</code> 个位置插入 <code>word2[j]</code>，所以 <code>j</code> 减 1 后计算剩余的编辑距离，再加上插入操作的1。</li>
</ul>
</li>
<li><strong>删除操作</strong>：<code>f[i][j] = f[i - 1][j] + 1</code><ul>
<li>相当于删除 <code>word1[i]</code>，因此 <code>i</code> 减 1 后计算剩余的编辑距离，再加上删除操作的1。</li>
</ul>
</li>
<li><strong>替换操作</strong>（或不变）：<code>f[i][j] = f[i - 1][j - 1] + eq</code>，其中 <code>eq = 0</code> 或 <code>1</code><ul>
<li>如果 <code>word1[i]</code> 与 <code>word2[j]</code> 相等，<code>eq = 0</code>；否则，<code>eq = 1</code>，因为需要一次替换操作。</li>
</ul>
</li>
</ul>
<p>初始条件</p>
<ul>
<li><code>f[i][0] = i</code>：将 <code>word1</code> 的前 <code>i</code> 个字符转化为一个空字符串需要 <code>i</code> 次删除操作。</li>
<li><code>f[0][j] = j</code>：将空字符串转化为 <code>word2</code> 的前 <code>j</code> 个字符需要 <code>j</code> 次插入操作。</li>
</ul>
<p>目标</p>
<p>最终目标是计算 <code>f[n][m]</code>，其中 <code>n</code> 和 <code>m</code> 分别是 <code>word1</code> 和 <code>word2</code> 的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word2)</span> &#123;<br>        <span class="hljs-type">int</span> n = word1.length();<br>        <span class="hljs-type">int</span> m = word2.length();<br>        <br>        <span class="hljs-comment">// 定义 f[i][j] 并初始化边界</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; f(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">1e9</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) f[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) f[<span class="hljs-number">0</span>][j] = j;<br><br>        <span class="hljs-comment">// 计算编辑距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-type">int</span> eq = (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>                f[i][j] = <span class="hljs-built_in">std</span>::min(&#123;f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 插入</span><br>                                    f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 删除</span><br>                                    f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + eq&#125;);  <span class="hljs-comment">// 替换或不变</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最终的编辑距离</span><br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0&#x2F;1 背包"></a><strong>0&#x2F;1 背包</strong></h3><p>给定 <code>N</code> 个物品，每个物品有一定的体积 <code>V[i]</code> 和价值 <code>W[i]</code>。还有一个容量为 <code>M</code> 的背包，要求在背包容量不超过 <code>M</code> 的前提下，选择一些物品放入背包，使物品的总价值最大。</p>
<p>模版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; V, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; W)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = V.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(M + <span class="hljs-number">1</span>, <span class="hljs-number">-1e9</span>)</span></span>; <span class="hljs-comment">// 初始化为负无穷</span><br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 没有物品且容量为0的初始状态</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 遍历每个物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = M; j &gt;= V[i]; --j) &#123; <span class="hljs-comment">// 倒序遍历容量，确保每个物品仅选择一次</span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - V[i]] + W[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 寻找容量为 M 时的最大价值</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= M; ++j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, f[j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><p>问题描述是：给定一个只包含正整数的非空数组，判断是否可以将数组分割成两个子集，使得两个子集的和相等。</p>
<p>这是一个典型的 0&#x2F;1 背包问题，问题可以转化为：是否可以从数组中选择一些数，使其和等于总和的一半。因为背包其实就是你看每个物品选不选?子集在一个核的限制下。选数的问题就跟背包一样，正好是选出来总体积为三-2这样的物品。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) sum += num;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= num; --j) &#123;<br>                f[j] = f[j] || f[j - num];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[target];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a><strong>完全背包问题</strong></h3><p>给定 NNN 种物品，其中第 iii 种物品的体积为 ViV_iVi，价值为 WiW_iWi，并且每种物品有无限个。现在有一个容量为 MMM 的背包，要求选择若干个物品放入背包中，使得物品的总体积不超过 MMM，并且物品的价值总和最大。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f(m + <span class="hljs-number">1</span>, <span class="hljs-number">-1000000000</span>); <span class="hljs-comment">// 初始化，容量为 m 的背包</span><br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;      <span class="hljs-comment">// 遍历每一种物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v[i]; j &lt;= m; j++) &#123; <span class="hljs-comment">// j 从 v[i] 到 m 顺序遍历</span><br>        f[j] = <span class="hljs-keyword">max</span>(f[j], f[j - v[i]] + w[i]); <span class="hljs-comment">// 更新当前容量 j 的最大值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>    ans = <span class="hljs-keyword">max</span>(ans, f[j]);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="零钱兑换-Ii"><a href="#零钱兑换-Ii" class="headerlink" title="零钱兑换 Ii"></a>零钱兑换 Ii</h4><p>给定一个整数数组 <code>coins</code> 表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。</p>
<p>编写一个函数来计算可以凑成总金额的硬币组合数，假设每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<ul>
<li>输入：<code>amount = 5, coins = [1, 2, 5]</code></li>
<li>输出：<code>4</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[amount + <span class="hljs-number">1</span>];<br>    Arrays.<span class="hljs-built_in">fill</span>(f, <span class="hljs-number">0</span>);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.length; i++) &#123; <span class="hljs-comment">// 遍历每种硬币</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="hljs-comment">// 遍历从 coins[i] 到 amount 的金额</span><br>            f[j] += f[j - coins[i]]; <span class="hljs-comment">// 更新方法数量</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[amount];<br>&#125;<br><br></code></pre></td></tr></table></figure>





<hr>
<h2 id="二十-字符串处理"><a href="#二十-字符串处理" class="headerlink" title="二十.字符串处理"></a>二十.字符串处理</h2><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br>ULL <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">string</span> s, p;   <span class="hljs-comment">// s是目标字符串，p是模式串</span><br><span class="hljs-comment">// s[]是模式串，p[]是模板串, n是s的长度，m是p的长度</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Trie字符串"><a href="#Trie字符串" class="headerlink" title="Trie字符串"></a>Trie字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h2 id="二十二-数学知识"><a href="#二十二-数学知识" class="headerlink" title="二十二.数学知识"></a>二十二.数学知识</h2><p>唯一分解定理</p>
<p>试除法判定质数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>试除法分解质因数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>朴素筛法求素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>        primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线性筛法求素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>试除法求所有约数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.push_back(i);<br>            <span class="hljs-keyword">if</span> (i != x / i) res.push_back(x / i);<br>        &#125;<br>    sort(res.begin(), res.end());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>约数个数和约数之和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">如果 N = p1^c1 * p2^c2 * ... *pk^ck<br>约数个数： (c1 + <span class="hljs-number">1</span>) * (c2 + <span class="hljs-number">1</span>) * ... * (ck + <span class="hljs-number">1</span>)<br>约数之和： (p1^<span class="hljs-number">0</span> + p1^<span class="hljs-number">1</span> + ... + p1^c1) * ... * (pk^<span class="hljs-number">0</span> + pk^<span class="hljs-number">1</span> + ... + pk^ck)<br><br><span class="hljs-type">int</span> gcd(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-keyword">return</span> b ? gcd(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>快速幂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">求 m^k mod p，时间复杂度 O(logk)。<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span><br>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>递归法求组合数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// c[a][b] 表示从a个苹果中选b个的方案数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ )<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>        <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;<br></code></pre></td></tr></table></figure>

<p>分解质因数法求组合数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c">当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：<br>    <span class="hljs-number">1.</span> 筛法求出范围内的所有质数<br>    <span class="hljs-number">2.</span> 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^<span class="hljs-number">2</span> + n / p^<span class="hljs-number">3</span> + ...<br>    <span class="hljs-number">3.</span> 用高精度乘法将所有质因子相乘<br><br><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// 存储所有质数</span><br><span class="hljs-type">int</span> sum[N];     <span class="hljs-comment">// 存储每个质数的次数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个数是否已被筛掉</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>      <span class="hljs-comment">// 线性筛法求素数</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span>       <span class="hljs-comment">// 求n！中的次数</span><br>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        res += n / p;<br>        n /= p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> b)</span>       <span class="hljs-comment">// 高精度乘低精度模板</span><br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); i ++ )<br>    &#123;<br>        t += a[i] * b;<br>        c.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (t)<br>    &#123;<br>        c.push_back(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br>get_primes(a);  <span class="hljs-comment">// 预处理范围内的所有质数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 求每个质因数的次数</span><br>&#123;<br>    <span class="hljs-type">int</span> p = primes[i];<br>    sum[i] = get(a, p) - get(b, p) - get(a - b, p);<br>&#125;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; res;<br>res.push_back(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++ )     <span class="hljs-comment">// 用高精度乘法将所有质因子相乘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; sum[i]; j ++ )<br>        res = mul(res, primes[i]);<br><br></code></pre></td></tr></table></figure>

<p>通过预处理逆元的方式求组合数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]<br>如果取模的数是质数，可以用费马小定理求逆元<br><span class="hljs-type">int</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>    <span class="hljs-comment">// 快速幂模板</span><br>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Lucas定理 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">若p是质数，则对于任意整数 <span class="hljs-number">1</span> &lt;= m &lt;= n，有：<br>    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)<br><br><span class="hljs-type">int</span> qmi(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k)       <span class="hljs-comment">// 快速幂模板</span><br>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        a = (LL)a * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>     <span class="hljs-comment">// 通过定理求组合数C(a, b)</span><br>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i ++, j -- )<br>    &#123;<br>        res = (LL)res * j % p;<br>        res = (LL)res * qmi(i, p - <span class="hljs-number">2</span>) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lucas</span><span class="hljs-params">(LL a, LL b)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> C(a, b);<br>    <span class="hljs-keyword">return</span> (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>求欧拉函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>筛法求欧拉函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">int</span> euler[N];           <span class="hljs-comment">// 存储每个数的欧拉函数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    euler[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>            euler[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> t = primes[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                euler[t] = euler[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            euler[t] = euler[i] * (primes[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>扩展欧几里得算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 求x, y，使得ax + by = gcd(a, b)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!b)<br>    &#123;<br>        x = <span class="hljs-number">1</span>; y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = exgcd(b, a % b, y, x);<br>    y -= (a/b) * x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>高斯消元</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a[N][N]是增广矩阵</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gauss</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> c, r;<br>    <span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; c &lt; n; c ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )   <span class="hljs-comment">// 找到绝对值最大的行</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; <span class="hljs-built_in">fabs</span>(a[t][c]))<br>                t = i;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[t][c]) &lt; eps) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      <span class="hljs-comment">// 将绝对值最大的行换到最顶端</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="hljs-comment">// 将当前上的首位变成1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++ )       <span class="hljs-comment">// 用当前行将下面所有的列消成0</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; eps)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= c; j -- )<br>                    a[i][j] -= a[r][j] * a[i][c];<br><br>        r ++ ;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r &lt; n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 无解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 有无穷多组解</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++ )<br>            a[i][n] -= a[i][j] * a[j][n];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 有唯一解</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二类斯特林</p>
<p>概率论与期望公式–均值期望</p>
<p>唯一分解定理</p>
<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><p>随机数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">rand() % (maxValue + <span class="hljs-number">1</span>)  <span class="hljs-comment">//生成一个 [0, maxValue] 之间的随机数</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 优化算法（待验证）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">optimizedAlgorithm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-comment">// 替换为你需要验证的算法</span><br>    <span class="hljs-comment">// 例如，选择排序、快速排序、归并排序等</span><br>&#125;<br><br><span class="hljs-comment">// 暴力算法（用作对比）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bruteForceAlgorithm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-comment">// 使用内置的排序算法作为暴力算法（如 std::sort）</span><br>    sort(arr.begin(), arr.end());<br>&#125;<br><br><span class="hljs-comment">// 生成随机数组</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">generateRandomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> maxValue)</span> &#123;<br>    <span class="hljs-type">int</span> size = rand() % (maxSize + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 数组大小在 [0, maxSize] 之间</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(size)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        arr[i] = rand() % (<span class="hljs-number">2</span> * maxValue + <span class="hljs-number">1</span>) - maxValue;  <span class="hljs-comment">// 数值范围 [-maxValue, maxValue]</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 复制数组</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">copyArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">return</span> arr;  <span class="hljs-comment">// 直接返回副本</span><br>&#125;<br><br><span class="hljs-comment">// 比较两个数组是否相等</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr1, <span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr1.size() != arr2.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr1.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 打印数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 设置随机数种子</span><br><br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">500000</span>;  <span class="hljs-comment">// 测试次数</span><br>    <span class="hljs-type">int</span> maxSize = <span class="hljs-number">100</span>;      <span class="hljs-comment">// 数组最大长度</span><br>    <span class="hljs-type">int</span> maxValue = <span class="hljs-number">100</span>;     <span class="hljs-comment">// 数值范围</span><br>    <span class="hljs-type">bool</span> succeed = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 多次测试</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr1 = generateRandomArray(maxSize, maxValue);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr2 = copyArray(arr1);<br><br>        <span class="hljs-comment">// 使用优化算法排序 arr1</span><br>        optimizedAlgorithm(arr1);<br>        <span class="hljs-comment">// 使用暴力算法排序 arr2</span><br>        bruteForceAlgorithm(arr2);<br><br>        <span class="hljs-comment">// 如果排序结果不一致，输出错误信息</span><br>        <span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;<br>            succeed = <span class="hljs-literal">false</span>;<br>            printArray(arr1);<br>            printArray(arr2);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (succeed) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Nice!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Fucking fucked!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试单个排序结果</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = generateRandomArray(maxSize, maxValue);<br>    printArray(arr);<br>    optimizedAlgorithm(arr);<br>    printArray(arr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<p>&#x2F;&#x2F;返回[0,1)的一个小数</p>
<p>&#x2F;&#x2F;任意的x,×属于[0,1)，[0，×)范围上的数出现概率由原来的×调整成x平方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">xToXPower2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(Math.random(), Math.random());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;三次方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">public <span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">xToXPower3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(Math.random(), Math.max(Math.random(), Math.random()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从1<del>5随机到1</del>7随机</p>
<p>​	由一个f1()条件函数1-5到目标函数f3()1-7</p>
<p>​	令有一个01条件发生器f2()，让12为0，让45为1，到3重复，那么f2_ f2_ f2_让每个二进制位上面全部都是f2就好了，就成为了数字的0-7,可是要1-7，那就当0-7时判断当0时重复做一般就成了1-7</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// f2() - 生成一个 0 或 1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> rand() % <span class="hljs-number">2</span>;  <span class="hljs-comment">// 返回 0 或 1</span><br>&#125;<br><br><span class="hljs-comment">// f3() - 使用 f2() 生成一个 0 到 7 的整数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> ans = (f2() &lt;&lt; <span class="hljs-number">2</span>) + (f2() &lt;&lt; <span class="hljs-number">1</span>) + f2();  <span class="hljs-comment">// 生成一个三位的二进制数</span><br>    <span class="hljs-keyword">return</span> ans;  <span class="hljs-comment">// 返回值是 0 到 7 之间</span><br>&#125;<br><br><span class="hljs-comment">// f1() - 生成一个 1 到 5 之间的随机数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> rand() % <span class="hljs-number">5</span> + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 生成 1 到 5 之间的随机数</span><br>&#125;<br><br><span class="hljs-comment">// 将 f1() 映射到 f3() 的 1 到 7</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mapTo1to7</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">int</span> f1_result = f1();  <span class="hljs-comment">// 1 到 5 之间的随机数</span><br>        <span class="hljs-type">int</span> f3_result = f3();  <span class="hljs-comment">// 0 到 7 之间的随机数</span><br>        <br>        <span class="hljs-comment">// 如果 f3() 结果在 0 到 4 之间，映射成功</span><br>        <span class="hljs-keyword">if</span> (f3_result &gt;= <span class="hljs-number">0</span> &amp;&amp; f3_result &lt; <span class="hljs-number">5</span>) &#123;<br>            result = f1_result + f3_result;<br>            <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">// 返回 1 到 7 之间的随机数</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 如果 f3() 的值大于 4，重新尝试</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    srand(time(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 设置随机数种子</span><br>    <span class="hljs-comment">// 测试</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Random number from 1 to 7: &quot;</span> &lt;&lt; mapTo1to7() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从a<del>b随机到c</del>d随机 </p>
<p>同理使用01条件器，把a-b分类，c-d变成0 -  d-c</p>
<p>利用这个思想大样本来调试程序</p>
<p>首先我补一个方法。你给我申请一个random数组。呃，这个长度最好随机，所以有个max长度。我然后值呢值我给你个范围range，这个是范围是吧？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">randomArray</span><span class="hljs-params">(<span class="hljs-type">int</span> len, <span class="hljs-type">int</span> range, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">arr</span><span class="hljs-params">(len)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        arr[i] = rand() % (range + <span class="hljs-number">1</span>); <span class="hljs-comment">// 生成 0 ~ range 的随机数</span><br>        <span class="hljs-keyword">if</span> (arr[i] &lt; k || arr[i] &gt; m) &#123;<br>            arr[i] = rand() % (m - k + <span class="hljs-number">1</span>) + k; <span class="hljs-comment">// 保证数组值在 [k, m] 范围内</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 假设 test 和 onlyKTimes 是两个函数，你需要实现它们</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-comment">// 假设的实现，具体逻辑根据实际需求填写</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">onlyKTimes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-comment">// 假设的实现，具体逻辑根据实际需求填写</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">100</span>;  <span class="hljs-comment">//数组长度最大100</span><br>    <span class="hljs-type">int</span> range = <span class="hljs-number">200</span>; <span class="hljs-comment">//数组的值在-200到200间</span><br>    <span class="hljs-type">int</span> testTime = <span class="hljs-number">100000</span>;  <span class="hljs-comment">//随机次数</span><br>    <span class="hljs-type">int</span> max = <span class="hljs-number">9</span>;<br><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>        <span class="hljs-type">int</span> a = rand() % max + <span class="hljs-number">1</span>; <span class="hljs-comment">// a 1 ~ 9</span><br>        <span class="hljs-type">int</span> b = rand() % max + <span class="hljs-number">1</span>; <span class="hljs-comment">// b 1 ~ 9</span><br>        <span class="hljs-type">int</span> k = min(a, b);<br>        <span class="hljs-type">int</span> m = max(a, b);<br>		<span class="hljs-comment">//命令k&lt;m</span><br>        <span class="hljs-keyword">if</span> (k == m) &#123;<br>            m++;<br>        &#125;<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; arr = randomArray(len, range, k, m);<br><br>        <span class="hljs-type">int</span> ans1 = test(arr, k, m);<br>        <span class="hljs-type">int</span> ans2 = onlyKTimes(arr, k, m);<br><br>        <span class="hljs-keyword">if</span> (ans1 != ans2) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;出错了！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>异或</p>
<p>异或运算的应用</p>
<p>1.应用一：不用任何额外变量交换两个数。要求ab所指向的位置必须在不同位置 </p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span>^b; b = <span class="hljs-keyword">a</span>^b; <span class="hljs-keyword">a</span> = <span class="hljs-keyword">a</span>^b;  <br></code></pre></td></tr></table></figure>



<p>2.应用二：在一个数组中找出现奇数次的一种数 [a,b,a,a,b]把所有值都跟eor异或一下，最终结果是出现奇数次的数</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">eor</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">eor</span> = <span class="hljs-keyword">eor</span>^a; <span class="hljs-keyword">eor</span> = <span class="hljs-keyword">eor</span>^b; <span class="hljs-keyword">eor</span> = <span class="hljs-keyword">eor</span>^a;  <br></code></pre></td></tr></table></figure>

<p>3.应用三：二进制int将最右侧的1提取出来组成新的int</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a&amp;(-a);<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法笔记</div>
      <div>https://theganlove.github.io/2024/09/09/算法笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>uert</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/" title="服务器部署">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">服务器部署</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/08/%E9%9A%90%E5%86%99/" title="隐写">
                        <span class="hidden-mobile">隐写</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
