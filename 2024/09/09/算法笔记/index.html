

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="uert">
  <meta name="keywords" content="">
  
    <meta name="description" content="本笔记以c++为主，其他语言也有相关代码 c++代码的基础内容头文件 1.基础数据结构和算法 #include &lt;iostream&gt;：用于输入输出流，如 std::cin 和 std::cout。 #include &lt;vector&gt;：用于动态数组 std::vector。 #include &lt;string&gt;：用于 std::string 字符串操作。 #incl">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://theganlove.github.io/2024/09/09/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本笔记以c++为主，其他语言也有相关代码 c++代码的基础内容头文件 1.基础数据结构和算法 #include &lt;iostream&gt;：用于输入输出流，如 std::cin 和 std::cout。 #include &lt;vector&gt;：用于动态数组 std::vector。 #include &lt;string&gt;：用于 std::string 字符串操作。 #incl">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-09T11:20:21.000Z">
<meta property="article:modified_time" content="2024-10-12T04:53:51.404Z">
<meta property="article:author" content="uert">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算法笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"theganlove.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>主题</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-09 19:20" pubdate>
          2024年9月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          250 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>本笔记以c++为主，其他语言也有相关代码</p>
<h1 id="c-代码的基础内容"><a href="#c-代码的基础内容" class="headerlink" title="c++代码的基础内容"></a>c++代码的基础内容</h1><p>头文件</p>
<h3 id="1-基础数据结构和算法"><a href="#1-基础数据结构和算法" class="headerlink" title="1.基础数据结构和算法"></a>1.<strong>基础数据结构和算法</strong></h3><ul>
<li><code>#include &lt;iostream&gt;</code>：用于输入输出流，如 <code>std::cin</code> 和 <code>std::cout</code>。</li>
<li><code>#include &lt;vector&gt;</code>：用于动态数组 <code>std::vector</code>。</li>
<li><code>#include &lt;string&gt;</code>：用于 <code>std::string</code> 字符串操作。</li>
<li><code>#include &lt;deque&gt;</code>：用于双端队列 <code>std::deque</code>。</li>
<li><code>#include &lt;stack&gt;</code>：用于栈数据结构 <code>std::stack</code>。</li>
<li><code>#include &lt;queue&gt;</code>：用于队列和优先队列 <code>std::queue</code>, <code>std::priority_queue</code>。</li>
<li><code>#include &lt;list&gt;</code>：用于双向链表 <code>std::list</code>。</li>
<li><code>#include &lt;set&gt;</code>：用于集合 <code>std::set</code>，有序唯一元素。</li>
<li><code>#include &lt;map&gt;</code>：用于键值对映射 <code>std::map</code>（有序映射）。</li>
<li><code>#include &lt;unordered_map&gt;</code>：用于哈希表 <code>std::unordered_map</code>（无序映射）。</li>
<li><code>#include &lt;unordered_set&gt;</code>：用于哈希表实现的集合 <code>std::unordered_set</code>。</li>
</ul>
<p><strong>算法与数学操作</strong></p>
<ul>
<li><code>#include &lt;algorithm&gt;</code>：用于常见的算法操作，如 <code>std::sort</code>, <code>std::min</code>, <code>std::max</code>, <code>std::reverse</code>。</li>
<li><code>#include &lt;numeric&gt;</code>：用于数字操作，如 <code>std::accumulate</code>（求和）和 <code>std::gcd</code>。</li>
<li><code>#include &lt;cmath&gt;</code>：用于常见的数学函数，如 <code>std::pow</code>, <code>std::sqrt</code>, <code>std::abs</code>，以及三角函数等。</li>
</ul>
<p><strong>迭代器和范围操作</strong></p>
<ul>
<li><code>#include &lt;iterator&gt;</code>：用于迭代器相关功能，如 <code>std::distance</code>, <code>std::advance</code>。</li>
<li><code>#include &lt;functional&gt;</code>：提供函数对象、绑定器和谓词函数支持。</li>
</ul>
<p><strong>时间处理</strong></p>
<ul>
<li><code>#include &lt;chrono&gt;</code>：用于时间测量和操作。</li>
<li><code>#include &lt;ctime&gt;</code>：用于传统C风格的时间处理。</li>
</ul>
<p><strong>随机数生成</strong></p>
<ul>
<li><code>#include &lt;random&gt;</code>：用于随机数生成，支持多种随机数分布和生成器。</li>
</ul>
<p><strong>输入输出流和文件处理</strong></p>
<ul>
<li><code>#include &lt;fstream&gt;</code>：用于文件流操作，如 <code>std::ifstream</code> 和 <code>std::ofstream</code> 读取和写入文件。</li>
<li><code>#include &lt;sstream&gt;</code>：用于字符串流操作，如 <code>std::istringstream</code>, <code>std::ostringstream</code>。</li>
</ul>
<p><strong>并发和线程处理</strong></p>
<ul>
<li><code>#include &lt;thread&gt;</code>：用于多线程支持。</li>
<li><code>#include &lt;mutex&gt;</code>：用于互斥锁机制。</li>
<li><code>#include &lt;future&gt;</code>：用于异步任务和期望值（futures）。</li>
</ul>
<p><strong>内存管理</strong></p>
<ul>
<li><code>#include &lt;memory&gt;</code>：用于智能指针，如 <code>std::shared_ptr</code>, <code>std::unique_ptr</code>, <code>std::weak_ptr</code>。</li>
</ul>
<h3 id="2-基础语法与数据类型"><a href="#2-基础语法与数据类型" class="headerlink" title="2. 基础语法与数据类型"></a>2. <strong>基础语法与数据类型</strong></h3><p>C++ 支持多种基本数据类型，常用的数据类型如下：</p>
<ul>
<li><p><code>int</code>: 整型，表示整数。</p>
</li>
<li><p><code>double</code>: 双精度浮点型，表示小数。</p>
</li>
<li><p><code>char</code>: 字符型，表示单个字符。</p>
</li>
<li><p><code>bool</code>: 布尔型，表示真 (<code>true</code>) 或假 (<code>false</code>)。</p>
</li>
<li><p><code>std::string</code>: 字符串类型，需要包含 <code>&lt;string&gt;</code> 头文件。</p>
</li>
<li><pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() &#123;
    int a = 10;  // 整型
    double b = 3.14;  // 浮点型
    char c = &#39;A&#39;;  // 字符型
    bool isTrue = true;  // 布尔型
    std::string name = &quot;Alice&quot;;  // 字符串类型
    
    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; a &lt;&lt; std::endl;
    return 0;
&#125;

<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- C++ 通过 `cin` 和 `cout` 来处理输入和输出。<br><br></code></pre></td></tr></table></figure>
#include &lt;iostream&gt;

int main() &#123;
    int age;
    std::cout &lt;&lt; &quot;Enter your age: &quot;;
    std::cin &gt;&gt; age;  // 输入年龄
    std::cout &lt;&lt; &quot;Your age is: &quot; &lt;&lt; age &lt;&lt; std::endl;  // 输出年龄
    return 0;
&#125;
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> <span class="hljs-code">`std::cin`</span>: 从用户输入读取数据。<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`&gt;&gt;`</span>: 输入运算符，用于从 <span class="hljs-code">`cin`</span> 接收数据<br><br><span class="hljs-bullet">-</span> ### 一、STL 的主要组成部分<br><br><span class="hljs-bullet">  1.</span> <span class="hljs-strong">**容器 (Containers)**</span>：用来存储和管理数据的集合。<br><span class="hljs-bullet">  2.</span> <span class="hljs-strong">**算法 (Algorithms)**</span>：用于对数据进行操作，如排序、查找、修改等。<br><span class="hljs-bullet">  3.</span> <span class="hljs-strong">**迭代器 (Iterators)**</span>：用于遍历容器中的元素，提供统一的访问接口。<br><br>  ### 二、容器 (Containers)<br><br>  STL 容器分为三类：<span class="hljs-strong">**顺序容器**</span>、<span class="hljs-strong">**关联容器**</span>和<span class="hljs-strong">**无序关联容器**</span>。<br><br>  #### 1. <span class="hljs-strong">**顺序容器**</span><br><br>  顺序容器存储数据时，元素按插入顺序排列，常见的顺序容器有：<br><br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**`vector`**</span>：动态数组，支持快速随机访问。<br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**`deque`**</span>：双端队列，支持两端快速插入和删除。<br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**`list`**</span>：双向链表，支持双向遍历，插入和删除操作效率较高。<br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**`array`**</span>：定长数组（C++11 引入），存储固定大小的数据。<br><span class="hljs-bullet">  -</span> <span class="hljs-strong">**`forward<span class="hljs-emphasis">_list`**：单向链表（C++11 引入），支持单向遍历。</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">  ##### `vector` 示例：</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br></code></pre></td></tr></table></figure>
  #include &lt;iostream&gt;
  #include &lt;vector&gt;
  
  int main() &#123;
      std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;
  
      // 添加元素
      vec.push_back(6);
  
      // 访问元素
      std::cout &lt;&lt; &quot;Element at index 2: &quot; &lt;&lt; vec[2] &lt;&lt; std::endl;
  
      // 遍历vector
      std::cout &lt;&lt; &quot;Elements in vector: &quot;;
      for (int num : vec) &#123;
          std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
      &#125;
      std::cout &lt;&lt; std::endl;
  
      // 删除最后一个元素
      vec.pop_back();
  
      return 0;
  &#125;
  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">#### 2. <span class="hljs-strong">**关联容器**</span></span><br><br>关联容器基于平衡二叉树（通常是红黑树）实现，元素按键值排序，支持快速查找、插入和删除操作。常见的关联容器有：<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**`set`**</span>：存储唯一的元素，自动按元素的键值排序。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**`map`**</span>：键值对（key-value）形式存储元素，按键排序。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**`multiset`**</span>：存储允许重复的元素，按键排序。<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**`multimap`**</span>：存储允许重复的键值对，按键排序。<br><br><span class="hljs-section">##### `map` 示例：</span><br><br></code></pre></td></tr></table></figure>
  #include &lt;iostream&gt;
  #include &lt;map&gt;
  
  int main() &#123;
      std::map&lt;std::string, int&gt; myMap;
  
      // 插入键值对
      myMap[&quot;apple&quot;] = 10;
      myMap[&quot;banana&quot;] = 20;
      myMap[&quot;orange&quot;] = 15;
  
      // 访问元素
      std::cout &lt;&lt; &quot;Price of apple: &quot; &lt;&lt; myMap[&quot;apple&quot;] &lt;&lt; std::endl;
  
      // 遍历map
      std::cout &lt;&lt; &quot;All fruits and their prices: &quot; &lt;&lt; std::endl;
      for (const auto&amp; pair : myMap) &#123;
          std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;
      &#125;
  
      return 0;
  &#125;
  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>#### <span class="hljs-number">3</span>. **无序关联容器**<br><br>无序关联容器是基于哈希表实现的容器，元素无序排列，但支持常数时间复杂度的查找、插入和删除操作。常见的无序关联容器有：<br><br>- **`unordered_set`**：无序集合，元素唯一。<br>- **`unordered_map`**：无序键值对，基于哈希表存储。<br>- **`unordered_multiset`**：无序多重集合，允许重复元素。<br>- **`unordered_multimap`**：无序多重键值对，允许重复键。<br><br>##### `unordered_map` 示例：<br><br></code></pre></td></tr></table></figure>
  #include &lt;iostream&gt;
  #include &lt;unordered_map&gt;
  
  int main() &#123;
      std::unordered_map&lt;std::string, int&gt; myMap;
  
      // 插入键值对
      myMap[&quot;apple&quot;] = 10;
      myMap[&quot;banana&quot;] = 20;
      myMap[&quot;orange&quot;] = 15;
  
      // 访问元素
      std::cout &lt;&lt; &quot;Price of banana: &quot; &lt;&lt; myMap[&quot;banana&quot;] &lt;&lt; std::endl;
  
      // 遍历unordered_map
      std::cout &lt;&lt; &quot;All fruits and their prices: &quot; &lt;&lt; std::endl;
      for (const auto&amp; pair : myMap) &#123;
          std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;
      &#125;
  
      return 0;
  &#125;
  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>### 三、算法 (Algorithms)<br><br>STL 提供了一系列的算法来操作容器，如排序、查找、修改等。这些算法定义在头文件 `&lt;algorithm&gt;` 中，并且可以通过迭代器访问容器的元素。<br><br>#### <span class="hljs-number">1</span>. **常用算法**<br><br>- **`sort`**：对容器进行排序。<br>- **`find`**：查找某个元素。<br>- **`binary_search`**：二分查找，要求容器是有序的。<br>- **`reverse`**：将容器中的元素反转。<br>- **`accumulate`**：计算容器中元素的累加和。<br>- **`count`**：统计容器中某个元素的出现次数。<br><br>##### `sort` 和 `find` 示例：<br><br></code></pre></td></tr></table></figure>
  #include &lt;iostream&gt;
  #include &lt;vector&gt;
  #include &lt;algorithm&gt;
  
  int main() &#123;
      std::vector&lt;int&gt; vec = &#123;4, 2, 5, 1, 3&#125;;
  
      // 对 vector 进行排序
      std::sort(vec.begin(), vec.end());
  
      std::cout &lt;&lt; &quot;Sorted vector: &quot;;
      for (int num : vec) &#123;
          std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
      &#125;
      std::cout &lt;&lt; std::endl;
  
      // 查找元素
      auto it = std::find(vec.begin(), vec.end(), 3);
      if (it != vec.end()) &#123;
          std::cout &lt;&lt; &quot;Element 3 found at index: &quot; &lt;&lt; it - vec.begin() &lt;&lt; std::endl;
      &#125; else &#123;
          std::cout &lt;&lt; &quot;Element 3 not found&quot; &lt;&lt; std::endl;
      &#125;
  
      return 0;
  &#125;
  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### <span class="hljs-number">2.</span> **自定义比较函数**<br><br>算法 `sort` 可以接受一个自定义的比较函数，以实现特定的排序规则。<br><br></code></pre></td></tr></table></figure>
  #include &lt;iostream&gt;
  #include &lt;vector&gt;
  #include &lt;algorithm&gt;
  
  // 自定义比较函数，降序排序
  bool compare(int a, int b) &#123;
      return a &gt; b;
  &#125;
  
  int main() &#123;
      std::vector&lt;int&gt; vec = &#123;4, 2, 5, 1, 3&#125;;
  
      // 使用自定义的比较函数进行排序
      std::sort(vec.begin(), vec.end(), compare);
  
      std::cout &lt;&lt; &quot;Sorted vector in descending order: &quot;;
      for (int num : vec) &#123;
          std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
      &#125;
      std::cout &lt;&lt; std::endl;
  
      return 0;
  &#125;
  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>### 四、迭代器 (Iterators)<br><br>迭代器提供了一种统一的方式来遍历 STL 容器。常见的迭代器类型有：<br><br>- **`begin()` 和 `end()`**：返回指向容器第一个元素和尾后元素的迭代器。<br>- **`rbegin()` 和 `rend()`**：返回逆序迭代器，分别指向最后一个元素和第一个元素之前的位置。<br>- **`cbegin()` 和 `cend()`**：返回常量迭代器，不能用于修改元素。<br><br>迭代器可以通过 `*it` 解引用访问元素，通过 `++it` 或 `--it` 移动到下一个或上一个元素。<br><br>##### 迭代器示例：<br><br></code></pre></td></tr></table></figure>
  #include &lt;iostream&gt;
  #include &lt;vector&gt;
  
  int main() &#123;
      std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;
  
      // 使用普通迭代器遍历
      std::cout &lt;&lt; &quot;Elements using iterator: &quot;;
      for (auto it = vec.begin(); it != vec.end(); ++it) &#123;
          std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
      &#125;
      std::cout &lt;&lt; std::endl;
  
      // 使用常量迭代器遍历
      std::cout &lt;&lt; &quot;Elements using const_iterator: &quot;;
      for (auto it = vec.cbegin(); it != vec.cend(); ++it) &#123;
          std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
      &#125;
      std::cout &lt;&lt; std::endl;
  
      // 使用逆序迭代器遍历
      std::cout &lt;&lt; &quot;Elements using reverse_iterator: &quot;;
      for (auto it = vec.rbegin(); it != vec.rend(); ++it) &#123;
          std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
      &#125;
      std::cout &lt;&lt; std::endl;
  
      return 0
  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>`std::pair` 是 C++ 标准模板库（STL）中的一种实用数据结构，它用于存储一对值（通常是两个相关的值），并且这两个值可以是不同类型。`pair` 通常用于返回多个值、存储键值对等情况。<br><br><span class="hljs-number">1</span>. **`pair` 的基本使用**<br><br>`pair` 的定义在 `&lt;utility&gt;` 头文件中，通常用 `std::make_pair` 函数来创建一个 `pair`，也可以直接使用构造函数。<br><br>示例代码：<br><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>#include <iostream><br>#include <utility>  &#x2F;&#x2F; 引入pair所需的头文件</p>
<p>int main() {<br>    &#x2F;&#x2F; 使用 make_pair 函数创建一个 pair<br>    std::pair&lt;std::string, int&gt; student &#x3D; std::make_pair(“Alice”, 23);</p>
<pre><code class="hljs">// 访问 pair 中的元素
std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; student.first &lt;&lt; &quot;, Age: &quot; &lt;&lt; student.second &lt;&lt; std::endl;

// 也可以直接使用构造函数初始化 pair
std::pair&lt;int, double&gt; score(1, 98.5);
std::cout &lt;&lt; &quot;Rank: &quot; &lt;&lt; score.first &lt;&lt; &quot;, Score: &quot; &lt;&lt; score.second &lt;&lt; std::endl;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-number">2</span>. **`pair` 的成员**<br><br><span class="hljs-title">- `first`:</span> 表示 `pair` 中的第一个元素。<br><span class="hljs-title">- `second`:</span> 表示 `pair` 中的第二个元素。<br><br>可以通过 `pair.first` 和 `pair.second` 分别访问两个值。<br><br>示例：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <utility></p>
<p>int main() {<br>    std::pair&lt;int, char&gt; p(10, ‘A’);  &#x2F;&#x2F; 初始化pair，第一个元素是int，第二个是char</p>
<pre><code class="hljs">std::cout &lt;&lt; &quot;First: &quot; &lt;&lt; p.first &lt;&lt; std::endl;  // 输出10
std::cout &lt;&lt; &quot;Second: &quot; &lt;&lt; p.second &lt;&lt; std::endl;  // 输出&#39;A&#39;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-number">3</span>. **与容器结合使用**<br><br>`pair` 在 STL 容器中非常常用，特别是在关联容器（如 `map` 和 `set`）中，`pair` 用于表示键值对。在 `map` 中，键值对的每个元素实际上是一个 `pair`，其中 `first` 是键，`second` 是值。<br><br>在 `map` 中使用 `pair`：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <map><br>#include <string></p>
<p>int main() {<br>    &#x2F;&#x2F; 创建一个 map 来存储学生姓名和分数<br>    std::map&lt;std::string, int&gt; studentScores;</p>
<pre><code class="hljs">// 插入键值对，使用 make_pair 函数
studentScores.insert(std::make_pair(&quot;Alice&quot;, 90));
studentScores.insert(std::make_pair(&quot;Bob&quot;, 85));

// 访问 map 中的元素
for (const auto&amp; entry : studentScores) &#123;
    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; entry.first &lt;&lt; &quot;, Score: &quot; &lt;&lt; entry.second &lt;&lt; std::endl;
&#125;

// 也可以通过 [] 操作符直接访问键值对
studentScores[&quot;Charlie&quot;] = 88;
std::cout &lt;&lt; &quot;Charlie&#39;s Score: &quot; &lt;&lt; studentScores[&quot;Charlie&quot;] &lt;&lt; std::endl;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-number">4</span>. **比较 `pair`**<br><br>`pair` 支持比较操作（如 `==`、`!=`、`&lt;`、`&gt;` 等）。比较规则是先比较 `first` 元素，如果 `first` 相等，则比较 `second` 元素。<br><br>示例：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <utility></p>
<p>int main() {<br>    std::pair&lt;int, int&gt; p1(10, 20);<br>    std::pair&lt;int, int&gt; p2(10, 30);</p>
<pre><code class="hljs">if (p1 &lt; p2) &#123;
    std::cout &lt;&lt; &quot;p1 is less than p2&quot; &lt;&lt; std::endl;  // 比较的是 first，若相等，则比较 second
&#125;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>在这个例子中，`p1` 和 `p2` 的 `first` 部分相同，比较结果取决于 `second` 部分。<br><br><span class="hljs-number">5</span>. **`pair` 的常见用法**<br><br>- **作为函数的返回值**：当你需要从函数中返回多个值时，`pair` 可以作为方便的结构体来返回两个值，而不需要创建专门的结构体。<br><br></code></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <utility></p>
<p>  std::pair&lt;int, int&gt; getMinMax(int a, int b) {<br>      if (a &lt; b) {<br>          return std::make_pair(a, b);<br>      } else {<br>          return std::make_pair(b, a);<br>      }<br>  }</p>
<p>  int main() {<br>      auto result &#x3D; getMinMax(5, 10);<br>      std::cout &lt;&lt; “Min: “ &lt;&lt; result.first &lt;&lt; “, Max: “ &lt;&lt; result.second &lt;&lt; std::endl;</p>
<pre><code class="hljs">  return 0;
</code></pre>
<p>  }<br>  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- **结合 STL 容器**：`pair` 常与 `map`、`set` 等关联容器结合使用，表示键值对。通过 `pair` 可以很方便地插入和操作这些关联容器中的元素。<br><br>- **返回复杂数据**：例如，计算函数的结果和状态时，可以用 `pair` 来表示结果和状态值。<br><br><span class="hljs-number">6</span>. **`tuple` 作为扩展**<br><br>`pair` 只能存储两个相关联的值。如果你需要存储更多的值，可以使用 C++<span class="hljs-number">11</span> 引入的 `tuple`，它是 `pair` 的扩展版，可以存储任意多个元素。<br><br>示例：<br><br></code></pre></td></tr></table></figure><br>#include <iostream><br>#include <tuple></p>
<p>int main() {<br>    std::tuple&lt;int, std::string, double&gt; t(1, “Alice”, 90.5);</p>
<pre><code class="hljs">// 访问 tuple 中的元素
std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Score: &quot; &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; std::endl;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>`tuple` 可以通过 `std::get&lt;index&gt;` 来访问每个元素，并且可以存储任意数量和类型的元素。<br><br>**`set` 和 `unordered_set`**<br><br>- `set` 是有序集合，内部实现为红黑树，元素有序且唯一。<br>- `unordered_set` 是无序集合，基于哈希表实现，查找和插入的平均时间复杂度为 O(<span class="hljs-number">1</span>)。<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <set></p>
<p>int main() {<br>    std::set<int> s;</p>
<pre><code class="hljs">s.insert(3);
s.insert(1);
s.insert(2);

for (int num : s) &#123;
    std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;  // 输出 1 2 3，按顺序输出
&#125;
std::cout &lt;&lt; std::endl;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>**`map` 和 `unordered_map`**<br><br>- `map` 是有序映射，基于红黑树，键值对按键有序存储。<br>- `unordered_map` 是无序映射，基于哈希表，键值对无序存储，查找、插入和删除的平均时间复杂度为 O(<span class="hljs-number">1</span>)。<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <map></p>
<p>int main() {<br>    std::map&lt;std::string, int&gt; m;</p>
<pre><code class="hljs">m[&quot;apple&quot;] = 10;
m[&quot;banana&quot;] = 20;

for (const auto&amp; pair : m) &#123;
    std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;
&#125;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">5.</span> <span class="hljs-strong">**指针与引用**</span><br><br><span class="hljs-strong">**指针**</span><br><br>指针是存储内存地址的变量，通常在算法中用于动态内存分配或指向数组等复杂数据结构。<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream></p>
<p>int main() {<br>    int x &#x3D; 10;<br>    int* p &#x3D; &x;  &#x2F;&#x2F; 定义一个指针指向变量 x</p>
<pre><code class="hljs">std::cout &lt;&lt; &quot;Value of x: &quot; &lt;&lt; x &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Pointer p points to value: &quot; &lt;&lt; *p &lt;&lt; std::endl;  // 解引用指针

return 0;
</code></pre>
<p>}</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**引用**</span><br><br>引用是变量的别名，常用于函数参数传递，以避免不必要的拷贝操作。它比指针更安全，不能是空引用。<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream></p>
<p>void increment(int&amp; a) {<br>    a++;<br>}</p>
<p>int main() {<br>    int x &#x3D; 10;<br>    increment(x);  &#x2F;&#x2F; 引用传递</p>
<pre><code class="hljs">std::cout &lt;&lt; &quot;Value of x after increment: &quot; &lt;&lt; x &lt;&lt; std::endl;  // 输出 11
return 0;
</code></pre>
<p>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">3.</span>常见的高级数据结构<br><br>#### <span class="hljs-number">1.</span> **堆（Heap）**<br><br>堆是一种特殊的二叉树，可以用数组表示，通常用于实现优先队列。在 C++ 中，STL 提供了 `priority_queue` 实现最大堆和最小堆。<br><br>##### 最大堆的实现 (C++ 中的 `priority_queue`)：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <queue><br>#include <vector></p>
<p>int main() {<br>    std::priority_queue<int> maxHeap;  &#x2F;&#x2F; 默认是最大堆</p>
<pre><code class="hljs">maxHeap.push(10);
maxHeap.push(20);
maxHeap.push(15);

std::cout &lt;&lt; &quot;Max Heap top: &quot; &lt;&lt; maxHeap.top() &lt;&lt; std::endl;  // 输出20
maxHeap.pop();  // 删除堆顶元素

std::cout &lt;&lt; &quot;After pop, Max Heap top: &quot; &lt;&lt; maxHeap.top() &lt;&lt; std::endl;  // 输出15
return 0;
</code></pre>
<p>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>##### 最小堆的实现：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <queue><br>#include <vector><br>#include <functional></p>
<p>int main() {<br>    &#x2F;&#x2F; 使用greater<int>来实现最小堆<br>    std::priority_queue&lt;int, std::vector<int>, std::greater<int>&gt; minHeap;</p>
<pre><code class="hljs">minHeap.push(10);
minHeap.push(20);
minHeap.push(15);

std::cout &lt;&lt; &quot;Min Heap top: &quot; &lt;&lt; minHeap.top() &lt;&lt; std::endl;  // 输出10
minHeap.pop();  // 删除堆顶元素

std::cout &lt;&lt; &quot;After pop, Min Heap top: &quot; &lt;&lt; minHeap.top() &lt;&lt; std::endl;  // 输出15
return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>#### <span class="hljs-number">2</span>. **平衡二叉搜索树 (BST)**<br><br>C++ 提供了 `set` 和 `map`，它们基于红黑树 (Red-Black Tree) 实现，用于维护元素的有序性并实现高效的查找、插入和删除操作，时间复杂度均为 O(log n)。<br><br>`set` 示例：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <set></p>
<p>int main() {<br>    std::set<int> bst;  &#x2F;&#x2F; 底层是红黑树</p>
<pre><code class="hljs">bst.insert(10);
bst.insert(5);
bst.insert(20);

std::cout &lt;&lt; &quot;Set contains: &quot;;
for (int num : bst) &#123;
    std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;  // 输出 5 10 20
&#125;
std::cout &lt;&lt; std::endl;

if (bst.find(10) != bst.end()) &#123;
    std::cout &lt;&lt; &quot;Found 10 in the set&quot; &lt;&lt; std::endl;
&#125;

bst.erase(10);  // 删除元素
std::cout &lt;&lt; &quot;After erasing 10, Set contains: &quot;;
for (int num : bst) &#123;
    std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;  // 输出 5 20
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>#### <span class="hljs-number">3</span>. **哈希表（Hash Table）**<br><br>C++ 提供了 `unordered_set` 和 `unordered_map`，分别是基于哈希表实现的无序集合和映射。它们的查找、插入和删除的平均时间复杂度是 O(<span class="hljs-number">1</span>)。<br><br>`unordered_map` 示例：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <unordered_map></p>
<p>int main() {<br>    std::unordered_map&lt;std::string, int&gt; hashMap;</p>
<pre><code class="hljs">hashMap[&quot;apple&quot;] = 1;
hashMap[&quot;banana&quot;] = 2;
hashMap[&quot;orange&quot;] = 3;

std::cout &lt;&lt; &quot;apple: &quot; &lt;&lt; hashMap[&quot;apple&quot;] &lt;&lt; std::endl;

hashMap.erase(&quot;banana&quot;);  // 删除键为 &quot;banana&quot; 的键值对

// 遍历所有键值对
for (const auto&amp; pair : hashMap) &#123;
    std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;
&#125;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### <span class="hljs-number">4.</span> **并查集 (Union-Find)**<br><br>并查集是一种树型数据结构，用于处理不相交集合的合并与查询操作，通常用于图算法（如寻找连通分量）。<br><br>并查集实现：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <vector></p>
<p>class UnionFind {<br>public:<br>    UnionFind(int size) {<br>        parent.resize(size);<br>        rank.resize(size, 1);  &#x2F;&#x2F; 初始化秩为1<br>        for (int i &#x3D; 0; i &lt; size; ++i) {<br>            parent[i] &#x3D; i;  &#x2F;&#x2F; 初始化父节点为自己<br>        }<br>    }</p>
<pre><code class="hljs">int find(int p) &#123;
    if (parent[p] != p) &#123;
        parent[p] = find(parent[p]);  // 路径压缩
    &#125;
    return parent[p];
&#125;

void unionSet(int p, int q) &#123;
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP != rootQ) &#123;
        if (rank[rootP] &gt; rank[rootQ]) &#123;
            parent[rootQ] = rootP;
        &#125; else if (rank[rootP] &lt; rank[rootQ]) &#123;
            parent[rootP] = rootQ;
        &#125; else &#123;
            parent[rootQ] = rootP;
            rank[rootP] += 1;
        &#125;
    &#125;
&#125;
</code></pre>
<p>private:<br>    std::vector<int> parent;<br>    std::vector<int> rank;<br>};</p>
<p>int main() {<br>    UnionFind uf(10);</p>
<pre><code class="hljs">uf.unionSet(1, 2);
uf.unionSet(2, 3);

std::cout &lt;&lt; &quot;Find 1: &quot; &lt;&lt; uf.find(1) &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Find 3: &quot; &lt;&lt; uf.find(3) &lt;&lt; std::endl;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">4.</span>常见的高级算法<br><br>#### <span class="hljs-number">1.</span> **二分查找 (Binary Search)**<br><br>二分查找用于在有序数组中高效查找元素，时间复杂度为 O(log n)。<br><br>示例代码：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <vector><br>#include <algorithm></p>
<p>int binarySearch(const std::vector<int>&amp; nums, int target) {<br>    int left &#x3D; 0, right &#x3D; nums.size() - 1;<br>    while (left &lt;&#x3D; right) {<br>        int mid &#x3D; left + (right - left) &#x2F; 2;<br>        if (nums[mid] &#x3D;&#x3D; target) {<br>            return mid;<br>        } else if (nums[mid] &lt; target) {<br>            left &#x3D; mid + 1;<br>        } else {<br>            right &#x3D; mid - 1;<br>        }<br>    }<br>    return -1;  &#x2F;&#x2F; 没有找到<br>}</p>
<p>int main() {<br>    std::vector<int> nums &#x3D; {1, 3, 5, 7, 9, 11};<br>    int target &#x3D; 7;</p>
<pre><code class="hljs">int index = binarySearch(nums, target);
if (index != -1) &#123;
    std::cout &lt;&lt; &quot;Found at index: &quot; &lt;&lt; index &lt;&lt; std::endl;
&#125; else &#123;
    std::cout &lt;&lt; &quot;Not found&quot; &lt;&lt; std::endl;
&#125;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### <span class="hljs-number">2.</span> **Dijkstra 最短路径算法**<br><br>Dijkstra 算法用于找到加权图中从起点到其他节点的最短路径，时间复杂度为 O(E log V)，其中 E 是边数，V 是顶点数。<br><br>示例代码：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <vector><br>#include <queue><br>#include <limits></p>
<p>const int INF &#x3D; std::numeric_limits<int>::max();</p>
<p>void dijkstra(int start, const std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt;&amp; graph, std::vector<int>&amp; dist) {<br>    dist[start] &#x3D; 0;<br>    std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt;&gt;, std::greater&lt;&gt;&gt; pq;<br>    pq.push({0, start});</p>
<pre><code class="hljs">while (!pq.empty()) &#123;
    int u = pq.top().second;
    int d = pq.top().first;
    pq.pop();

    if (d &gt; dist[u]) continue;

    for (const auto&amp; edge : graph[u]) &#123;
        int v = edge.first;
        int weight = edge.second;
        if (dist[u] + weight &lt; dist[v]) &#123;
            dist[v] = dist[u] + weight;
            pq.push(&#123;dist[v], v&#125;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>int main() {<br>    int V &#x3D; 5;<br>    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; graph(V);</p>
<pre><code class="hljs">// 构建图 (u, v, weight)
graph[0].push_back(&#123;1, 10&#125;);
graph[0].push_back(&#123;4, 5&#125;);
graph[1].push_back(&#123;2, 1&#125;);
graph[1].push_back(&#123;4, 2&#125;);
graph[2].push_back(&#123;3, 4&#125;);
graph[3].push_back(&#123;2, 6&#125;);
graph[4].push_back(&#123;1, 3&#125;);
graph[4].push_back(&#123;2, 9&#125;);
graph[4].push_back(&#123;3, 2&#125;);

std::vector&lt;int&gt; dist(V, INF);
dijkstra(0, graph, dist);

for (int i = 0; i &lt; V; ++i) &#123;
    std::cout &lt;&lt; &quot;Distance from 0 to &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist[i] &lt;&lt; std::endl;
&#125;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>#### <span class="hljs-number">3</span>. **快速排序 (Quick Sort)**<br><br>快速排序是一种分治算法，时间复杂度为 <span class="hljs-built_in">O</span>(n log n)，最差情况下为 <span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)。<br><br>示例代码：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <vector></p>
<p>int partition(std::vector<int>&amp; arr, int low, int high) {<br>    int pivot &#x3D; arr[high];<br>    int i &#x3D; low - 1;<br>    for (int j &#x3D; low; j &lt; high; j++) {<br>        if (arr[j] &lt;&#x3D; pivot) {<br>            i++;<br>            std::swap(arr[i], arr[j]);<br>        }<br>    }<br>    std::swap(arr[i + 1], arr[high]);<br>    return i + 1;<br>}</p>
<p>void quickSort(std::vector<int>&amp; arr, int low, int high) {<br>    if (low &lt; high) {<br>        int pi &#x3D; partition(arr, low, high);<br>        quickSort(arr, low, pi - 1);<br>        quickSort(arr, pi + 1, high);<br>    }<br>}</p>
<p>int main() {<br>    std::vector<int> arr &#x3D; {10, 7, 8, 9, 1, 5};<br>    quickSort(arr, 0, arr.size() - 1);</p>
<pre><code class="hljs">std::cout &lt;&lt; &quot;Sorted array: &quot;;
for (int num : arr) &#123;
    std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
&#125;
std::cout &lt;&lt; std::endl;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>### <span class="hljs-number">5</span>.优化技巧<br><br>在算法竞赛中，为了编写简洁高效的代码，争取时间并减少输入输出的繁琐步骤，常见的简便操作可以帮助你在紧张的比赛环境中提高编写和执行代码的效率。以下是一些常见的简便操作和优化技巧：<br><br>#### <span class="hljs-number">1</span>. **快速输入输出**<br><br>在算法竞赛中，输入输出速度非常关键，尤其是对于大规模数据集。C++ 标准的 `cin` 和 `cout` 是比较方便的输入输出方式，但默认速度较慢，可以通过以下方式加速：<br><br>**加速 `cin` 和 `cout`**<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>using namespace std;</p>
<p>int main() {<br>    ios::sync_with_stdio(false);  &#x2F;&#x2F; 关闭同步功能<br>    cin.tie(0);  &#x2F;&#x2F; 取消输入输出的绑定</p>
<pre><code class="hljs">int n;
cin &gt;&gt; n;
cout &lt;&lt; &quot;Number: &quot; &lt;&lt; n &lt;&lt; &#39;\n&#39;;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> <span class="hljs-code">`ios::sync_with_stdio(false);`</span>：关闭 <span class="hljs-code">`cin`</span> 与 <span class="hljs-code">`scanf`</span>，<span class="hljs-code">`cout`</span> 与 <span class="hljs-code">`printf`</span> 的同步，显著提高输入输出速度。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`cin.tie(0);`</span>：取消 <span class="hljs-code">`cin`</span> 与 <span class="hljs-code">`cout`</span> 的绑定，防止每次输入时都刷新输出缓冲区，可以提高效率。<br><br><span class="hljs-section">#### 2.<span class="hljs-strong">**使用宏定义减少代码量**</span></span><br><br>宏可以用于减少输入输出、常用算法或者常用数据结构的代码量。虽然宏定义过多可能影响代码的可读性，但在竞赛中可以帮助你快速编写代码。<br><br>示例：<br><br></code></pre></td></tr></table></figure>
<p>#include <iostream><br>#define int long long  &#x2F;&#x2F; 定义long long，避免重复写<br>#define pb push_back   &#x2F;&#x2F; 定义push_back，缩短容器操作<br>#define FAST_IO ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);</p>
<p>using namespace std;</p>
<p>int32_t main() {<br>    FAST_IO  &#x2F;&#x2F; 使用宏快速加速I&#x2F;O<br>    vector<int> vec;<br>    vec.pb(10);  &#x2F;&#x2F; 使用宏减少代码长度<br>    vec.pb(20);</p>
<pre><code class="hljs">for (int i : vec) &#123;
    cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;
&#125;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>#### <span class="hljs-number">3.</span> **使用结构化绑定（C+<span class="hljs-number">+17</span>）**<br><br>结构化绑定可以使得处理数据更加简洁，尤其在处理 `pair` 或 `tuple` 时，避免使用 `first`、`second` 等显式字段。<br><br>示例：<br><br>```<span class="hljs-function">cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : vp) &#123;  <span class="hljs-comment">// 结构化绑定，简化代码</span><br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-使用-STL-简化操作"><a href="#4-使用-STL-简化操作" class="headerlink" title="4. 使用 STL 简化操作"></a>4. <strong>使用 STL 简化操作</strong></h4><p>C++ 标准模板库（STL）提供了丰富的容器和算法，可以大幅减少代码量和开发时间。在竞赛中常用的有：</p>
<p><strong><code>std::vector</code> 和 <code>std::pair</code></strong></p>
<ul>
<li><code>vector</code> 是动态数组，非常适合存储大规模数据。</li>
<li><code>pair</code> 用于存储两个相关联的值，常用于排序和存储坐标、键值对等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;&#125;;<br>    <br>    <span class="hljs-comment">// 使用sort对pair进行排序，按照first排序</span><br>    <span class="hljs-built_in">sort</span>(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : vp) &#123;<br>        cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>常用 STL 函数：<code>sort</code>、<code>max_element</code>、<code>min_element</code></strong></p>
<p>使用 STL 提供的算法库，如 <code>sort</code>、<code>max_element</code> 等，可以快速实现排序和最大最小值的查找，避免手动实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 查找最大值和最小值</span><br>    <span class="hljs-type">int</span> maxVal = *<span class="hljs-built_in">max_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> minVal = *<span class="hljs-built_in">min_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Max: &quot;</span> &lt;&lt; maxVal &lt;&lt; <span class="hljs-string">&quot;, Min: &quot;</span> &lt;&lt; minVal &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-适当使用inline-函数"><a href="#5-适当使用inline-函数" class="headerlink" title="5. 适当使用inline 函数"></a>5. <strong>适当使用<code>inline</code> 函数</strong></h4><p><code>inline</code> 函数可以减少函数调用的开销，尤其在竞赛中，当某些函数被频繁调用时，<code>inline</code> 关键字可以提升性能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">inline <span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    <span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-避免不必要的拷贝"><a href="#6-避免不必要的拷贝" class="headerlink" title="6. 避免不必要的拷贝"></a>6. <strong>避免不必要的拷贝</strong></h4><p>在处理较大数据时，尽量避免不必要的拷贝操作。可以使用引用传递或移动语义（C++11），提高效率。</p>
<p>引用传递示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;  <span class="hljs-comment">// 使用引用避免拷贝</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; data = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">printVector</span>(data);  <span class="hljs-comment">// 使用引用传递</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-使用-auto-减少冗长的类型声明"><a href="#7-使用-auto-减少冗长的类型声明" class="headerlink" title="7. 使用 auto 减少冗长的类型声明"></a>7. <strong>使用 <code>auto</code> 减少冗长的类型声明</strong></h4><p><code>auto</code> 关键字允许编译器自动推导变量类型，特别是在使用复杂的 STL 容器时，它可以显著减少代码的长度和复杂性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> vec = vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动推导类型</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : vec) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出 1 2 3</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8-提前规划代码结构"><a href="#8-提前规划代码结构" class="headerlink" title="8. 提前规划代码结构"></a>8. <strong>提前规划代码结构</strong></h4><p>为了应对竞赛中的多题目情境，提前写好一些常用的模板，比如快速输入输出模板、二分查找、DFS、BFS、动态规划等常用代码结构，在比赛时只需要专注于核心算法部分。</p>
<p>二分查找模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;  <span class="hljs-comment">// 找到目标</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未找到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; data = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">binarySearch</span>(data, target);<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Index of target: &quot;</span> &lt;&lt; index &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-预处理技巧"><a href="#9-预处理技巧" class="headerlink" title="9. 预处理技巧"></a>9. <strong>预处理技巧</strong></h4><p>有些算法问题中，可以通过预处理数据来加速查询或计算。例如在某些数学问题中，可以提前计算出所有可能的结果，避免重复计算。</p>
<p>预处理 <code>n!</code> 阶乘的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">1000</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">factorial</span><span class="hljs-params">(MAX_N + <span class="hljs-number">1</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">precomputeFactorials</span><span class="hljs-params">()</span> </span>&#123;<br>    factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= MAX_N; ++i) &#123;<br>        factorial[i] = factorial[i - <span class="hljs-number">1</span>] * i;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">precomputeFactorials</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;10! = &quot;</span> &lt;&lt; factorial[<span class="hljs-number">10</span>] &lt;&lt; endl;  <span class="hljs-comment">// 输出 10!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="10-使用编译器优化"><a href="#10-使用编译器优化" class="headerlink" title="10. 使用编译器优化"></a>10. <strong>使用编译器优化</strong></h4><p>在算法竞赛中，可以使用编译器优化选项，如 <code>-O2</code> 或 <code>-O3</code> 来提升程序运行效率。</p>
<p>编译时使用 <code>g++</code>：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-literal">-</span><span class="hljs-comment">O2</span> <span class="hljs-literal">-</span><span class="hljs-comment">std=c</span><span class="hljs-literal">++</span><span class="hljs-comment">17 solution</span><span class="hljs-string">.</span><span class="hljs-comment">cpp</span> <span class="hljs-literal">-</span><span class="hljs-comment">o solution</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>-O2</code>：启用一般优化，适合大部分竞赛情况。</li>
<li><code>-O3</code>：更激进的优化，但在某些极限条件下可能会导致代码的非预期行为。</li>
</ul>
<h4 id="11-记忆化搜索"><a href="#11-记忆化搜索" class="headerlink" title="11. 记忆化搜索"></a>11. <strong>记忆化搜索</strong></h4><p>记忆化搜索是动态规划的一种方式，结合了递归和缓存结果的技术，避免重复计算。它常用于解决带有重叠子问题的递归问题，比如递归求解斐波那契数列。</p>
<p>示例：记忆化斐波那契数列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">memo</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">// 初始化一个数组来存储已经计算过的结果</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">if</span> (memo[n] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> memo[n];  <span class="hljs-comment">// 如果已经计算过，直接返回缓存的结果</span><br><br>    memo[n] = <span class="hljs-built_in">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fibonacci</span>(n - <span class="hljs-number">2</span>);  <span class="hljs-comment">// 递归计算并缓存结果</span><br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Fibonacci of &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">fibonacci</span>(n) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优点</strong>：大大减少了重复计算，尤其是当递归深度较大时，记忆化可以有效提升算法效率。</p>
<hr>
<h4 id="12-位操作优化"><a href="#12-位操作优化" class="headerlink" title="12. 位操作优化"></a>12. <strong>位操作优化</strong></h4><p>位操作是非常高效的操作，它能让很多算法在常数时间内完成操作。常见的应用包括判断奇偶性、交换数值、位掩码操作等。</p>
<p><strong>常见的位操作技巧</strong>：</p>
<ul>
<li><p><strong>判断奇偶</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &amp; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果 n 的最低位是 1 则为奇数，否则为偶数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>交换两个数</strong>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">void</span> swap(int &amp;a, int &amp;b) &#123;<br>    <span class="hljs-attribute">a</span> = a<span class="hljs-regexp"> ^</span> b;<br>    <span class="hljs-attribute">b</span> = a<span class="hljs-regexp"> ^</span> b;<br>    <span class="hljs-attribute">a</span> = a<span class="hljs-regexp"> ^</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>快速计算 2 的幂</strong>：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">bool isPowerOfTwo(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>    return (<span class="hljs-built_in">n</span> &gt; <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">n</span> &amp; (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;  // <span class="hljs-built_in">n</span> 是 <span class="hljs-number">2</span> 的幂时，其二进制中只有一个 <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="13-处理大整数运算"><a href="#13-处理大整数运算" class="headerlink" title="13. 处理大整数运算"></a>13. <strong>处理大整数运算</strong></h4><p>在算法竞赛中，有时会遇到超出标准 <code>int</code> 范围的整数运算（如大数乘法、幂运算等）。C++ 可以使用标准库中的 <code>__int128</code>（在某些编译器下可用），但更常用的方式是处理模运算，确保大数计算不会溢出。</p>
<p><strong>快速幂运算（模幂运算）</strong>：</p>
<p>快速幂用于计算形如 <code>a^b mod c</code> 的大数运算，其时间复杂度为 O(log b)，比直接乘法更高效。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-title">modPow</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">base</span>, <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> exp, <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> mod</span>)</span> &#123;<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (exp &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (exp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果 exp 是奇数</span><br>            result = (result * <span class="hljs-keyword">base</span>) % mod;<br>        &#125;<br>        <span class="hljs-keyword">base</span> = (<span class="hljs-keyword">base</span> * <span class="hljs-keyword">base</span>) % mod;  <span class="hljs-comment">// 平方</span><br>        exp /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">base</span> = <span class="hljs-number">2</span>, exp = <span class="hljs-number">10</span>, mod = <span class="hljs-number">1000000007</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2^10 % 1000000007 = &quot;</span> &lt;&lt; modPow(<span class="hljs-keyword">base</span>, exp, mod) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：在处理大数的乘法或幂运算时，模运算可以防止数值溢出，并且是数论问题中的常用技巧。</p>
<hr>
<h4 id="14-双指针技巧"><a href="#14-双指针技巧" class="headerlink" title="14. 双指针技巧"></a>14. <strong>双指针技巧</strong></h4><p>双指针是一种高效的数组和链表处理技巧，常用于解决有序数组中的查找、区间问题等。例如，双指针可以在 O(n) 时间复杂度内完成两个有序数组的合并、判断子数组的和是否等于给定值等。</p>
<p>示例：求解有序数组中的两数之和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">twoSumSorted</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> sum = arr[left] + arr[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 找到和为 target 的两个数</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">twoSumSorted</span>(arr, target)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Found two numbers with sum &quot;</span> &lt;&lt; target &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No two numbers found&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：双指针在处理区间、滑动窗口、链表等场景中非常常用，是解决两数问题、三数问题等经典问题的有效方法。</p>
<hr>
<h4 id="15-滑动窗口技术"><a href="#15-滑动窗口技术" class="headerlink" title="15. 滑动窗口技术"></a>15. <strong>滑动窗口技术</strong></h4><p>滑动窗口是一种高效的处理子数组、子串问题的技巧，适合用在求解固定长度或动态长度的窗口内的最优值。通常，滑动窗口可以在 O(n) 时间复杂度内完成任务。</p>
<p>示例：滑动窗口求解最长不重复子串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">char</span> c = s[right];<br>        window[c]++;<br>        right++;<br><br>        <span class="hljs-comment">// 如果窗口中有重复的字符，收缩左边界</span><br>        <span class="hljs-keyword">while</span> (window[c] &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">char</span> d = s[left];<br>            window[d]--;<br>            left++;<br>        &#125;<br><br>        maxLength = <span class="hljs-built_in">max</span>(maxLength, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLength;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;abcabcbb&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Longest substring length: &quot;</span> &lt;&lt; <span class="hljs-built_in">lengthOfLongestSubstring</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：滑动窗口技术常用于解决子串或子数组问题，例如最长连续子串、最大子数组和等问题。</p>
<hr>
<h4 id="16-优先队列（堆）"><a href="#16-优先队列（堆）" class="headerlink" title="16. 优先队列（堆）"></a>16. <strong>优先队列（堆）</strong></h4><p>优先队列（堆）是一种高效的数据结构，常用于需要动态维护最大值或最小值的场景。C++ 提供了 <code>std::priority_queue</code>，用于实现最大堆和最小堆。</p>
<p>示例：使用优先队列求解滑动窗口中的最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq;  <span class="hljs-comment">// 双端队列，用于存储元素下标</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-comment">// 移除滑动窗口外的元素</span><br>        <span class="hljs-keyword">if</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() == i - k) dq.<span class="hljs-built_in">pop_front</span>();<br><br>        <span class="hljs-comment">// 移除队列中所有比当前元素小的元素</span><br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i]) dq.<span class="hljs-built_in">pop_back</span>();<br><br>        <span class="hljs-comment">// 将当前元素下标加入队列</span><br>        dq.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-comment">// 如果当前下标 i 达到窗口大小 k，记录当前最大值</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) result.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">3</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">maxSlidingWindow</span>(nums, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : result) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：优先队列常用于需要实时维护最大值或最小值的问题，如动态滑动窗口最大值、最小生成树（Prim、Kruskal）、Dijkstra 算法等。</p>
<hr>
<h4 id="17-使用动态规划模板"><a href="#17-使用动态规划模板" class="headerlink" title="17. 使用动态规划模板"></a>17. <strong>使用动态规划模板</strong></h4><p>在竞赛中，动态规划（DP）是非常常见的技巧。通过模板化的解法，可以快速解决很多 DP 问题，如背包问题、最长子序列问题、区间问题等。</p>
<p>示例：0-1 背包问题的动态规划解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> W, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; values)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = weights.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">1</span>; w &lt;= W; ++w) &#123;<br>            <span class="hljs-keyword">if</span> (weights[i - <span class="hljs-number">1</span>] &lt;= w) &#123;<br>                dp[i][w] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][w], dp[i - <span class="hljs-number">1</span>][w - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][w] = dp[i - <span class="hljs-number">1</span>][w];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][W];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weights = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; values = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> W = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum value: &quot;</span> &lt;&lt; <span class="hljs-built_in">knapsack</span>(W, weights, values) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：动态规划适用于很多优化问题，如背包问题、最长递增子序列、区间合并等。</p>
<h1 id="一-数组"><a href="#一-数组" class="headerlink" title="一.数组"></a>一.数组</h1><p>c++的操作</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;cstdio&gt;  // For printf</span><br><span class="hljs-comment">#include &lt;algorithm&gt;  // For sort and reverse</span><br><br><span class="hljs-keyword">int</span> main() &#123;<br>    <span class="hljs-regexp">//</span> 初始化数组<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;数组第一个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, arr[<span class="hljs-number">0</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">1</span><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;数组第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, arr[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">3</span><br><br>    // 修改数组元素<br>    arr[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;修改后的第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, arr[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">10</span><br><br>    // 使用<span class="hljs-keyword">for</span>循环遍历数组<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;数组元素: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-regexp">//</span> 使用C风格的数组模拟vector功能<br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">vec</span>[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">int</span> vec_size = <span class="hljs-number">5</span>;  <span class="hljs-regexp">//</span> 跟踪实际元素个数<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;vector第一个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, <span class="hljs-keyword">vec</span>[<span class="hljs-number">0</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">1</span><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;vector第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">3</span><br><br>    // 修改vector元素<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;修改后的第三个元素: <span class="hljs-variable">%d</span>\n&quot;</span>, <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>]);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">10</span><br><br>    // 向vector中添加元素（实际是模拟）<br>    <span class="hljs-keyword">if</span> (vec_size &lt; <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-keyword">vec</span>[vec_size] = <span class="hljs-number">6</span>;  <span class="hljs-regexp">//</span> 添加到末尾<br>        vec_size++;<br>    &#125;<br><br>    // 手动插入元素，模拟插入操作<br>    <span class="hljs-keyword">if</span> (vec_size &lt; <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = vec_size; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-keyword">vec</span>[i] = <span class="hljs-keyword">vec</span>[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">vec</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">7</span>;  <span class="hljs-regexp">//</span> 在索引<span class="hljs-number">1</span>处插入<br>        vec_size++;<br>    &#125;<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;添加元素后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-regexp">//</span> 从vector中删除元素（手动操作）<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vec_size - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">vec</span>[i] = <span class="hljs-keyword">vec</span>[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    vec_size--;  <span class="hljs-regexp">//</span> 删除末尾元素<br>    vec_size--;  <span class="hljs-regexp">//</span> 再删除一个<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;删除元素后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-regexp">//</span> 清空vector（模拟）<br>    vec_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;清空后的vector大小: <span class="hljs-variable">%d</span>\n&quot;</span>, vec_size);  <span class="hljs-regexp">//</span> 输出: <span class="hljs-number">0</span><br><br>    // 重新填充vector<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">vec</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;<br>    vec_size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-regexp">//</span> 排序和反转vector<br>    std::<span class="hljs-keyword">sort</span>(<span class="hljs-keyword">vec</span>, <span class="hljs-keyword">vec</span> + vec_size);  <span class="hljs-regexp">//</span> 使用标准算法排序<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;排序后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    std::<span class="hljs-keyword">reverse</span>(<span class="hljs-keyword">vec</span>, <span class="hljs-keyword">vec</span> + vec_size);  <span class="hljs-regexp">//</span> 使用标准算法反转<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;反转后的vector: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec_size; i++) &#123;<br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>, <span class="hljs-keyword">vec</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">java</span> &#123;<br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 初始化数组</span><br>        <span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-comment">// 访问元素</span><br>        System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">2</span>]);  <span class="hljs-comment">// 输出 3, 访问数组中索引为2的元素</span><br>        <span class="hljs-comment">// 修改元素</span><br>        arr[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 将数组中索引为2的元素修改为10</span><br>        <span class="hljs-comment">// 使用ArrayList来实现动态数组Arrays.asList是java.util.Arrays类中的一个静态方法，它接受一个可变参数（varargs）并返回一个包含这些元素的固定大小的List然后使用new ArrayList&lt;&gt;(...)构造一个新的ArrayList对象，初始内容为上述固定大小的List中的元素。这使得新创建的ArrayList具有这些初始元素，同时它是可变大小的，可以添加和删除元素。</span><br>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-number">6</span>);  <span class="hljs-comment">// 在数组末尾添加元素6</span><br>        <span class="hljs-comment">// 删除元素之前先检查是否存在</span><br>        <span class="hljs-keyword">if</span> (list.contains(<span class="hljs-number">3</span>)) &#123;  <span class="hljs-comment">// 检查元素3是否在数组中</span><br>            list.remove(Integer.valueOf(<span class="hljs-number">3</span>));  <span class="hljs-comment">// 删除数组中的元素3</span><br>        &#125;<br>        <span class="hljs-comment">// 打印修改后的数组</span><br>        System.<span class="hljs-keyword">out</span>.println(list);  <span class="hljs-comment">// 输出修改后的数组 [1, 2, 10, 4, 5, 6]</span><br><br><br>        <span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>Array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        String[] strArray = new String[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 初始化一个包含5个元素的数组，元素默认值为null</span><br>        <span class="hljs-built_in">int</span> firstElement = <span class="hljs-built_in">int</span>Array[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 访问第一个元素</span><br>        <span class="hljs-built_in">int</span>Array[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 修改第三个元素的值为10</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>Array.length; i++) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">int</span>Array[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> value : <span class="hljs-built_in">int</span>Array) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(value);<br>        &#125;<br>        Arrays.sort(<span class="hljs-built_in">int</span>Array);  <span class="hljs-comment">// 对数组进行排序，要import java.util.Arrays;</span><br><br>        <span class="hljs-built_in">int</span>[] newArray = Arrays.copyOf(<span class="hljs-built_in">int</span>Array, <span class="hljs-built_in">int</span>Array.length);  <span class="hljs-comment">// 复制整个数组</span><br>        <span class="hljs-built_in">int</span>[] partialArray = Arrays.copyOf(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 复制数组的前3个元素</span><br>        <span class="hljs-built_in">int</span>[] destinationArray = new <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br>        System.<span class="hljs-built_in">array</span>copy(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">0</span>, destinationArray, <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>Array.length);  <span class="hljs-comment">// 复制数组到另一个数组</span><br><br>        String <span class="hljs-built_in">array</span>String = Arrays.toString(<span class="hljs-built_in">int</span>Array);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">array</span>String);  <span class="hljs-comment">// 输出数组的字符串表示</span><br>        List&lt;Integer&gt; <span class="hljs-built_in">array</span>List = new ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br><br>        Arrays.fill(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 将数组的所有元素设置为10</span><br>        Arrays.fill(<span class="hljs-built_in">int</span>Array, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 将数组的部分元素设置为20（索引1到2）</span><br>        <span class="hljs-built_in">int</span>[] anotherArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-built_in">bool</span>ean <span class="hljs-built_in">array</span>sEqual = Arrays.equals(<span class="hljs-built_in">int</span>Array, anotherArray);  <span class="hljs-comment">// 检查两个数组是否相等</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Arrays are equal: &quot;</span> + <span class="hljs-built_in">array</span>sEqual);<br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 初始化列表</span><br><span class="hljs-attribute">arr</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">2</span>])  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span><br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5]</span><br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">arr</span>.append(<span class="hljs-number">6</span>)  # 在末尾添加<br><span class="hljs-attribute">arr</span>.insert(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)  # 在索引<span class="hljs-number">1</span>处插入<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 7, 2, 10, 4, 5, 6]</span><br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">arr</span>.remove(<span class="hljs-number">7</span>)  # 移除第一个值为<span class="hljs-number">7</span>的元素<br><span class="hljs-attribute">del</span> arr[<span class="hljs-number">2</span>]  # 删除索引<span class="hljs-number">2</span>处的元素<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5, 6]</span><br><br><span class="hljs-comment"># 切片</span><br><span class="hljs-attribute">sub_arr</span> = arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  # 从索引<span class="hljs-number">1</span>到索引<span class="hljs-number">3</span>的子数组<br><span class="hljs-attribute">print</span>(sub_arr)  # 输出<span class="hljs-meta"> [2, 10, 4]</span><br><br><span class="hljs-comment"># 遍历</span><br><span class="hljs-attribute">for</span> value in arr:<br>    <span class="hljs-attribute">print</span>(value, end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">print</span>()<br><br><span class="hljs-comment"># 使用索引遍历</span><br><span class="hljs-attribute">for</span> i in range(len(arr)):<br>    <span class="hljs-attribute">print</span>(arr[i], end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">print</span>()<br><br><span class="hljs-comment"># 检查元素是否在列表中</span><br><span class="hljs-attribute">print</span>(<span class="hljs-number">10</span> in arr)  # 输出 True<br><br><span class="hljs-comment"># 获取长度</span><br><span class="hljs-attribute">print</span>(len(arr))  # 输出 <span class="hljs-number">6</span><br><br><span class="hljs-comment"># 列表合并</span><br><span class="hljs-attribute">arr2</span> =<span class="hljs-meta"> [7, 8, 9]</span><br><span class="hljs-attribute">combined_arr</span> = arr + arr2<br><span class="hljs-attribute">print</span>(combined_arr)  # 输出<span class="hljs-meta"> [1, 2, 10, 4, 5, 6, 7, 8, 9]</span><br><br><span class="hljs-comment"># 列表排序</span><br><span class="hljs-attribute">arr</span>.sort()<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [1, 2, 4, 5, 6, 10]</span><br><br><span class="hljs-comment"># 列表反转</span><br><span class="hljs-attribute">arr</span>.reverse()<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [10, 6, 5, 4, 2, 1]</span><br><br><br><span class="hljs-comment">#使用 NumPy 数组操作</span><br><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-comment"># 初始化数组</span><br><span class="hljs-attribute">arr</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(arr[<span class="hljs-number">2</span>])  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span><br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [ 1  2 10  4  5]</span><br><br><span class="hljs-comment"># 切片</span><br><span class="hljs-attribute">sub_arr</span> = arr[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  # 从索引<span class="hljs-number">1</span>到索引<span class="hljs-number">3</span>的子数组<br><span class="hljs-attribute">print</span>(sub_arr)  # 输出<span class="hljs-meta"> [ 2 10  4]</span><br><br><span class="hljs-comment"># 遍历</span><br><span class="hljs-attribute">for</span> value in arr:<br>    <span class="hljs-attribute">print</span>(value, end=&#x27; &#x27;)  # 输出 <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">print</span>()<br><span class="hljs-comment"># 数组元素的加法</span><br><span class="hljs-attribute">arr2</span> = np.array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])<br><span class="hljs-attribute">result</span> = arr + arr2<br><span class="hljs-attribute">print</span>(result)  # 输出<span class="hljs-meta"> [11 22 40 44 55]</span><br><br><span class="hljs-comment"># 数组元素的乘法</span><br><span class="hljs-attribute">result</span> = arr * <span class="hljs-number">2</span><br><span class="hljs-attribute">print</span>(result)  # 输出<span class="hljs-meta"> [ 2  4 20  8 10]</span><br><br><span class="hljs-comment"># 数组的矩阵运算</span><br><span class="hljs-attribute">matrix1</span> = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<span class="hljs-meta"> [3, 4]])</span><br><span class="hljs-meta">matrix2 = np.array([[5, 6], [7, 8]])</span><br><span class="hljs-meta">result = np.dot(matrix1, matrix2)</span><br><span class="hljs-meta">print(result)</span><br><span class="hljs-meta"># 输出</span><br><span class="hljs-meta"># [[19 22]</span><br><span class="hljs-comment">#  [43 50]]</span><br><span class="hljs-comment"># 创建特定形状的数组</span><br><span class="hljs-attribute">zeros</span> = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(zeros)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[0. 0. 0.]</span><br><span class="hljs-comment">#  [0. 0. 0.]</span><br><span class="hljs-comment">#  [0. 0. 0.]]</span><br><br><span class="hljs-attribute">ones</span> = np.ones((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))<br><span class="hljs-attribute">print</span>(ones)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[1. 1. 1. 1.]</span><br><span class="hljs-comment">#  [1. 1. 1. 1.]]</span><br><br><span class="hljs-comment"># 生成等差数组</span><br><span class="hljs-attribute">arr</span> = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br><span class="hljs-attribute">print</span>(arr)  # 输出<span class="hljs-meta"> [0 2 4 6 8]</span><br><br><span class="hljs-comment"># 数组重塑</span><br><span class="hljs-attribute">arr</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-attribute">reshaped</span> = arr.reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(reshaped)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># [[1 2 3]</span><br><span class="hljs-comment">#  [4 5 6]]</span><br><span class="hljs-comment"># 创建一个包含1到10的平方的列表</span><br><span class="hljs-attribute">squares</span> =<span class="hljs-meta"> [x**2 for x in range(1, 11)]</span><br><span class="hljs-attribute">print</span>(squares)  # 输出<span class="hljs-meta"> [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><br><span class="hljs-comment"># 过滤列表中的元素</span><br><span class="hljs-attribute">even_squares</span> =<span class="hljs-meta"> [x**2 for x in range(1, 11) if x % 2 == 0]</span><br><span class="hljs-attribute">print</span>(even_squares)  # 输出<span class="hljs-meta"> [4, 16, 36, 64, 100]</span><br></code></pre></td></tr></table></figure>

<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>针对去重这类操作的模版</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">num</span>.size;i++)&#123;<br>	<span class="hljs-keyword">if</span>(要什么)&#123;<br>		<span class="hljs-built_in">num</span>[n] = <span class="hljs-built_in">num</span>[i];<br>		n++;<br>	&#125;<br>&#125;<br>去重:i=<span class="hljs-number">0</span> || <span class="hljs-built_in">num</span>[i]!=<span class="hljs-built_in">num</span>[i<span class="hljs-number">-1</span>]<br>移动零: <span class="hljs-built_in">num</span>[i]!=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h1><p>c++的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">data</span>(data), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* head;<br><br>    <span class="hljs-built_in">LinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = newNode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node* last = head;<br>        <span class="hljs-keyword">while</span> (last-&gt;next) &#123;<br>            last = last-&gt;next;<br>        &#125;<br>        last-&gt;next = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepend</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(data);<br>        newNode-&gt;next = head;<br>        head = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteWithValue</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (head-&gt;data == data) &#123;<br>            Node* temp = head;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;data != data) &#123;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current-&gt;next) &#123;<br>            Node* temp = current-&gt;next;<br>            current-&gt;next = current-&gt;next-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;None&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current) &#123;<br>            Node* next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            current = next;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用链表类</span><br>    LinkedList myList;<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">1</span>);<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">2</span>);<br>    myList.<span class="hljs-built_in">append</span>(<span class="hljs-number">3</span>);<br>    myList.<span class="hljs-built_in">prepend</span>(<span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list after additions: &quot;</span>;<br>    myList.<span class="hljs-built_in">printList</span>();  <span class="hljs-comment">// 输出: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; None</span><br><br>    myList.<span class="hljs-built_in">deleteWithValue</span>(<span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list after deleting 2: &quot;</span>;<br>    myList.<span class="hljs-built_in">printList</span>();  <span class="hljs-comment">// 输出: 0 -&gt; 1 -&gt; 3 -&gt; None</span><br><br>    <span class="hljs-comment">// 使用 std::list 示例</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Using std::list:&quot;</span> &lt;&lt; std::endl;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// 添加元素</span><br>    lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after additions: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First element: &quot;</span> &lt;&lt; lst.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Last element: &quot;</span> &lt;&lt; lst.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl;    <span class="hljs-comment">// 输出: 4</span><br><br>    <span class="hljs-comment">// 修改元素</span><br>    <span class="hljs-keyword">auto</span> it = lst.<span class="hljs-built_in">begin</span>();<br>    ++it;  <span class="hljs-comment">// 指向第二个元素</span><br>    *it = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after modifying second element: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    lst.<span class="hljs-built_in">remove</span>(<span class="hljs-number">10</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;List after removing 10: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : lst) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>链表类（LinkedList）:<br><br><span class="hljs-built_in">append</span>(<span class="hljs-type">int</span> data)：在链表末尾添加元素。<br><span class="hljs-built_in">prepend</span>(<span class="hljs-type">int</span> data)：在链表头部添加元素。<br><span class="hljs-built_in">deleteWithValue</span>(<span class="hljs-type">int</span> data)：删除值为 data 的节点。<br><span class="hljs-built_in">printList</span>()：打印链表中的所有元素。<br>析构函数 ~<span class="hljs-built_in">LinkedList</span>()：释放链表占用的内存。<br>std::list 示例:<br><br><span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)：在列表末尾添加元素。<br><span class="hljs-built_in">push_front</span>(<span class="hljs-type">int</span> value)：在列表头部添加元素。<br><span class="hljs-built_in">front</span>()：访问第一个元素。<br><span class="hljs-built_in">back</span>()：访问最后一个元素。<br>通过迭代器修改元素。<br><span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> value)：删除值为 value 的所有元素。<br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> java1 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 初始化链表</span><br>        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Initial list: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br><br>        <span class="hljs-comment">// 访问元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;First element: &quot;</span> + list.getFirst()); <span class="hljs-comment">// 输出 1</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Last element: &quot;</span> + list.getLast());   <span class="hljs-comment">// 输出 3</span><br><br>        <span class="hljs-comment">// 修改元素</span><br>        list.set(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// 修改索引1处的元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after modification: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 20, 3]</span><br><br>        <span class="hljs-comment">// 删除元素</span><br>        list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除索引1处的元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after removal: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 3]</span><br><br>        <span class="hljs-comment">// 链表大小</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Size of the list: &quot;</span> + list.<span class="hljs-keyword">size</span>()); <span class="hljs-comment">// 输出 2</span><br><br>        <span class="hljs-comment">// 遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using for-each loop: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (Integer element : list) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(element + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用迭代器遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using iterator: &quot;</span>);<br>        Iterator&lt;Integer&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(iterator.<span class="hljs-keyword">next</span>() + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用索引遍历链表</span><br>        System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Traversing list using for loop: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-keyword">size</span>(); i++) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(list.get(i) + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 输出 1 3</span><br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br><br>        <span class="hljs-comment">// 使用Deque操作</span><br>        list.addFirst(<span class="hljs-number">0</span>); <span class="hljs-comment">// 在头部添加元素</span><br>        list.addLast(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 在尾部添加元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after deque operations: &quot;</span> + list); <span class="hljs-comment">// 输出 [0, 1, 3, 4]</span><br><br>        <span class="hljs-comment">// 删除Deque操作</span><br>        list.removeFirst(); <span class="hljs-comment">// 删除头部元素</span><br>        list.removeLast();  <span class="hljs-comment">// 删除尾部元素</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after removing first and last: &quot;</span> + list); <span class="hljs-comment">// 输出 [1, 3]</span><br><br>        <span class="hljs-comment">// 检查元素是否存在</span><br>        <span class="hljs-keyword">boolean</span> contains = list.contains(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List contains 3: &quot;</span> + contains); <span class="hljs-comment">// 输出 true</span><br><br>        <span class="hljs-comment">// 清空链表</span><br>        list.clear();<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;List after clear: &quot;</span> + list); <span class="hljs-comment">// 输出 []</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Size of the list after clear: &quot;</span> + list.<span class="hljs-keyword">size</span>()); <span class="hljs-comment">// 输出 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 使用 Python 内置的 list</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Using Python list:&quot;</span>)<br><br><span class="hljs-comment"># 初始化列表</span><br><span class="hljs-attribute">lst</span> =<span class="hljs-meta"> [1, 2, 3]</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Initial list:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 2, 3]</span><br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">lst</span>.append(<span class="hljs-number">4</span>)  # 在末尾添加元素<br><span class="hljs-attribute">lst</span>.insert(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>)  # 在索引<span class="hljs-number">1</span>处插入元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after additions:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 1.5, 2, 3, 4]</span><br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;First element:&quot;</span>, lst[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Last element:&quot;</span>, lst[-<span class="hljs-number">1</span>])  # 输出 <span class="hljs-number">4</span><br><br><span class="hljs-comment"># 修改元素</span><br><span class="hljs-attribute">lst</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after modification:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [1, 1.8, 2, 3, 4]</span><br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">lst</span>.remove(<span class="hljs-number">1</span>.<span class="hljs-number">8</span>)  # 删除值为<span class="hljs-number">1</span>.<span class="hljs-number">8</span>的元素<br><span class="hljs-attribute">del</span> lst[<span class="hljs-number">0</span>]  # 删除索引<span class="hljs-number">0</span>处的元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;List after deletions:&quot;</span>, lst)  # 输出<span class="hljs-meta"> [2, 3, 4]</span><br><br><span class="hljs-comment"># 列表长度</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Length of the list:&quot;</span>, len(lst))  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历列表</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Traversing the list:&quot;</span>)<br><span class="hljs-attribute">for</span> item in lst:<br>    <span class="hljs-attribute">print</span>(item, end=<span class="hljs-string">&quot; &quot;</span>)  # 输出 <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment">### 使用 `collections.deque`</span><br><br><br><span class="hljs-attribute">from</span> collections import deque<br><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Using collections.deque:&quot;</span>)<br><br><span class="hljs-comment"># 初始化deque</span><br><span class="hljs-attribute">d</span> = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Initial deque:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 添加元素</span><br><span class="hljs-attribute">d</span>.append(<span class="hljs-number">4</span>)  # 在尾部添加<br><span class="hljs-attribute">d</span>.appendleft(<span class="hljs-number">0</span>)  # 在头部添加<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after additions:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 访问元素（需要转换为列表）</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;First element:&quot;</span>, d[<span class="hljs-number">0</span>])  # 输出 <span class="hljs-number">0</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Last element:&quot;</span>, d[-<span class="hljs-number">1</span>])  # 输出 <span class="hljs-number">4</span><br><br><span class="hljs-comment"># 修改元素（需要转换为列表）</span><br><span class="hljs-attribute">d_list</span> = list(d)<br><span class="hljs-attribute">d_list</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">d</span> = deque(d_list)<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after modification:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-attribute">d</span>.pop()  # 删除尾部元素<br><span class="hljs-attribute">d</span>.popleft()  # 删除头部元素<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Deque after deletions:&quot;</span>, d)  # 输出 deque([<span class="hljs-number">1</span>.<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># deque长度</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Length of the deque:&quot;</span>, len(d))  # 输出 <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 遍历deque</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;Traversing the deque:&quot;</span>)<br><span class="hljs-attribute">for</span> item in d:<br>    <span class="hljs-attribute">print</span>(item, end=<span class="hljs-string">&quot; &quot;</span>)  # 输出 <span class="hljs-number">1</span>.<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h2 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl">head  head 是一个指针，指向链表的第一个节点，因此它表示整个链表的起始<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;null(补充的<span class="hljs-keyword">last</span>)<br><br> struct ListNode &#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* <span class="hljs-keyword">next</span>;<br>    ListNode(<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>) : val(<span class="hljs-keyword">x</span>), <span class="hljs-keyword">next</span>(nullptr) &#123;&#125;<br>&#125;;<br><br>ListNode* reverseList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-keyword">last</span> = nullptr;<br>    <span class="hljs-keyword">while</span> (head != nullptr) &#123;<br>        ListNode* nextHead = head-&gt;<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span> 暂存下一个节点<br>        head-&gt;<span class="hljs-keyword">next</span> = <span class="hljs-keyword">last</span>;                <span class="hljs-regexp">//</span> 反转当前节点的指针<br>        <span class="hljs-keyword">last</span> = head;                      <span class="hljs-regexp">//</span> 更新<span class="hljs-keyword">last</span>为当前节点<br>        head = nextHead;                  <span class="hljs-regexp">//</span> 继续处理下一个节点<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">last</span>;                          <span class="hljs-regexp">//</span> 返回新头节点<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="三-单调栈"><a href="#三-单调栈" class="headerlink" title="三.单调栈"></a>三.单调栈</h1><p>栈的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;C++ 实现\n&quot;</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;栈操作（Stack）：&quot;</span> &lt;&lt; std::endl;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 压栈</span><br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Stack after pushes: &quot;</span>;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; tempStack = stack;<br>    <span class="hljs-keyword">while</span> (!tempStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempStack.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-type">int</span> top = stack.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 获取栈顶元素</span><br>    stack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 出栈</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Popped element: &quot;</span> &lt;&lt; top &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Stack after pop: &quot;</span>;<br>    tempStack = stack;<br>    <span class="hljs-keyword">while</span> (!tempStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempStack.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 队列</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n队列操作（Queue）：&quot;</span> &lt;&lt; std::endl;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; queue;<br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 入队</span><br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Queue after enqueues: &quot;</span>;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; tempQueue = queue;<br>    <span class="hljs-keyword">while</span> (!tempQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempQueue.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempQueue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-type">int</span> front = queue.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 获取队首元素</span><br>    queue.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 出队</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Dequeued element: &quot;</span> &lt;&lt; front &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Queue after dequeue: &quot;</span>;<br>    tempQueue = queue;<br>    <span class="hljs-keyword">while</span> (!tempQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempQueue.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempQueue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 双端队列</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n双端队列操作（Deque）：&quot;</span> &lt;&lt; std::endl;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; deque;<br>    deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 在尾部添加</span><br>    deque.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部添加</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Deque after additions: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : deque) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-type">int</span> last = deque.<span class="hljs-built_in">back</span>();  <span class="hljs-comment">// 获取尾部元素</span><br>    deque.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 从尾部移除</span><br>    <span class="hljs-type">int</span> first = deque.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 获取头部元素</span><br>    deque.<span class="hljs-built_in">pop_front</span>();  <span class="hljs-comment">// 从头部移除</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Deque after removals: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : deque) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 优先队列</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n优先队列操作（Priority Queue）：&quot;</span> &lt;&lt; std::endl;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 入队</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Priority Queue elements: &quot;</span>;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; tempPQ = pq;<br>    <span class="hljs-keyword">while</span> (!tempPQ.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; tempPQ.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        tempPQ.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 按优先级顺序出队</span><br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>java的操作</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// Java实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">java2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 栈</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Java 实现\n&quot;</span>);<br><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;栈操作（Stack）：&quot;</span>);<br>        java.util.Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> java.util.Stack&lt;&gt;();<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 压栈</span><br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Stack after pushes: &quot;</span> + stack);<br>        <span class="hljs-type">int</span> top = stack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 出栈</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Popped element: &quot;</span> + top);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Stack after pop: &quot;</span> + stack);<br><br>        <span class="hljs-comment">// 队列</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n队列操作（Queue）：&quot;</span>);<br>        java.util.Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> java.util.LinkedList&lt;&gt;();<br>        queue.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 入队</span><br>        queue.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>);<br>        queue.<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Queue after enqueues: &quot;</span> + queue);<br>        <span class="hljs-type">int</span> front = queue.<span class="hljs-built_in">poll</span>();  <span class="hljs-comment">// 出队</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Dequeued element: &quot;</span> + front);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Queue after dequeue: &quot;</span> + queue);<br><br>        <span class="hljs-comment">// 双端队列</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n双端队列操作（Deque）：&quot;</span>);<br>        java.util.Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> java.util.LinkedList&lt;&gt;();<br>        deque.<span class="hljs-built_in">addLast</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 在尾部添加</span><br>        deque.<span class="hljs-built_in">addFirst</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部添加</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Deque after additions: &quot;</span> + deque);<br>        <span class="hljs-type">int</span> last = deque.<span class="hljs-built_in">removeLast</span>();  <span class="hljs-comment">// 从尾部移除</span><br>        <span class="hljs-type">int</span> first = deque.<span class="hljs-built_in">removeFirst</span>();  <span class="hljs-comment">// 从头部移除</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Deque after removals: &quot;</span> + deque);<br><br>        <span class="hljs-comment">// 优先队列</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n优先队列操作（Priority Queue）：&quot;</span>);<br>        java.util.PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> java.util.PriorityQueue&lt;&gt;();<br>        pq.<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 入队</span><br>        pq.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);<br>        pq.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Priority Queue elements: &quot;</span> + pq);<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            System.out.<span class="hljs-built_in">println</span>(pq.<span class="hljs-built_in">poll</span>());  <span class="hljs-comment">// 按优先级顺序出队</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的操作</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Python实现</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Python 实现&quot;</span>)<br><br><span class="hljs-comment"># 栈</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n栈操作（Stack）：&quot;</span>)<br>stack = []<br>stack.append(1)  # 压栈<br>stack.append(2)<br>stack.append(3)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stack after pushes:&quot;</span>, stack)<br>top = stack.pop()  # 出栈<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Popped element:&quot;</span>, top)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stack after pop:&quot;</span>, stack)<br><br><span class="hljs-comment"># 队列</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n队列操作（Queue）：&quot;</span>)<br><span class="hljs-keyword">from</span> collections import deque<span class="hljs-built_in"></span><br><span class="hljs-built_in">queue </span>= deque()<br>queue.append(1)  # 入队<br>queue.append(2)<br>queue.append(3)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Queue after enqueues:&quot;</span>, queue)<br>front = queue.popleft()  # 出队<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dequeued element:&quot;</span>, front)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Queue after dequeue:&quot;</span>, queue)<br><br><span class="hljs-comment"># 双端队列</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n双端队列操作（Deque）：&quot;</span>)<br>deque = deque()<br>deque.append(1)  # 在尾部添加<br>deque.appendleft(0)  # 在头部添加<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deque after additions:&quot;</span>, deque)<br>last = deque.pop()  # 从尾部移除<br>first = deque.popleft()  # 从头部移除<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deque after removals:&quot;</span>, deque)<br><br><span class="hljs-comment"># 优先队列</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n优先队列操作（Priority Queue）：&quot;</span>)<br>import<span class="hljs-built_in"> queue</span><br><span class="hljs-built_in"></span>pq = queue.PriorityQueue()<br>pq.put((2, <span class="hljs-string">&quot;B&quot;</span>))  # 入队<br>pq.put((1, <span class="hljs-string">&quot;A&quot;</span>))<br>pq.put((3, <span class="hljs-string">&quot;C&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Priority Queue elements:&quot;</span>, pq.queue)<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> pq.empty():<br>    <span class="hljs-built_in">print</span>(pq.<span class="hljs-built_in">get</span>())  # 按优先级顺序出队<br></code></pre></td></tr></table></figure>

<p>经验</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><br>当新h小于之前的h,进行累加长度更新答案,pop上一个被推的栈,推累长加一的h栈<br><br>核心思想:单调栈考虑前面不影响后面<br>套路模版: <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//int一个答案要全局</span><br>heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 如果需要弹空就写</span><br><span class="hljs-keyword">for</span>(破坏单调的位置&amp;&amp;不能空)&#123;<br>	<span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(栈顶与新元素不满足单调栈)&#123;<br>	 	累加长度<br>	 	更新答案<br>	 	pop弹栈<br>	 	....... <span class="hljs-comment">//期间可以思考增加限制</span><br>	&#125;<br>	s.<span class="hljs-built_in">push</span>(&#123;accmulatedWidth<span class="hljs-number">+1</span>,height&#125;);<br>&#125;<br><br><br><br>例子<br>柱状图中最大矩形<br>heighs=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br><span class="hljs-keyword">private</span>:<br>	stuct UERT&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	stack &lt;UERT&gt; s;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    	<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    	heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 便于最后清空栈</span><br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>    		<span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度小于栈顶柱子的高度，则计算面积</span><br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>().height &gt;= height) &#123;<br>                accmulatedWidth += s.<span class="hljs-built_in">top</span>().width;<br>                res = <span class="hljs-built_in">max</span>(ans,s.<span class="hljs-built_in">top</span>().width*accmulatedWidth);            <br>                s.<span class="hljs-built_in">pop</span>();            <br>        	&#125;<br>        	s.<span class="hljs-built_in">push</span>(&#123;accmulatedWidth<span class="hljs-number">+1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>   		&#125;<br>    	<span class="hljs-keyword">return</span> res;<br>	&#125;<br><br><br><br>接雨水<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UERT</span>&#123;<br>		<span class="hljs-type">int</span> width;<br>		<span class="hljs-type">int</span> height;<br>	&#125;;<br>	stack &lt;UERT&gt; s;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height:heights) &#123;<br>            <span class="hljs-type">int</span> accmulatedWidth = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 如果当前柱子的高度大于栈顶柱子，计算能存储的雨水</span><br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>().height &lt;= height) &#123;<br>                <span class="hljs-type">int</span> bottom = s.<span class="hljs-built_in">top</span>().height;<br>                accmulatedWidth += s.<span class="hljs-built_in">top</span>().width;<br>                s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果栈为空，跳过,水从左边溜走了</span><br>                <span class="hljs-type">int</span> up = <span class="hljs-built_in">min</span>(height,s.<span class="hljs-built_in">top</span>().height);<br>                ans += accmulatedWidth*(up-bottom);<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(&#123;accmulatedWidth<span class="hljs-number">+1</span>,height&#125;);  <span class="hljs-comment">// 将当前柱子的索引压入栈</span><br>        &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;	<br>	<br>前缀和思想<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = heights.<span class="hljs-built_in">size</span>();<br>    preMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    sufMax = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    <br>    <span class="hljs-comment">// 预处理preMax数组</span><br>    preMax[<span class="hljs-number">0</span>] = heights[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        preMax[i] = <span class="hljs-built_in">max</span>(preMax[i - <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 预处理sufMax数组</span><br>    sufMax[n - <span class="hljs-number">1</span>] = heights[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        sufMax[i] = <span class="hljs-built_in">max</span>(sufMax[i + <span class="hljs-number">1</span>], heights[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> up = <span class="hljs-built_in">min</span>(preMax[i - <span class="hljs-number">1</span>], sufMax[i + <span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> bottom = heights[i];<br>        <span class="hljs-keyword">if</span> (up &gt; bottom) &#123;<br>            ans += up - bottom;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>preMax[]：记录当前位置左侧的最大高度。<br>sufMax[]：记录当前位置右侧的最大高度。<br></code></pre></td></tr></table></figure>

<h1 id="四-单调队列"><a href="#四-单调队列" class="headerlink" title="四.单调队列"></a>四.单调队列</h1><p>我们就希望去维护一个这样的候选,集合里边的元素，它们的值是递减的。所以当I它大于等于k-1时，我已经攒够了。q的值是递减的呀，可能成为一个答案的选项，那么此时就对头最好，我就取对头作为答案啊。这就是我们要干三件事情。</p>
<p>单调队列维护的是一个候选集合，前面的比较旧，后面的比较新(时间有单调性</p>
<p>候选项的某个属性也具有单调性</p>
<p>确定递增递减的方法–考虑任意两个候选顶j&lt;j2，写出j比优的条件</p>
<p>排除冗余的关键:若j比j差，j的生命周期还比了短，那了 就没卵用了</p>
<p>单调队列题目代码套路:<br>·for 每个元素<br>    (1)while(队头过期)队头出队<br>    (2)取队头为最佳选项，计算答案                                                                                                                                            	(3)while(队尾与新元素不满足单调性)队尾出队                                                                                                                                                                                                                                                        	(3)新元素入队</p>
<h3 id="1-滑动窗口最大值问题"><a href="#1-滑动窗口最大值问题" class="headerlink" title="1. 滑动窗口最大值问题"></a>1. 滑动窗口最大值问题</h3><ul>
<li>题目：给定一个整数数组和一个窗口大小 <code>k</code>，找出每个窗口内的最大值。</li>
<li>解法：使用双端队列（deque）来实现窗口内最大值的获取，确保在时间复杂度上达到最优（<code>O(n)</code>）。</li>
</ul>
<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><ul>
<li><p><code>vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)</code>：主函数，计算滑动窗口的最大值。</p>
<ul>
<li>创建一个<code>deque&lt;int&gt; q</code>用于存储元素的索引，保持双端队列中元素从大到小的顺序。</li>
<li>遍历数组中的每个元素：<ol>
<li><strong>删除过期元素</strong>：检查队首的元素是否超出了当前滑动窗口的范围，如果超出，则弹出队首。</li>
<li><strong>插入新元素</strong>：保持队列递减的性质，移除队列中比当前元素小的所有元素。</li>
<li><strong>记录窗口最大值</strong>：当遍历到第 <code>k-1</code> 个元素之后，将当前窗口的最大值添加到结果中。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>deque&lt;int&gt; q</code>：用于存储滑动窗口内可能成为最大值的元素的索引。</p>
<ul>
<li>双端队列的特点是支持在两端进行插入和删除操作，保证了队列中的元素在当前窗口范围内保持从大到小的顺序。</li>
</ul>
</li>
</ul>
<h3 id="3-辅助说明"><a href="#3-辅助说明" class="headerlink" title="3. 辅助说明"></a>3. 辅助说明</h3><ul>
<li><strong>复杂度分析</strong>：通过使用双端队列，可以确保每个元素在队列中最多进出一次，因此整体的时间复杂度为 <code>O(n)</code>。</li>
<li><strong>细节</strong>：<ol>
<li>队列中的元素始终按照递减顺序排列，以便每次窗口滑动时，队首元素就是当前窗口的最大值。</li>
<li>插入新的元素时，移除队列中所有比当前元素小的值，保证新的最大值可以被快速获取。</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">解决模版<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans; <span class="hljs-comment">// 存储结果</span><br>        deque&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 用于维护滑动窗口的双端队列</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 删除过期元素：如果队首元素不在当前窗口范围内，则弹出队首</span><br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">front</span>() &lt;= i - k) &#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// 插入新元素：移除队列中所有小于当前元素的值，以保持递减顺序</span><br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[q.<span class="hljs-built_in">back</span>()] &lt;= nums[i]) &#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// 将当前元素的索引加入到队列中</span><br>            q.<span class="hljs-built_in">push_back</span>(i);<br><br>            <span class="hljs-comment">// 记录当前窗口的最大值：队首元素即为窗口内的最大值</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[q.<span class="hljs-built_in">front</span>()]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h1 id="五-集合和映射"><a href="#五-集合和映射" class="headerlink" title="五. 集合和映射"></a>五. 集合和映射</h1><p>C++实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;C++ 实现\n&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 哈希表（unordered_map）</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;哈希表操作（unordered_map）：&quot;</span> &lt;&lt; std::endl;<br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; hashMap;<br>    hashMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span>;<br>    hashMap[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span>;<br>    hashMap[<span class="hljs-string">&quot;c&quot;</span>] = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 添加元素</span><br>    hashMap[<span class="hljs-string">&quot;d&quot;</span>] = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value for key &#x27;a&#x27;: &quot;</span> &lt;&lt; hashMap[<span class="hljs-string">&quot;a&quot;</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 修改元素</span><br>    hashMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    hashMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>    <span class="hljs-comment">// 遍历哈希表</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hash table elements:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : hashMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查键是否存在</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Key &#x27;c&#x27; in hashMap: &quot;</span> &lt;&lt; (hashMap.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;c&quot;</span>) != hashMap.<span class="hljs-built_in">end</span>()) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 无序集合（unordered_set）</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n无序集合操作（unordered_set）：&quot;</span> &lt;&lt; std::endl;<br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; hashSet;<br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 添加元素</span><br>    hashSet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 删除元素</span><br>    hashSet.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 遍历集合</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Set elements:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem : hashSet) &#123;<br>        std::cout &lt;&lt; elem &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查元素是否存在</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Element 3 in hashSet: &quot;</span> &lt;&lt; (hashSet.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>) != hashSet.<span class="hljs-built_in">end</span>()) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java实现</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Java实现</span><br>import java.util.HashMap;<br>import java.util.Map;<br>import java.util.HashSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">java3</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 哈希表（HashMap）</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Java 实现\n&quot;</span>);<br><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;哈希表操作（HashMap）：&quot;</span>);<br>        HashMap&lt;String, Integer&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        hashMap.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>        hashMap.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);<br>        hashMap.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 添加元素</span><br>        hashMap.put(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 访问元素</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Value for key &#x27;a&#x27;: &quot;</span> + hashMap.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;a&quot;</span>));<br><br>        <span class="hljs-comment">// 修改元素</span><br>        hashMap.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        hashMap.<span class="hljs-keyword">remove</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历哈希表</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hash table elements:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(entry.getKey() + <span class="hljs-string">&quot; &quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">// 检查键是否存在</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Key &#x27;c&#x27; in hashMap: &quot;</span> + hashMap.containsKey(<span class="hljs-string">&quot;c&quot;</span>));<br><br>        <span class="hljs-comment">// 无序集合（HashSet）</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\n无序集合操作（HashSet）：&quot;</span>);<br>        HashSet&lt;Integer&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);<br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 添加元素</span><br>        hashSet.<span class="hljs-keyword">add</span>(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        hashSet.<span class="hljs-keyword">remove</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 遍历集合</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Set elements:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> elem : hashSet) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(elem);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查元素是否存在</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Element 3 in hashSet: &quot;</span> + hashSet.contains(<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>py的实现</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Python实现</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Python 实现&quot;</span>)<br><br><span class="hljs-comment"># 哈希表（字典）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n哈希表操作（Dictionary）：&quot;</span>)<br>hash_table = &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>: 1,<br>    <span class="hljs-string">&#x27;b&#x27;</span>: 2,<br>    <span class="hljs-string">&#x27;c&#x27;</span>: 3<br>&#125;<br><br><span class="hljs-comment"># 添加元素</span><br>hash_table[<span class="hljs-string">&#x27;d&#x27;</span>] = 4<br><br><span class="hljs-comment"># 访问元素</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Value for key &#x27;a&#x27;:&quot;</span>, hash_table[<span class="hljs-string">&#x27;a&#x27;</span>])<br><br><span class="hljs-comment"># 修改元素</span><br>hash_table[<span class="hljs-string">&#x27;a&#x27;</span>] = 10<br><br><span class="hljs-comment"># 删除元素</span><br>del hash_table[<span class="hljs-string">&#x27;b&#x27;</span>]<br><br><span class="hljs-comment"># 遍历哈希表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hash table elements:&quot;</span>)<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> hash_table.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br><br><span class="hljs-comment"># 检查键是否存在</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Key &#x27;c&#x27; in hash_table:&quot;</span>, <span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-keyword">in</span> hash_table)<br><br><span class="hljs-comment"># 无序集合（Set）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n无序集合操作（Set）：&quot;</span>)<br>unordered_set = &#123;1, 2, 3&#125;<br><br><span class="hljs-comment"># 添加元素</span><br>unordered_set.<span class="hljs-built_in">add</span>(4)<br><br><span class="hljs-comment"># 删除元素</span><br>unordered_set.<span class="hljs-built_in">remove</span>(2)<br><br><span class="hljs-comment"># 遍历集合</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Set elements:&quot;</span>)<br><span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> unordered_set:<br>    <span class="hljs-built_in">print</span>(elem)<br><br><span class="hljs-comment"># 检查元素是否存在</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Element 3 in unordered_set:&quot;</span>, 3 <span class="hljs-keyword">in</span> unordered_set)<br></code></pre></td></tr></table></figure>

<h2 id="经验-2"><a href="#经验-2" class="headerlink" title="经验"></a>经验</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; h;  <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 遍历数组 nums</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;                    <br>            <span class="hljs-keyword">if</span> (h.<span class="hljs-built_in">find</span>(target-num[i]) != h.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;h[target-num[i]], i&#125;;  <span class="hljs-comment">// 找到两数之和，返回其索引</span><br>            &#125;<br>            <span class="hljs-comment">// 如果不存在，将当前元素和索引存入哈希表</span><br>            h[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 如果未找到符合条件的数对，返回空数组</span><br>    &#125;<br>&#125;;<br><br>模拟行走机器人<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; commands, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dirs[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 四个方向: 北(0,1), 东(1,0), 南(0,-1), 西(-1,0)</span><br>        <span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">60010</span> + y; &#125;;  <span class="hljs-comment">// 将障碍物位置映射为唯一的值</span><br>        std::unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : obstacles) &#123;<br>            s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">f</span>(e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : commands) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-2</span>) &#123;<br>                k = (k + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向左转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-1</span>) &#123;<br>                k = (k + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 向右转 90 度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (c-- &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> nx = x + dirs[k], ny = y + dirs[k + <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">f</span>(nx, ny))) &#123;<br>                        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 遇到障碍物</span><br>                    &#125;<br>                    x = nx;<br>                    y = ny;<br>                    ans = std::<span class="hljs-built_in">max</span>(ans, x * x + y * y);  <span class="hljs-comment">// 计算离原点的距离的平方</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br><br><br>字母异位词分组<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(std::vector&lt;std::string&gt;&amp; strs) &#123;<br>        std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; h;  <span class="hljs-comment">// 哈希表，键是排序后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strs) &#123;<br>            std::string key = str;<br>            std::<span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 将字符串排序</span><br>            h[key].<span class="hljs-built_in">push_back</span>(str);  <span class="hljs-comment">// 将原始字符串加入哈希表</span><br>        &#125;<br>        <br>        std::vector&lt;std::vector&lt;std::string&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : h) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(p.second);  <span class="hljs-comment">// 收集结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>





<h1 id="六-前缀和"><a href="#六-前缀和" class="headerlink" title="六.前缀和"></a>六.前缀和</h1><h3 id="1-前缀和数组（Prefix-Sum-Array，S）："><a href="#1-前缀和数组（Prefix-Sum-Array，S）：" class="headerlink" title="1. 前缀和数组（Prefix Sum Array，S）："></a>1. <strong>前缀和数组（Prefix Sum Array，S）</strong>：</h3><ul>
<li><p>定义：前缀和数组是用于快速计算数组任意区间和的辅助数组。<code>S[i]</code> 表示从数组开头到第 <code>i</code> 个元素的累加和。</p>
</li>
<li><p>公式：</p>
<ul>
<li><p>基本公式：<code>S[i] = S[i-1] + A[i]</code></p>
</li>
<li><p>区间和公式：要计算原数组 <code>A</code> 中 <code>[i, j]</code> 区间的和，可以使用前缀和数组：<code>sum(i, j) = S[j] - S[i-1]</code>  用x,y模拟s[x]-s[y]此时只需要遍历x的位置。</p>
</li>
<li><pre><code class="hljs">[3, 1, 4, 5, 2]
维护前缀和的写法
vector&lt;int&gt; count(n+1);
s[0] = 0;
for(int i=0;i&lt;=0;i++)	s[i]=s[i-1]+sums[i-1]

preMin写法，从左往右遍历，preMin[] = [3, 1, 1, 1, 1]
vector&lt;int&gt; preMin(n+1);
preMin[0] = s[0];
for(int i=0;i&lt;=0;i++)	preMin[i]=min(preMin[i-1],s[i]);                    

preMax写法，从左往右遍历，preMax[] = [3, 3, 4, 5, 5]
vector&lt;int&gt; preMax(n+1);
preMax[0] = s[0];
for(int i=0;i&lt;=0;i++)	preMax[i]=max(preMax[i-1],s[i]);

sufMin 的写法，从右往左遍历，sufMin[] = [1, 1, 2, 2, 2]
vector&lt;int&gt; sufMin(n+1);
sufMin[n] = s[n];  
for (int i = n - 1; i &gt;= 0; i--) &#123;
    sufMin[i] = min(sufMin[i + 1], s[i]);  
&#125;

sufMax 的写法，从右往左遍历，sufMax[] = [5, 5, 5, 5, 2]
vector&lt;int&gt; sufMax(n+1);
sufMax[n] = s[n]; 
for (int i = n - 1; i &gt;= 0; i--) &#123;
    sufMax[i] = max(sufMax[i + 1], s[i]);  
&#125;

<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta">  <br>- 例子分析：<br>  - 假设 `A = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]`，要求找到连续子数组的和等于 `k = <span class="hljs-number">3</span>` 的子数组个数。<br>  - **思路**：我们可以利用前缀和将问题转换为寻找满足条件的区间，通过记录前缀和的变化，使用哈希表来高效解决问题。所以只需用一个计数数组或 hash map 维护S中每个值的个数，枚举右端点 i，看一下等于S[i]-k 的值有几个就行了<br>  <br><span class="hljs-meta">### 2. **实现代码（子数组和问题）**：</span><br>  - **代码**：<br>    <br>    ```java<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> numOfSubarrays(vertor&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.size();<br>        vertor&lt;<span class="hljs-built_in">int</span>&gt; s(n+<span class="hljs-number">1</span>); <span class="hljs-comment">// 前缀和数组s(0-n)</span><br>        s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">var</span> <span class="hljs-keyword">count</span> = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;(); <span class="hljs-comment">// 用于记录前缀和出现的次数</span><br>        <span class="hljs-keyword">count</span>.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始前缀和为0时，计数为1</span><br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;s[i] = s[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>]%<span class="hljs-number">2</span>;&#125; <span class="hljs-comment">// 计算前缀和&#125;</span><br>        vertor&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">count</span>(n+<span class="hljs-number">1</span>); <span class="hljs-comment">//0-n</span><br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">count</span>[s[<span class="hljs-number">0</span>]]++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;=n ; i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i]-k&gt;=<span class="hljs-number">0</span>)&#123;ans+=<span class="hljs-keyword">count</span>[s[i]-k];&#125;<br>            <span class="hljs-keyword">count</span>[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>解析</strong>：</p>
<ul>
<li><code>sums[i]</code> 表示到数组的第 <code>i</code> 个元素的前缀和。</li>
<li>哈希表 <code>count</code> 用来存储每个前缀和出现的次数。</li>
<li>对于每个位置 <code>i</code>，我们查看是否存在某个前缀和 <code>sums[j]</code>，使得 <code>sums[i] - sums[j] = k</code>。如果存在，则说明从 <code>j</code> 到 <code>i</code> 的子数组和为 <code>k</code>，将符合条件的子数组计数加一。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-最大子数组和问题（Max-Subarray-Sum-Problem）："><a href="#3-最大子数组和问题（Max-Subarray-Sum-Problem）：" class="headerlink" title="3. 最大子数组和问题（Max Subarray Sum Problem）："></a>3. <strong>最大子数组和问题（Max Subarray Sum Problem）</strong>：</h3><ul>
<li><p>问题描述：给定一个整数数组，要求找到其最大子数组的和。子数组的定义是数组中连续的一部分元素。</p>
</li>
<li><p><strong>思路</strong>：</p>
<ul>
<li>可以通过前缀和的方式来求解最大子数组和问题。</li>
<li>同时我们需要一个 <code>preMin</code> 数组来记录当前子数组的前缀和中的最小值，以便在当前区间进行减法操作时，获得可能的最大子数组和。</li>
</ul>
</li>
</ul>
<h3 id="4-实现代码（最大子数组和问题）："><a href="#4-实现代码（最大子数组和问题）：" class="headerlink" title="4. 实现代码（最大子数组和问题）："></a>4. <strong>实现代码（最大子数组和问题）</strong>：</h3><ul>
<li><strong>代码</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-type">int</span>[] preMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 前缀最小值数组</span><br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s[i] = s[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算前缀和</span><br>    &#125;<br>    preMin[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>]; <span class="hljs-comment">//preMin书写模版</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        preMin[i] = Math.min(preMin[i-<span class="hljs-number">1</span>], s[i]); <span class="hljs-comment">// 维护前缀最小值</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>; <span class="hljs-comment">// 初始化答案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = Math.max(ans, s[i] - preMin[i-<span class="hljs-number">1</span>]); <span class="hljs-comment">// 计算最大子数组和 从一开始</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>解析</strong>：<ul>
<li>前缀和数组 <code>s[i]</code> 存储的是从数组开头到第 <code>i</code> 个元素的累加和。</li>
<li><code>preMin[i]</code> 数组存储的是从开头到第 <code>i</code> 个元素的前缀和中的最小值。</li>
<li>每次在计算 <code>s[i]</code> 时，通过减去当前区间的最小前缀和 <code>preMin[i-1]</code>，就可以得到从某个区间到 <code>i</code> 的最大子数组和。</li>
</ul>
</li>
</ul>
<h3 id="5-额外注释和细节："><a href="#5-额外注释和细节：" class="headerlink" title="5. 额外注释和细节："></a>5. <strong>额外注释和细节</strong>：</h3><ul>
<li>在 <strong>子数组和问题</strong> 中，哈希表 <code>count</code> 的作用非常关键，它可以快速定位前缀和的差值是否已经出现过，并通过查找差值来确定是否存在满足条件的子数组。</li>
<li><strong>前缀和法的核心</strong>：将原始问题中的区间和转换为前缀和的差值问题，进而简化计算，达到提高效率的目的。</li>
<li>在 <strong>最大子数组和问题</strong> 中，通过维护一个 <code>preMin</code> 数组来保存当前子数组的最小前缀和，从而可以通过差值来计算最大和。</li>
<li>代码中的 <code>Math.min</code> 和 <code>Math.max</code> 是用于动态更新当前最优的结果。</li>
<li>详细讲解了如何通过前缀和数组快速计算区间和。</li>
<li>针对不同问题，给出了具体的代码实现并且逐步进行了分析。</li>
<li>重点强调了利用 <code>HashMap</code>（哈希表） 来高效存储和查找前缀和，以及如何动态维护前缀和中的最小值。：</li>
</ul>
<h3 id="一维前缀和及其应用："><a href="#一维前缀和及其应用：" class="headerlink" title="一维前缀和及其应用："></a>一维前缀和及其应用：</h3><ul>
<li>在前面的笔记中，我们介绍了<strong>一维前缀和</strong>的概念以及如何利用前缀和来快速解决区间和问题，特别是对于子数组和等于某个目标值的计数问题，我们使用了前缀和和哈希表结合的方法进行高效解答。此外，<strong>最大子数组和问题</strong>通过前缀和与最小前缀和的差值计算得出答案。</li>
</ul>
<h3 id="二维前缀和（2D-Prefix-Sum）："><a href="#二维前缀和（2D-Prefix-Sum）：" class="headerlink" title="二维前缀和（2D Prefix Sum）："></a>二维前缀和（2D Prefix Sum）：</h3><ul>
<li><p>在本部分的笔记中，前缀和的概念被推广到了二维情况。二维前缀和 <code>S[i][j]</code> 表示的是从矩阵左上角 <code>(1, 1)</code> 到当前坐标 <code>(i, j)</code> 的所有元素的累加和，这一概念让我们能够快速计算任意矩形区域内的元素和。</p>
</li>
<li><p>类似于一维前缀和的区间和公式，二维前缀和的矩形区域和通过前缀和数组快速求解，避免了重复计算。计算区域 <code>(p, q)</code> 到 <code>(i, j)</code> 的矩形区域和的公式为：</p>
<ul>
<li><code>sum(p, q, i, j) = S[i][j] - S[i][q-1] - S[p-1][j] + S[p-1][q-1]</code></li>
</ul>
</li>
<li><p>这种方式不仅能快速处理问题，还能提升算法的时间复杂度，尤其适合处理较大规模的矩阵求和问题。</p>
</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs inform7">二维区域的和<br>public NumMatrix(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> matrix) &#123;<br>    int n = matrix.length;<br>    int m = matrix<span class="hljs-comment">[0]</span>.length;<br>    sum = new int<span class="hljs-comment">[n + 1]</span><span class="hljs-comment">[m + 1]</span>;<br><br>    for (int i = 1; i &lt;= n; i++) &#123;<br>        for (int j = 1; j &lt;= m; j++) &#123;<br>            sum<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = sum<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + sum<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span> - sum<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> + matrix<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>public int sumRegion(int row1, int col1, int row2, int col2) &#123;<br>    row1 += 1;<br>    col1 += 1;<br>    row2 += 1;<br>    col2 += 1;<br><br>    return sum<span class="hljs-comment">[row2]</span><span class="hljs-comment">[col2]</span> - sum<span class="hljs-comment">[row1 - 1]</span><span class="hljs-comment">[col2]</span> - sum<span class="hljs-comment">[row2]</span><span class="hljs-comment">[col1 - 1]</span> + sum<span class="hljs-comment">[row1 - 1]</span><span class="hljs-comment">[col1 - 1]</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="差分数组及其应用："><a href="#差分数组及其应用：" class="headerlink" title="差分数组及其应用："></a>差分数组及其应用：</h3><p>总结：把 A的第!个数到第r个数加 d，B 的变化为:B;加 d，B,+ 减d，它比较适用于我们想把一段儿-个子段都加一个值的时候。比如我们想把a的dl到底I个数啊啊|到r这个字段都加一个数d。</p>
<ul>
<li><p><strong>差分数组</strong>的引入则为高效区间更新提供了一种新的方法。在解决大规模区间更新问题时，如果直接对原数组进行操作，时间复杂度会比较高，而差分数组通过记录相邻元素之间的差值，在常数时间内更新区间，最后通过前缀和恢复原数组。</p>
</li>
<li><p>例如，在航班预定问题中，差分数组 <code>id</code> 被用来记录每个区间的变化量，最终通过前缀和恢复预定后的航班乘客数量。</p>
</li>
<li><p>差分数组的本质是通过对局部变化的记录和累积，使得区间更新可以在 O(1) 时间内完成，极大优化了需要频繁进行更新操作的场景。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">book</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bookings, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; booking : bookings) &#123;<br>            <span class="hljs-type">int</span> a = booking[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> b = booking[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> c = booking[<span class="hljs-number">2</span>];<br>            id[a] += c;<br>            id[b + <span class="hljs-number">1</span>] -= c;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + id[i];<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            answer[i - <span class="hljs-number">1</span>] = sum[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="综合总结："><a href="#综合总结：" class="headerlink" title="综合总结："></a>综合总结：</h3><ol>
<li><strong>一维前缀和</strong>解决了基本的区间和问题，同时通过哈希表等技巧，可以处理子数组和计数等高级问题。</li>
<li><strong>二维前缀和</strong>将这一思想推广到矩阵，能够快速求解矩形区域和问题，极大提高了处理二维数据的效率。</li>
<li><strong>差分数组</strong>则提供了高效的区间更新方法，特别适合于需要多次区间操作的场景，在减少时间复杂度方面有显著优势。</li>
</ol>
<hr>
<h1 id="七-双指针"><a href="#七-双指针" class="headerlink" title="七.双指针"></a>七.双指针</h1><h3 id="1-双指针算法的核心思想："><a href="#1-双指针算法的核心思想：" class="headerlink" title="1. 双指针算法的核心思想："></a><strong>1. 双指针算法的核心思想</strong>：</h3><ul>
<li><p><strong>定义</strong>：双指针法是通过两个指针从不同方向（常见的是一头一尾）同时进行遍历，进而达到降低时间复杂度的目的。这种方法尤其适合在有序数组或特定问题中使用，通过一左一右或一前一后两个指针逼近来找到符合条件的解。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ol>
<li><strong>有序数组的查找问题</strong>：在一个排序好的数组中，利用双指针可以快速确定满足条件的两个或多个元素，典型的例子是“两数之和”。</li>
<li><strong>区间内查找问题</strong>：通过双指针从区间两端逐渐缩小范围，避免重复遍历。比如“盛水最多的容器问题”。</li>
<li><strong>多元素组合问题</strong>：像“三数之和”问题，通过固定一个数，再使用双指针寻找另外两个数的组合。</li>
</ol>
</li>
</ul>
<h3 id="2-两数之和问题："><a href="#2-两数之和问题：" class="headerlink" title="2. 两数之和问题："></a><strong>2. 两数之和问题</strong>：</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个有序数组，找到两个数，使得它们的和等于目标值 <code>target</code>。返回这两个数的下标，假定数组内没有重复解。</p>
<h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a><strong>思路分析</strong>：</h4><ul>
<li>因为数组已经排序，直接使用双指针从头和尾同时进行遍历：<ul>
<li>如果左右两指针的元素之和 <code>numbers[i] + numbers[j]</code> 等于目标值，则返回结果。</li>
<li>如果和小于目标值，则左指针右移增加和；</li>
<li>如果和大于目标值，则右指针左移减小和。</li>
</ul>
</li>
<li>该方法的时间复杂度是 O(n)，相比于暴力枚举的 O(n²) 更加高效。</li>
</ul>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入有序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 两个指针从数组两端开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; numbers[i]+numbers[j]&gt;target)	j--;<br>        <span class="hljs-keyword">if</span> (i&lt;j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>            reture &#123;i<span class="hljs-number">+1</span>,j<span class="hljs-number">+1</span>&#125;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;<br><br>输入无序<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; pairs;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        pairs.<span class="hljs-built_in">push</span>(&#123;num[i],i&#125;);  <br>    &#125;<br>    <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(),pairs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> j = pairs.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;pairs.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first&gt;target)	j--;<br>        <span class="hljs-keyword">if</span>(i&lt;j &amp;&amp; pairs[i].first+pairs.first==target)&#123;<br>            <span class="hljs-keyword">return</span> &#123;pairs[i],second , pairs[j].second&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// 未找到目标值，返回空结果</span><br>&#125;  <br></code></pre></td></tr></table></figure>

<h4 id="细节与优化："><a href="#细节与优化：" class="headerlink" title="细节与优化："></a><strong>细节与优化</strong>：</h4><ul>
<li><strong>时间复杂度</strong>：排序数组直接使用双指针只需遍历一次，时间复杂度为 O(n)，非常高效。</li>
<li><strong>边界条件</strong>：确保 <code>i &lt; j</code>，即两个指针不能重叠，避免重复或错误的索引访问。</li>
</ul>
<hr>
<h3 id="3-三数之和问题："><a href="#3-三数之和问题：" class="headerlink" title="3. 三数之和问题："></a><strong>3. 三数之和问题</strong>：</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个数组 <code>nums</code>，找出其中的三个数，使得它们的和为 0。可以假设数组中没有重复解。</p>
<h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a><strong>思路分析</strong>：</h4><ul>
<li><p><strong>固定一个数，求剩下两数之和</strong>：</p>
<ol>
<li>先对数组进行排序，便于使用双指针法。</li>
<li>从第一个元素开始，依次固定一个数 <code>nums[i]</code>，接着利用双指针在剩下的数组部分中寻找两数之和为 <code>-nums[i]</code> 的数对。</li>
<li>为了避免重复解，固定的数和双指针处理时需要跳过相同的元素。</li>
</ol>
</li>
<li><p><strong>详细步骤</strong>：</p>
<ol>
<li>排序数组。</li>
<li>遍历数组中的每一个元素，固定 <code>nums[i]</code>。</li>
<li>在 <code>i</code> 之后的元素中用双指针寻找和为 <code>-nums[i]</code> 的数对。</li>
<li>如果找到满足条件的数对，记录下来，继续遍历时跳过重复元素。</li>
</ol>
</li>
</ul>
<h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; jks = <span class="hljs-built_in">twoSum</span>(nums, i + <span class="hljs-number">1</span>, -nums[i]);<br>            <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; jk : jks) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], jk[<span class="hljs-number">0</span>], jk[<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target) j--;<br>            <span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; numbers[i] + numbers[j] == target) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;numbers[i], numbers[j]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="优化与细节："><a href="#优化与细节：" class="headerlink" title="优化与细节："></a><strong>优化与细节</strong>：</h4><ul>
<li><strong>去重处理</strong>：为了避免重复解，固定数和双指针都需要跳过重复的元素。例如，固定数 <code>nums[i]</code> 相同的情况不再处理，双指针的 <code>nums[j]</code> 和 <code>nums[k]</code> 也需要处理重复的情况。</li>
<li><strong>时间复杂度</strong>：排序时间复杂度为 O(nlogn)，之后遍历和双指针查找的时间复杂度是 O(n²)，总体复杂度为 O(n²)。</li>
</ul>
<hr>
<h3 id="4-盛水最多的容器问题："><a href="#4-盛水最多的容器问题：" class="headerlink" title="4. 盛水最多的容器问题："></a><strong>4. 盛水最多的容器问题</strong>：</h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h4><p>给定一个数组 <code>height</code>，其中每个元素代表容器壁的高度，找到两个容器壁，使得它们与 X 轴构成的容器能盛最多的水。</p>
<h4 id="思路分析：-2"><a href="#思路分析：-2" class="headerlink" title="思路分析："></a><strong>思路分析</strong>：</h4><ul>
<li><strong>双指针法</strong>：<ol>
<li>通过两个指针分别指向数组的最左和最右位置。</li>
<li>每次计算两根柱子之间的容积：<code>min(height[i], height[j]) * (j - i)</code>。</li>
<li>为了使盛水的容量最大，移动较短的一端指针，试图找到更高的柱子，从而获得更大的面积。</li>
</ol>
</li>
</ul>
<h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>        <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) i++;<br>        <span class="hljs-keyword">else</span> j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="优化与细节：-1"><a href="#优化与细节：-1" class="headerlink" title="优化与细节："></a><strong>优化与细节</strong>：</h4><ul>
<li><strong>双指针法的精髓</strong>：通过移动较短的一端，不断调整容器两壁的位置，试图找到盛水的最大面积。</li>
<li><strong>时间复杂度</strong>：由于只需遍历一次，时间复杂度为 O(n)，是一种高效的解法。</li>
</ul>
<hr>
<h3 id="5-笔记中的重要提示："><a href="#5-笔记中的重要提示：" class="headerlink" title="5. 笔记中的重要提示："></a><strong>5. 笔记中的重要提示</strong>：</h3><h4 id="双指针的本质："><a href="#双指针的本质：" class="headerlink" title="双指针的本质："></a><strong>双指针的本质</strong>：</h4><ul>
<li>双指针的核心思想是通过对称的方式从两端或从不同方向移动，能够在保持线性时间复杂度的同时解决较为复杂的问题，如查找和、最优解等。</li>
<li>无论是“两数之和”、“三数之和”还是“盛水最多的容器”，都通过双指针在适当的场景下提高效率，避免了暴力解法的高时间复杂度。</li>
</ul>
<h4 id="关键细节总结："><a href="#关键细节总结：" class="headerlink" title="关键细节总结："></a><strong>关键细节总结</strong>：</h4><ul>
<li>在处理“两数之和”和“三数之和”问题时，注意通过排序和去重来简化问题，避免重复计算和解的重复。</li>
<li>对于“盛水最多的容器”问题，利用双指针的对称移动特性，可以在 O(n) 时间内获得最优解。</li>
</ul>
<hr>
<p>比较前缀和，差分，双指针，滑动窗口，单调栈各自适用的情况</p>
<ol>
<li>前缀和（Prefix Sum）<br>适用情况：<br>快速计算数组某个子区间的和：适用于需要多次计算数组某个区间和的场景。<br>区间查询和更新较少：适合静态数组或查询操作远多于更新操作的情况。</li>
<li>差分（Difference Array）<br>适用情况：<br>快速进行区间修改：适用于需要频繁对数组某个区间进行加减操作的场景。<br>需要高效进行批量更新：适合大规模区间更新操作。</li>
<li>双指针（Two Pointers）<br>适用情况：<br>处理有序数组：适用于需要在有序数组或链表中查找、遍历等操作。<br>解决滑动窗口问题：适合在数组或字符串上维护动态区间的问题。</li>
<li>滑动窗口（Sliding Window）<br>适用情况：<br>子数组问题：适用于需要找到数组中满足特定条件的子数组或子字符串的问题。<br>连续子区间：适合处理需要计算连续子区间的问题。</li>
<li>单调栈（Monotonic Stack）<br>适用情况：<br>找到数组中每个元素的下一个更大（或更小）元素：适用于需要在数组中找到特定方向上的极值问题。<br>维护区间单调性：适合处理需要保持区间单调性的问题。</li>
</ol>
<hr>
<h1 id="八-递归"><a href="#八-递归" class="headerlink" title="八.递归"></a>八.递归</h1><h3 id="1-回溯法的核心思想："><a href="#1-回溯法的核心思想：" class="headerlink" title="1. 回溯法的核心思想："></a><strong>1. 回溯法的核心思想</strong>：</h3><ul>
<li><strong>定义</strong>：回溯法是一种通过递归逐步生成解空间，遇到不满足条件时及时回溯到上一个状态的算法，通常用于解决排列组合、子集、路径等问题。</li>
<li><strong>基本框架</strong>：<ul>
<li>注意语意,即这个函数解决的问题,这些代码在当前进程的操作,调用函数相当于开了一个新进程</li>
<li>定义递归的边界</li>
<li>保护还原现场</li>
</ul>
</li>
</ul>
<h1 id="三个模版"><a href="#三个模版" class="headerlink" title="三个模版"></a>三个模版</h1><h3 id="子集问题（Subsets）："><a href="#子集问题（Subsets）：" class="headerlink" title="子集问题（Subsets）："></a><strong>子集问题（Subsets）</strong>：</h3><p>给定一个数组 <code>nums</code>，要求生成所有的子集。</p>
<h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归生成子集</strong>：<ul>
<li>每次递归选择是否将当前元素加入子集。</li>
<li>遍历整个数组，生成所有可能的子集。</li>
</ul>
</li>
<li><strong>回溯的实现</strong>：<ul>
<li>使用一个 <code>chosen</code> 数组保存当前已经选择的元素，递归时选择是否添加当前元素，完成后回溯（撤销选择）。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">recur</span>(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == n) &#123; <span class="hljs-comment">// 递归终止条件</span><br>            ans.<span class="hljs-built_in">push_back</span>(chosen);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 递归不选当前元素</span><br>        <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 递归选择当前元素</span><br>        chosen.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">recur</span>(nums, i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 撤销选择</span><br>        chosen.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br></code></pre></td></tr></table></figure>

<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>回溯过程</strong>：递归的过程中不断选择是否包含当前元素，形成子集。每当一个选择完成后，回溯撤销上一步的选择，继续探索下一个可能的解。</li>
<li><strong>时间复杂度</strong>：O(2^n)，每个元素都有两种选择（选择或不选择）。</li>
</ul>
<hr>
<h3 id="组合问题（Combinations）："><a href="#组合问题（Combinations）：" class="headerlink" title="组合问题（Combinations）："></a>组合问题（Combinations）：</h3><p>给定整数 <code>n</code> 和 <code>k</code>，从 <code>[1, 2, ..., n]</code> 中选择 <code>k</code> 个数的所有组合。</p>
<h4 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归生成组合</strong>：<ul>
<li>遍历 <code>[1, n]</code> 中的每一个数，每次递归选择或不选择该数，直到选满 <code>k</code> 个数。</li>
<li>剪枝优化：当剩下的元素数量不足以填满 <code>k</code> 个数时可以提前结束递归。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-built_in">recur</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-comment">// 剪枝条件</span><br>        <span class="hljs-keyword">if</span> (chosen.<span class="hljs-built_in">size</span>() + (n - i + <span class="hljs-number">1</span>) &lt; k) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (i == n + <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(chosen);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不选当前元素</span><br>        <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 选择当前元素</span><br>        chosen.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">recur</span>(i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 撤销选择</span><br>        chosen.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> n, k;<br>    vector&lt;<span class="hljs-type">int</span>&gt; chosen;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br></code></pre></td></tr></table></figure>

<h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>递归选择与回溯</strong>：从 <code>1</code> 到 <code>n</code> 的数中逐个选择，直到选满 <code>k</code> 个数，每次选择完后回溯撤销选择。</li>
<li><strong>剪枝优化</strong>：当剩余数不足 <code>k - chosen.size()</code> 时，直接结束递归，避免无效操作。</li>
<li><strong>时间复杂度</strong>：O(C(n, k))，组合数的复杂度。</li>
</ul>
<hr>
<h3 id="全排列问题（Permutations）："><a href="#全排列问题（Permutations）：" class="headerlink" title="全排列问题（Permutations）："></a><strong>全排列问题（Permutations）</strong>：</h3><p>给定一个不包含重复数字的数组 <code>nums</code>，要求生成所有可能的全排列。</p>
<h4 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归生成全排列</strong>：<ul>
<li>每次递归选择一个尚未使用的数，直到所有数都被选过。</li>
<li>使用一个布尔数组 <code>used</code> 来标记哪些数已经被使用，防止重复使用。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    n = nums.<span class="hljs-built_in">size</span>();<br>    used = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt; (n,<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">recur</span>(nums,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">private</span>：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos == n) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(a);  <span class="hljs-comment">// 找到一个排列</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>            a.push_back)(num[i]);<br>            used[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记为使用</span><br>            <span class="hljs-built_in">recur</span>(nums, pos + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 递归下一层</span><br>            used[i] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 标记为未使用</span><br>            a.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; used;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    <span class="hljs-type">int</span> a;<br>    vector &lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>回溯与排列</strong>：每次递归选择一个未使用的数，直到所有数都被选过，形成一个排列。回溯时撤销选择并将数标记为未使用。</li>
<li><strong>时间复杂度</strong>：O(n!)，全排列的复杂度，每次递归需要遍历未使用的元素。</li>
</ul>
<hr>
<h3 id="反转二叉树（Invert-Binary-Tree）："><a href="#反转二叉树（Invert-Binary-Tree）：" class="headerlink" title="反转二叉树（Invert Binary Tree）："></a><strong>反转二叉树（Invert Binary Tree）</strong>：</h3><p>该问题要求对一个二叉树进行左右子树的交换。</p>
<h4 id="算法思路：-3"><a href="#算法思路：-3" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归反转左右子树</strong>：<ul>
<li>对当前节点的左右子树递归交换。</li>
<li>递归终止条件是当前节点为空。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-6"><a href="#代码实现：-6" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 空节点返回</span><br>    TreeNode* temp = root-&gt;left;  <span class="hljs-comment">// 交换左右子树</span><br>    root-&gt;left = root-&gt;right;<br>    root-&gt;right = temp;<br>    <span class="hljs-built_in">invertTree</span>(root-&gt;left);  <span class="hljs-comment">// 递归反转左子树</span><br>    <span class="hljs-built_in">invertTree</span>(root-&gt;right);  <span class="hljs-comment">// 递归反转右子树</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>递归反转过程</strong>：从根节点开始，对每个节点的左右子树进行交换，并递归处理子树。</li>
<li><strong>时间复杂度</strong>：O(n)，每个节点遍历一次。</li>
</ul>
<h3 id="6-总结："><a href="#6-总结：" class="headerlink" title="6. 总结："></a><strong>6. 总结</strong>：</h3><ul>
<li><strong>回溯法</strong>是一种经典的递归算法，适用于组合、排列、子集等问题。其核心思想是在递归过程中通过试探的方式逐步生成解，遇到不满足条件的解时回溯到上一步重新尝试。</li>
<li><strong>子集与组合</strong>：通过回溯生成所有可能的子集或组合，并在递归过程中进行剪枝优化。</li>
<li><strong>全排列</strong>：回溯法生成全排列时，需要通过标记已使用的元素来避免重复使用元素。</li>
<li><strong>二叉树的递归操作</strong>：类似反转二叉树等问题可以通过递归方式简化操作，每次递归处理左右子树即可。</li>
</ul>
<p>这些笔记展示了回溯法在多种问题中的应用，并提供了相应的递归实现。</p>
<hr>
<h1 id="九-分治"><a href="#九-分治" class="headerlink" title="九.分治"></a>九.分治</h1><h3 id="1-分治算法（Divide-and-Conquer）："><a href="#1-分治算法（Divide-and-Conquer）：" class="headerlink" title="1. 分治算法（Divide and Conquer）："></a><strong>1. 分治算法（Divide and Conquer）</strong>：</h3><ul>
<li><strong>定义</strong>：将原问题划分为若干个相同或相似的子问题，递归求解子问题，然后将各个子问题的解合并成原问题的解。</li>
<li><strong>应用场景</strong>：分治法常用于大规模问题的解决，比如快速排序、归并排序、矩阵乘法等。</li>
<li><strong>要点</strong>：<ul>
<li>将问题分成若干子问题；</li>
<li>分别递归求解每个子问题；</li>
<li>合并子问题的解得到最终解。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-递归实现-pow-x-n-问题："><a href="#2-递归实现-pow-x-n-问题：" class="headerlink" title="2. 递归实现 pow(x, n) 问题："></a><strong>2. 递归实现 <code>pow(x, n)</code> 问题</strong>：</h3><p>计算 <code>x</code> 的 <code>n</code> 次方。</p>
<h4 id="算法思路：-4"><a href="#算法思路：-4" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li><strong>递归公式</strong>：<ul>
<li>如果 <code>n</code> 为偶数，<code>pow(x, n) = pow(x, n / 2) * pow(x, n / 2)</code>。</li>
<li>如果 <code>n</code> 为奇数，<code>pow(x, n) = pow(x, (n - 1) / 2) * pow(x, (n - 1) / 2) * x</code>。</li>
<li>如果 <code>n</code> 为负数，则 <code>pow(x, n) = 1 / pow(x, -n)</code>。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-7"><a href="#代码实现：-7" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 任何数的 0 次方都等于 1</span><br>    <span class="hljs-keyword">if</span> (n == INT_MIN) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">myPow</span>(x, -(n<span class="hljs-number">+1</span>)) * x);  <span class="hljs-comment">// 处理 n 为最小负数的特殊情况</span><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / <span class="hljs-built_in">myPow</span>(x, -n);  <span class="hljs-comment">// 负数次幂</span><br>    <span class="hljs-type">double</span> temp = <span class="hljs-built_in">myPow</span>(x, n / <span class="hljs-number">2</span>);  <span class="hljs-comment">// 递归计算</span><br>    <span class="hljs-type">double</span> ans = temp * temp;  <span class="hljs-comment">// 平方</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ans *= x;  <span class="hljs-comment">// 处理奇数次幂</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>时间复杂度</strong>：O(log n)，递归每次将 <code>n</code> 减半。</li>
<li><strong>空间复杂度</strong>：O(log n)，递归调用栈的深度。</li>
</ul>
<hr>
<h3 id="3-括号生成问题（Generate-Parentheses）："><a href="#3-括号生成问题（Generate-Parentheses）：" class="headerlink" title="3. 括号生成问题（Generate Parentheses）："></a><strong>3. 括号生成问题（Generate Parentheses）</strong>：</h3><p>给定整数 <code>n</code>，生成所有可能的包含 <code>n</code> 对括号的有效组合。</p>
<h4 id="算法思路：-5"><a href="#算法思路：-5" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>使用递归生成所有括号组合，依次生成 <code>k</code> 对括号与 <code>n-k</code> 对括号的组合，再将它们合并。</li>
<li><strong>递归优化</strong>：通过 <code>unordered_map</code> 缓存中间结果，避免重复计算（记忆化搜索）。</li>
<li>设生成的括号组合可以看作 <code>S = (A)B</code>其中 <code>A</code> 是在 <code>k-1</code> 对括号的基础上生成的组合，<code>B</code> 是在 <code>n-k</code> 对括号的基础上生成的组合。</li>
</ul>
<h4 id="代码实现：-8"><a href="#代码实现：-8" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;  <span class="hljs-comment">// 基本情况，n=0时返回空字符串</span><br>    <span class="hljs-keyword">if</span> (store.<span class="hljs-built_in">find</span>(n) != store.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> store[n];  <span class="hljs-comment">// 如果已经计算过，直接返回缓存的结果</span><br>    <br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;  <span class="hljs-comment">// 遍历所有可能的 k 值(A)B</span><br>        vector&lt;string&gt; A = <span class="hljs-built_in">generateParenthesis</span>(k - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 生成 k-1 对括号</span><br>        vector&lt;string&gt; B = <span class="hljs-built_in">generateParenthesis</span>(n - k);  <span class="hljs-comment">// 生成 n-k 对括号</span><br>        <span class="hljs-keyword">for</span> (string&amp; a : A) &#123;<br>            <span class="hljs-keyword">for</span> (string&amp; b : B) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;(&quot;</span> + a + <span class="hljs-string">&quot;)&quot;</span> + b);  <span class="hljs-comment">// 将两部分组合</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    store[n] = ans;  <span class="hljs-comment">// 缓存当前 n 对括号的所有组合</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;string&gt;&gt; store;  <span class="hljs-comment">// 用于记忆化搜索，避免重复计算</span><br></code></pre></td></tr></table></figure>

<h4 id="分析：-5"><a href="#分析：-5" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>记忆化搜索</strong>：通过 <code>unordered_map</code> 缓存递归中间结果，避免重复计算，提升效率。</li>
<li><strong>时间复杂度</strong>：理论上为 O(4^n &#x2F; sqrt(n))，因为每次递归生成所有可能的括号组合。</li>
</ul>
<hr>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4. 总结："></a><strong>4. 总结</strong>：</h3><ul>
<li><strong>分治法</strong>是一种强大的算法思想，适用于将大问题分解为小问题的场景，通过递归求解小问题来解决大问题。</li>
<li><strong>递归优化</strong>：在实现递归算法时，可以通过<strong>记忆化搜索</strong>等方式来优化重复计算问题，大大提升算法的效率。</li>
<li><strong>递归框架</strong>：很多复杂问题都可以通过递归分解为子问题来解决，比如 <code>pow</code> 问题通过递归将指数减半、括号生成问题通过递归生成不同数量括号的组合等。</li>
</ul>
<hr>
<h1 id="十-二叉树"><a href="#十-二叉树" class="headerlink" title="十.二叉树"></a>十.二叉树</h1><h3 id="1-二叉树的定义和遍历方式："><a href="#1-二叉树的定义和遍历方式：" class="headerlink" title="1. 二叉树的定义和遍历方式："></a>1. 二叉树的定义和遍历方式：</h3><ul>
<li>二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。</li>
<li><strong>遍历方式</strong>：<ul>
<li><strong>前序遍历</strong>（Pre-order Traversal）：按根节点 -&gt; 左子树 -&gt; 右子树的顺序遍历。</li>
<li><strong>中序遍历</strong>（In-order Traversal）：按左子树 -&gt; 根节点 -&gt; 右子树的顺序遍历。</li>
<li><strong>后序遍历</strong>（Post-order Traversal）：按左子树 -&gt; 右子树 -&gt; 根节点的顺序遍历。</li>
<li><strong>层次遍历</strong>（Level-order Traversal）：按层从上到下、从左到右的顺序遍历树节点。</li>
</ul>
</li>
</ul>
<h4 id="遍历方式总结："><a href="#遍历方式总结：" class="headerlink" title="遍历方式总结："></a><strong>遍历方式总结</strong>：</h4><h3 id="中序遍历的递归实现："><a href="#中序遍历的递归实现：" class="headerlink" title="中序遍历的递归实现："></a><strong>中序遍历的递归实现</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; seq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> seq;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    seq.add(root.val);<br>    dfs(root.left);<br>    dfs(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong>：使用递归的方式遍历树，先访问当前节点，然后递归访问左子树和右子树。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h3 id="前序遍历的递归实现："><a href="#前序遍历的递归实现：" class="headerlink" title="前序遍历的递归实现："></a><strong>前序遍历的递归实现</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span> <span class="hljs-params">(Node root)</span> &#123;<br>    seq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    dfs (root);<br>    <span class="hljs-keyword">return</span> seq;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span> <span class="hljs-params">(CNode root)</span> &#123;<br>    seq.add (root.val);<br>    <span class="hljs-keyword">for</span> (CNode child : root.children) &#123;<br>        dfs (child);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong>：先递归遍历左子树，再递归遍历右子树，最后访问根节点。</li>
</ul>
<h3 id="4-树的层次遍历（广度优先搜索）："><a href="#4-树的层次遍历（广度优先搜索）：" class="headerlink" title="4. 树的层次遍历（广度优先搜索）："></a><strong>4. 树的层次遍历（广度优先搜索）</strong>：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">Order</span> <span class="hljs-params">(Node root)</span> &#123;<br>    Queue&lt;Pair&lt;Node, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Pair&lt;Node, Integer&gt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; seq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == NULL) <span class="hljs-keyword">return</span> seq;<br>    q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Node, Integer&gt;(root, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> q.peek().getKey();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> q.poll().getValue();<br>        <span class="hljs-keyword">if</span> (depth &gt;= seq.size()) seq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        seq.get(depth).add(node.val);<br>        <span class="hljs-keyword">for</span> (Node child : node.children) &#123;<br>            q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Node, Integer&gt;(child, depth + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>思路</strong>：使用队列辅助实现层次遍历，每次取出一个节点，并将其所有子节点加入队列。遍历每一层时记录该层的深度。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h3 id="根据前序遍历和中序遍历重建二叉树："><a href="#根据前序遍历和中序遍历重建二叉树：" class="headerlink" title="根据前序遍历和中序遍历重建二叉树："></a><strong>根据前序遍历和中序遍历重建二叉树</strong>：</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>给定二叉树的前序遍历和中序遍历，重建这棵二叉树。</p>
<h4 id="算法思路：-6"><a href="#算法思路：-6" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>前序遍历的第一个节点是根节点。</li>
<li>在中序遍历中找到根节点的位置，根节点左边的部分是左子树，右边的部分是右子树。</li>
<li>递归构建左子树和右子树。</li>
</ul>
<h4 id="代码实现：-9"><a href="#代码实现：-9" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>    <span class="hljs-built_in">this</span>.preorder = preorder;<br>    <span class="hljs-built_in">this</span>.inorder = inorder;<br>    <span class="hljs-keyword">return</span> build (<span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>&#125;<br><br>TreeNode <span class="hljs-title function_">build</span> <span class="hljs-params">(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l1 &gt; r1) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span> (preorder[l1]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l2;  <span class="hljs-comment">// 找到 root 在 inorder 中的位置</span><br>    <span class="hljs-keyword">while</span> (inorder[mid] != root.val) ++mid;  <span class="hljs-comment">// mid - l2 是左子树长度</span><br>    root.left = build (l1 + <span class="hljs-number">1</span>, l1 + mid - l2, l2, mid - <span class="hljs-number">1</span>);<br>    root.right = build (l1 + mid - l2 + <span class="hljs-number">1</span>, r1, mid + <span class="hljs-number">1</span>, r2);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>分析</strong>：<ul>
<li>前序遍历的第一个元素是当前子树的根节点。</li>
<li>在中序遍历中找到根节点，划分出左子树和右子树。</li>
<li>递归地对左右子树进行同样的处理。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
<h3 id="找到两个节点的最近公共祖先："><a href="#找到两个节点的最近公共祖先：" class="headerlink" title="找到两个节点的最近公共祖先："></a><strong>找到两个节点的最近公共祖先</strong>：</h3><h4 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>在二叉树中找到两个节点的最近公共祖先（LCA）。</p>
<h4 id="算法思路：-7"><a href="#算法思路：-7" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>对每个节点递归判断：<ul>
<li>如果节点等于 p 或 q，则返回当前节点。</li>
<li>如果左右子树分别找到了 p 和 q，则当前节点为最近公共祖先。</li>
<li>如果只有一侧找到 p 或 q，则返回这一侧的结果。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-10"><a href="#代码实现：-10" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>:<br>    TreeNode* Ansestor (TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-built_in">this</span> -&gt; p = p;<br>        <span class="hljs-built_in">this</span> -&gt; q = q;<br>        dfs (root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    TreeNode* p;<br>    TreeNode* q;<br>    TreeNode* ans;<br>    pair&lt;bool, bool&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;<br>        pair&lt;bool, bool&gt; leftResult = dfs (root -&gt; left);<br>        pair&lt;bool, bool&gt; rightResult = dfs (root -&gt; right);<br>        pair&lt;bool, bool&gt; result;<br>        result.first = leftResult.first || rightResult.first || root == p;<br>        result.second = leftResult.second || rightResult.second || root == q;<br>        <span class="hljs-keyword">if</span>(result.first &amp;&amp; result.second &amp;&amp; ans == nullptr) ans = root;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>分析</strong>：<ul>
<li>通过递归遍历整棵树，当一个节点的左右子树分别找到 p 和 q 时，该节点即为最近公共祖先。</li>
<li><strong>时间复杂度</strong>：O(n)，其中 n 为节点数量。</li>
</ul>
</li>
</ul>
<h3 id="7-笔记中还涉及的图和链表相关的补充知识："><a href="#7-笔记中还涉及的图和链表相关的补充知识：" class="headerlink" title="7. 笔记中还涉及的图和链表相关的补充知识："></a><strong>7. 笔记中还涉及的图和链表相关的补充知识</strong>：</h3><ul>
<li><strong>广度优先搜索（BFS）与深度优先搜索（DFS）</strong>：图的遍历方式类似于树的层次遍历和前序遍历。</li>
<li><strong>动态规划问题</strong>：如矩阵路径求解的动态规划方法，使用递推公式求解最短路径或最长路径问题。</li>
<li><strong>链表操作</strong>：涉及链表节点的插入、删除和反转操作，通常通过定义 <code>head</code> 指针和递归方法实现。</li>
</ul>
<hr>
<h1 id="十一-图"><a href="#十一-图" class="headerlink" title="十一.图"></a>十一.图</h1><h3 id="1-图的存储方式："><a href="#1-图的存储方式：" class="headerlink" title="1. 图的存储方式："></a><strong>1. 图的存储方式</strong>：</h3><p>图可以通过多种方式表示，常见的有：</p>
<ul>
<li><strong>邻接矩阵</strong>：<ul>
<li>使用二维数组 <code>graph[MAX_N][MAX_N]</code>，其中 <code>graph[x][y] = 1</code> 表示节点 <code>x</code> 与节点 <code>y</code> 之间有一条边。</li>
<li>适用于稠密图，但在处理稀疏图时会占用大量空间，复杂度为 O(N^2)。</li>
</ul>
</li>
<li><strong>邻接表</strong>：<ul>
<li>使用动态数组 <code>vector&lt;int&gt; graph[MAX_N]</code> 来存储邻接表，每个元素存储与该节点相邻的所有节点。</li>
<li>这种方式更适合稀疏图，复杂度为 O(M)，其中 M 是图中边的数量。</li>
</ul>
</li>
<li><strong>链式前向星</strong>：<ul>
<li>使用结构体数组来存储边的信息，每个边包含两个属性：<code>from</code> 和 <code>to</code> 表示边的起点和终点，以及 <code>next</code> 指向下一条边。</li>
<li><code>head</code> 数组用于记录每个顶点的第一条边。适合空间较紧张的情况。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-图的遍历："><a href="#2-图的遍历：" class="headerlink" title="2. 图的遍历："></a><strong>2. 图的遍历</strong>：</h3><p>图的遍历包括深度优先搜索（DFS）和广度优先搜索（BFS）。</p>
<h4 id="DFS（深度优先搜索）："><a href="#DFS（深度优先搜索）：" class="headerlink" title="DFS（深度优先搜索）："></a><strong>DFS（深度优先搜索）</strong>：</h4><ul>
<li><strong>递归实现</strong>：<ul>
<li>使用递归来实现 DFS，首先访问当前节点，然后递归访问与当前节点相连的节点。</li>
<li>常用于检测图中是否存在环、连通分量的统计等问题。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-11"><a href="#代码实现：-11" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点已访问</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, to, visited);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-环检测："><a href="#3-环检测：" class="headerlink" title="3. 环检测："></a><strong>3. 环检测</strong>：</h3><p>环检测是一个典型的图论问题，通常使用 DFS 来实现。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路</strong>：</h4><ul>
<li><strong>DFS 实现环检测</strong>：<ul>
<li>在进行 DFS 时，如果当前节点已经被访问过且是祖先节点，则说明存在环。</li>
</ul>
</li>
</ul>
<h4 id="代码实现：-12"><a href="#代码实现：-12" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> hasCycle = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; to, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; onPath)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记当前节点为已访问</span><br>    onPath[u] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点位于递归路径上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, to, visited, onPath);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (onPath[v]) &#123;<br>            hasCycle = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 检测到环</span><br>        &#125;<br>    &#125;<br>    onPath[u] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 递归结束后，移除路径上的节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-拓扑排序："><a href="#4-拓扑排序：" class="headerlink" title="4. 拓扑排序："></a><strong>4. 拓扑排序</strong>：</h3><p>拓扑排序是对有向无环图（DAG）节点的排序，使得对于每条边 <code>(u, v)</code>，节点 <code>u</code> 在节点 <code>v</code> 之前被排序。</p>
<h4 id="算法思路：-8"><a href="#算法思路：-8" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>拓扑排序可以通过<strong>广度优先搜索（BFS）</strong>和<strong>DFS</strong>实现。</li>
<li><strong>入度表</strong>：使用一个数组 <code>inDeg</code> 来记录每个节点的入度。在 BFS 中，每次选择入度为 0 的节点，将其移出图，并更新其相邻节点的入度。</li>
<li><strong>BFS 实现</strong>：<ol>
<li>先将所有入度为 0 的节点加入队列。</li>
<li>从队列中取出节点，将其从图中移除，并更新其相邻节点的入度。</li>
<li>重复该过程，直到队列为空。如果存在未处理的节点，说明图中存在环。</li>
</ol>
</li>
</ul>
<h4 id="代码实现：-13"><a href="#代码实现：-13" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(numCourses);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDeg</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 构建邻接表并计算入度</span><br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre : prerequisites) &#123;<br>        <span class="hljs-type">int</span> a = pre[<span class="hljs-number">0</span>], b = pre[<span class="hljs-number">1</span>];<br>        to[b].<span class="hljs-built_in">push_back</span>(a);<br>        inDeg[a]++;<br>    &#125;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// 将所有入度为 0 的节点入队</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> lessonCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        lessonCount++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : to[u]) &#123;<br>            inDeg[v]--;<br>            <span class="hljs-keyword">if</span> (inDeg[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lessonCount == numCourses;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="分析：-6"><a href="#分析：-6" class="headerlink" title="分析："></a><strong>分析</strong>：</h4><ul>
<li><strong>入度为 0 的节点优先处理</strong>，广度优先搜索的过程类似于层次遍历。</li>
<li><strong>时间复杂度</strong>：O(V + E)，其中 V 为节点数量，E 为边数量。</li>
</ul>
<hr>
<h3 id="整合提取的代码如下："><a href="#整合提取的代码如下：" class="headerlink" title="整合提取的代码如下："></a>整合提取的代码如下：</h3><h4 id="邻接矩阵、链式前向星、邻接表表示"><a href="#邻接矩阵、链式前向星、邻接表表示" class="headerlink" title="邻接矩阵、链式前向星、邻接表表示"></a>邻接矩阵、链式前向星、邻接表表示</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 邻接矩阵</span><br><span class="hljs-type">int</span> graph[MAX_N][MAX_N];<br><br><span class="hljs-comment">// 出边数组（链式前向星）</span><br>vector&lt;<span class="hljs-type">int</span>&gt; graph[MAX_N], edges[MAX_N];<br><br><span class="hljs-comment">// 邻接表 O(m+n)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-type">int</span> to; Node* next;&#125;;<br>Node* head[MAX_N];<br></code></pre></td></tr></table></figure>

<h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 邻接矩阵表示</span><br>graph[x][y] = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 出边数组（链式前向星）表示</span><br>graph[x].<span class="hljs-built_in">push_back</span>(y);<br><br><span class="hljs-comment">// 邻接表表示</span><br>Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>node-&gt;to = y;<br>node-&gt;next = head[x];<br>head[x] = node;<br></code></pre></td></tr></table></figure>

<h4 id="寻找环-深度优先搜索"><a href="#寻找环-深度优先搜索" class="headerlink" title="寻找环 - 深度优先搜索"></a>寻找环 - 深度优先搜索</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges) &#123;<br>            <span class="hljs-type">int</span> x = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = edge[<span class="hljs-number">1</span>];<br>            to[x].<span class="hljs-built_in">push_back</span>(y);<br>            n = <span class="hljs-built_in">max</span>(n, <span class="hljs-built_in">max</span>(x, y));<br>        &#125;<br>        hasCycle = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            visited[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (hasCycle) <span class="hljs-keyword">return</span> edge;<br>        <br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; to;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; visited;<br>    <span class="hljs-type">bool</span> hasCycle;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        visited[x] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>            <span class="hljs-keyword">if</span> (C[visited[y]]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (visited[y] == <span class="hljs-literal">false</span>) <span class="hljs-built_in">dfs</span>(x);<br>            <span class="hljs-keyword">else</span> hasCycle = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        to = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        inDeg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre : prerequisites) &#123;<br>            <span class="hljs-type">int</span> ai = pre[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> bi = pre[<span class="hljs-number">1</span>];<br>            to[bi].<span class="hljs-built_in">push_back</span>(ai);<br>            inDeg[ai]++;<br>        &#125;<br><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inDeg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; lessons;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            lessons.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : to[x]) &#123;<br>                inDeg[y]--;<br>                <span class="hljs-keyword">if</span> (inDeg[y] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lessons.<span class="hljs-built_in">size</span>() == numCourses;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>以上内容是根据你提供的笔记图片逐行完整提取的代码。</p>
<h3 id="5-课程安排问题："><a href="#5-课程安排问题：" class="headerlink" title="5. 课程安排问题："></a><strong>5. 课程安排问题</strong>：</h3><h4 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>给定 <code>numCourses</code> 门课程和它们之间的先修课程关系 <code>prerequisites</code>，判断是否可以完成所有课程。</p>
<h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a><strong>解决思路</strong>：</h4><ul>
<li>使用<strong>拓扑排序</strong>判断是否存在环。如果图中存在环，则课程安排存在冲突，无法完成所有课程。</li>
<li>使用 DFS 或 BFS 实现拓扑排序，并检测是否存在环。</li>
</ul>
<h4 id="代码实现：-14"><a href="#代码实现：-14" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pre : prerequisites) &#123;<br>        graph[pre[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(pre[<span class="hljs-number">0</span>]);<br>        inDegree[pre[<span class="hljs-number">0</span>]]++;<br>    &#125;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 入度为0的课程可以先学习</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> curr = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        count++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[curr]) &#123;<br>            inDegree[neighbor]--;<br>            <span class="hljs-keyword">if</span> (inDegree[neighbor] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(neighbor);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> count == numCourses;  <span class="hljs-comment">// 如果学习的课程数等于课程总数，则可以完成所有课程</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>图的表示方式</strong>：通过邻接矩阵、邻接表或链式前向星表示图结构，适应不同的场景和空间复杂度要求。</li>
<li><strong>图的遍历</strong>：DFS 和 BFS 是图的两种基本遍历方式，DFS 常用于连通分量、环检测，BFS 常用于最短路径和拓扑排序。</li>
<li><strong>拓扑排序</strong>：基于入度的 BFS 是一种高效的拓扑排序方法，广泛应用于课程安排、任务调度等场景。</li>
<li><strong>环检测与课程安排</strong>：通过 DFS 或 BFS 进行环检测，确定是否存在循环依赖，从而判断课程能否按要求完成。</li>
</ul>
<hr>
<h1 id="十二-搜索"><a href="#十二-搜索" class="headerlink" title="十二.搜索"></a>十二.搜索</h1><h3 id="1-状态与状态空间搜索："><a href="#1-状态与状态空间搜索：" class="headerlink" title="1. 状态与状态空间搜索："></a><strong>1. 状态与状态空间搜索</strong>：</h3><ul>
<li><p><strong>状态</strong>：状态表示问题的每一个可能的配置。状态可以看作图中的一个顶点，状态的转移则对应图中的边。状态空间的搜索通常用于解决某些搜索问题，如寻找最优解、遍历所有可能的解等。</p>
</li>
<li><p><strong>搜索算法</strong>：</p>
<ul>
<li><strong>深度优先搜索（DFS）</strong>：优先探索当前路径，深入到不能继续为止，再进行回溯。适用于需要遍历整棵搜索树或图的场景。</li>
<li><strong>广度优先搜索（BFS）</strong>：按照层次逐步扩展所有状态，适用于最短路径等需要找到最早解的场景。</li>
</ul>
</li>
</ul>
<h4 id="状态搜索的步骤："><a href="#状态搜索的步骤：" class="headerlink" title="状态搜索的步骤："></a><strong>状态搜索的步骤</strong>：</h4><ul>
<li><strong>确定初始状态</strong>：选择问题的起始状态，通常是一个明确的初始条件。</li>
<li><strong>确定状态转移</strong>：定义状态如何从一个状态转移到下一个状态，类似于图中的边。</li>
<li><strong>搜索终止条件</strong>：根据问题的性质，设置搜索的结束条件。</li>
</ul>
<h4 id="DFS-和-BFS-的比较："><a href="#DFS-和-BFS-的比较：" class="headerlink" title="DFS 和 BFS 的比较："></a><strong>DFS 和 BFS 的比较</strong>：</h4><ul>
<li><strong>DFS</strong>：在找到目标解之前，会不断深入搜索某条路径。适用于找到所有解，或不关心最优解的场景。</li>
<li><strong>BFS</strong>：逐层扩展搜索，通常用于寻找最优解或最短路径。</li>
</ul>
<hr>
<h3 id="2-电话号码的字母组合问题："><a href="#2-电话号码的字母组合问题：" class="headerlink" title="2. 电话号码的字母组合问题："></a><strong>2. 电话号码的字母组合问题</strong>：</h3><h4 id="问题描述：-3"><a href="#问题描述：-3" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话按键一致。</p>
<p>例如：</p>
<ul>
<li>输入：”23”</li>
<li>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li>
</ul>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a><strong>思路</strong>：</h4><ul>
<li><strong>递归（DFS）实现</strong>：该问题可以被看作是一个递归问题，每个数字对应多个字母，每个数字的字母组合都与前一个数字的字母组合进行全排列。</li>
<li><strong>状态转移</strong>：每个状态表示当前递归到第几个数字，每次递归时选择对应数字所映射的字母，生成所有可能的字母组合。</li>
</ul>
<h4 id="代码实现：-15"><a href="#代码实现：-15" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">L</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;digits = digits;<br>        alphabet[<span class="hljs-string">&#x27;2&#x27;</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;3&#x27;</span>] = <span class="hljs-string">&quot;def&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;4&#x27;</span>] = <span class="hljs-string">&quot;ghi&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;5&#x27;</span>] = <span class="hljs-string">&quot;jkl&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;6&#x27;</span>] = <span class="hljs-string">&quot;mno&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;7&#x27;</span>] = <span class="hljs-string">&quot;pqrs&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;8&#x27;</span>] = <span class="hljs-string">&quot;tuv&quot;</span>;<br>        alphabet[<span class="hljs-string">&#x27;9&#x27;</span>] = <span class="hljs-string">&quot;wxyz&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">length</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : alphabet[digits[index]]) &#123;<br>            <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, str + ch);<br>        &#125;<br>    &#125;<br><br>    string digits;<br>    vector&lt;string&gt; ans;<br>    unordered_map&lt;<span class="hljs-type">char</span>, string&gt; alphabet;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="详细分析："><a href="#详细分析：" class="headerlink" title="详细分析："></a><strong>详细分析</strong>：</h4><ul>
<li><strong>递归过程</strong>：每次递归处理一个数字的所有字母组合，并将结果传递到下一层递归中。直到处理完所有数字后，结果将累积到 <code>ans</code> 中。</li>
<li><strong>时间复杂度</strong>：O(3^n * 4^m)，其中 n 是映射到 3 个字母的数字的数量，m 是映射到 4 个字母的数字的数量。</li>
</ul>
<hr>
<h3 id="3-状态的存储与计算优化："><a href="#3-状态的存储与计算优化：" class="headerlink" title="3. 状态的存储与计算优化："></a><strong>3. 状态的存储与计算优化</strong>：</h3><p>笔记中提到通过<strong>哈希表（unordered_map）</strong>来存储和检索状态，以提高搜索效率。对于类似电话号码字母组合的问题，哈希表用于存储数字与字母的对应关系，方便快速查询。</p>
<h4 id="哈希表应用："><a href="#哈希表应用：" class="headerlink" title="哈希表应用："></a><strong>哈希表应用</strong>：</h4><ul>
<li><strong>存储映射关系</strong>：数字到字母的映射使用 <code>unordered_map</code>，在搜索过程中可以快速查找某个数字对应的字母。</li>
<li><strong>状态去重</strong>：在某些状态搜索问题中，如果某个状态已经被访问过，可以使用哈希表来存储已访问状态，避免重复搜索，提升效率。</li>
</ul>
<hr>
<h3 id="4-其他优化策略："><a href="#4-其他优化策略：" class="headerlink" title="4. 其他优化策略："></a><strong>4. 其他优化策略</strong>：</h3><h4 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a><strong>剪枝</strong>：</h4><p>在状态空间搜索中，剪枝是指提前终止那些不可能产生有效解的状态，减少搜索空间。常见的剪枝条件包括：</p>
<ul>
<li>状态不满足约束条件时，直接返回。</li>
<li>通过某些启发式方法判断该路径无法产生最优解，从而终止进一步搜索。</li>
</ul>
<h4 id="记忆化搜索："><a href="#记忆化搜索：" class="headerlink" title="记忆化搜索："></a><strong>记忆化搜索</strong>：</h4><p>将已经计算过的状态及其结果进行缓存，避免在递归过程中重复计算。电话号码字母组合问题通过字典存储每个数字与字母的映射，就是一种简化的记忆化优化。</p>
<hr>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>状态空间搜索</strong>是一种广泛应用于图遍历和组合问题的技术，主要通过 DFS 和 BFS 实现。对于复杂问题，合理地定义状态和状态转移是关键。</li>
<li><strong>电话号码的字母组合问题</strong>是一个经典的状态搜索问题，通过 DFS 实现可以生成所有可能的组合，借助哈希表存储映射关系提高搜索效率。</li>
<li><strong>递归和剪枝</strong>：在搜索过程中，使用递归和剪枝可以有效减少不必要的计算，提升算法性能。</li>
</ul>
<p>这张笔记介绍了<strong>基因突变问题</strong>，并通过<strong>广度优先搜索（BFS）</strong>求解，最后还总结了<strong>深度优先搜索（DFS）</strong>与<strong>广度优先搜索（BFS）</strong>的适用场景及其特点。以下是详细总结：</p>
<hr>
<h3 id="1-基因突变问题："><a href="#1-基因突变问题：" class="headerlink" title="1. 基因突变问题："></a><strong>1. 基因突变问题</strong>：</h3><h4 id="问题描述：-4"><a href="#问题描述：-4" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><ul>
<li>给定一个初始基因序列 <code>start</code> 和目标基因序列 <code>end</code>，每个基因序列由长度为 8 的字符（A、C、G、T）组成。</li>
<li>通过一次基因突变，可以将一个基因序列中的某个位置的字符变为另一个字符。</li>
<li>还给定了一个基因库 <code>bank</code>，该基因库中的基因序列为合法的突变序列。</li>
<li>问题要求找到从 <code>start</code> 变为 <code>end</code> 的最少突变次数，如果无法完成转换则返回 <code>-1</code>。</li>
</ul>
<h4 id="解法思路："><a href="#解法思路：" class="headerlink" title="解法思路："></a><strong>解法思路</strong>：</h4><ul>
<li><strong>广度优先搜索（BFS）</strong>：每次将当前基因序列的合法突变加入队列，按层次遍历，直到找到目标基因序列为止。</li>
<li><strong>状态表示</strong>：每个基因序列是一个状态。</li>
<li><strong>状态转移</strong>：一次合法突变即为从当前基因序列变为另一个基因序列。</li>
</ul>
<h4 id="代码实现：-16"><a href="#代码实现：-16" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        depth[start] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (string seq : bank) hasBank.<span class="hljs-built_in">insert</span>(seq);<br>        <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(end) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        queue&lt;string&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> gene[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            string s = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (s[i] != gene[j]) &#123;<br>                        string ns = s;<br>                        ns[i] = gene[j];<br>                        <span class="hljs-keyword">if</span> (hasBank.<span class="hljs-built_in">find</span>(ns) == hasBank.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">if</span> (depth.<span class="hljs-built_in">find</span>(ns) != depth.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br><br>                        depth[ns] = depth[s] + <span class="hljs-number">1</span>;<br>                        q.<span class="hljs-built_in">push</span>(ns);<br>                        <span class="hljs-keyword">if</span> (ns == end)<br>                            <span class="hljs-keyword">return</span> depth[ns];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;string&gt; hasBank;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; depth;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="细节分析："><a href="#细节分析：" class="headerlink" title="细节分析："></a><strong>细节分析</strong>：</h4><ul>
<li><strong>广度优先搜索</strong>：BFS 是一种层次遍历，每次只处理当前层的突变，确保找到的第一个满足条件的路径就是最短路径。</li>
<li><strong>哈希表优化</strong>：基因库和已经访问过的基因序列存储在哈希表中，以便快速查找和去重。</li>
</ul>
<h4 id="时间复杂度：O-n-8-，其中-n-是基因库的大小，8-是基因序列的长度，每个基因序列都需要对每一位进行-4-种变换尝试。"><a href="#时间复杂度：O-n-8-，其中-n-是基因库的大小，8-是基因序列的长度，每个基因序列都需要对每一位进行-4-种变换尝试。" class="headerlink" title="时间复杂度：O(n * 8)，其中 n 是基因库的大小，8 是基因序列的长度，每个基因序列都需要对每一位进行 4 种变换尝试。"></a><strong>时间复杂度</strong>：O(n * 8)，其中 n 是基因库的大小，8 是基因序列的长度，每个基因序列都需要对每一位进行 4 种变换尝试。</h4><hr>
<h3 id="2-DFS-和-BFS-的对比："><a href="#2-DFS-和-BFS-的对比：" class="headerlink" title="2. DFS 和 BFS 的对比："></a><strong>2. DFS 和 BFS 的对比</strong>：</h3><p>笔记还详细总结了 <strong>DFS</strong> 和 <strong>BFS</strong> 的不同适用场景及其特点：</p>
<h4 id="DFS（深度优先搜索）：-1"><a href="#DFS（深度优先搜索）：-1" class="headerlink" title="DFS（深度优先搜索）："></a><strong>DFS（深度优先搜索）</strong>：</h4><ul>
<li><strong>适用场景</strong>：<ul>
<li>适用于树形或图形结构的状态空间搜索，尤其是需要遍历所有可能解的场景。</li>
<li>更适合递归实现，适合处理树或图结构。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>深度优先</strong>：优先探索当前路径，深入到不能继续时才回溯。</li>
<li><strong>需要回溯</strong>：由于优先走到最深处，可能会走很多不必要的路径，因此需要回溯。</li>
<li><strong>应用场景</strong>：如全排列、子集等需要遍历所有可能状态的问题。</li>
</ul>
</li>
</ul>
<h4 id="BFS（广度优先搜索）："><a href="#BFS（广度优先搜索）：" class="headerlink" title="BFS（广度优先搜索）："></a><strong>BFS（广度优先搜索）</strong>：</h4><ul>
<li><strong>适用场景</strong>：<ul>
<li>适用于寻找最短路径类问题，尤其在状态空间搜索中找到从起点到目标的最短步骤。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>广度优先</strong>：按层次遍历，优先处理当前层的节点，逐步扩展到下一层。</li>
<li><strong>最短路径</strong>：BFS 能够确保找到的解是步数最少的解，适合寻找最短路径、最小步数的场景。</li>
<li><strong>应用场景</strong>：如最短路径、最小步数、无权图的最短路径等问题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>基因突变问题</strong>通过 BFS 解决，是一个经典的层次遍历问题。BFS 可以保证找到的路径是最短的，适合解决此类寻找最小步数的问题。</li>
<li><strong>DFS 和 BFS 的适用场景不同</strong>，DFS 更适合于需要遍历所有解的场景，而 BFS 则适合用于最短路径类问题。这两种搜索方法在不同的应用场景下各有优势。</li>
</ul>
<hr>
<h1 id="十三-二分"><a href="#十三-二分" class="headerlink" title="十三.二分"></a>十三.二分</h1><p>各种排序算法 分为基于比较的和非比较的排序 比较：交换 冒泡 快速     插入 插入 希尔     选择 选择 堆     归并 二路 多路 非比较： 计数排序 桶排序 基数排序 用c++语言总结这些算法怎么写,技巧等</p>
<h3 id="1-二分查找的基本实现："><a href="#1-二分查找的基本实现：" class="headerlink" title="1. 二分查找的基本实现："></a><strong>1. 二分查找的基本实现</strong>：</h3><h4 id="问题描述：-5"><a href="#问题描述：-5" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>二分查找用于在有序数组中查找目标值 <code>target</code>，其时间复杂度为 O(log n)。</p>
<h4 id="算法思路：-9"><a href="#算法思路：-9" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>将数组的搜索范围缩小为左边界 <code>left</code> 和右边界 <code>right</code>，每次取中间位置 <code>mid</code> 的值进行比较：<ul>
<li>如果 <code>array[mid] == target</code>，则找到了目标值，返回 <code>mid</code>。</li>
<li>如果 <code>array[mid] &lt; target</code>，则将左边界 <code>left</code> 移动到 <code>mid + 1</code>，缩小搜索范围。</li>
<li>如果 <code>array[mid] &gt; target</code>，则将右边界 <code>right</code> 移动到 <code>mid - 1</code>，缩小搜索范围。</li>
</ul>
</li>
</ul>
<h4 id="C-Java-实现："><a href="#C-Java-实现：" class="headerlink" title="C++&#x2F;Java 实现："></a><strong>C++&#x2F;Java 实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] == target)<br>        <span class="hljs-keyword">break</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">return</span> mid;<br><br>    <span class="hljs-keyword">if</span> (array[mid] &lt; target)<br>        left = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="Python-实现："><a href="#Python-实现：" class="headerlink" title="Python 实现："></a><strong>Python 实现</strong>：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(array) - <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> left &lt;= right:<br>    mid = (left + right) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> array[mid] == target:<br>        <span class="hljs-keyword">break</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">return</span> mid<br>    <span class="hljs-keyword">elif</span> array[mid] &lt; target:<br>        left = mid + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        right = mid - <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-二分查找的变体："><a href="#2-二分查找的变体：" class="headerlink" title="2. 二分查找的变体："></a><strong>2. 二分查找的变体</strong>：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>后继型</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">n</span>;<br>while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">if</span> (array[<span class="hljs-built_in">mid</span>] &gt;= target)  // 查找 upper_bound 即 array[<span class="hljs-built_in">mid</span>] &gt; target<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>    else<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>&#125;<br>return <span class="hljs-built_in">right</span>; // 不安全返回<br><br></code></pre></td></tr></table></figure>



<hr>
<h3 id="3-二分查找的应用场景："><a href="#3-二分查找的应用场景：" class="headerlink" title="3. 二分查找的应用场景："></a><strong>3. 二分查找的应用场景</strong>：</h3><p>二分查找通常用于<strong>有序数组</strong>或<strong>单调函数</strong>的查找问题。通过二分查找可以高效解决以下问题：</p>
<ul>
<li><strong>查找目标值</strong>：直接查找一个值是否存在于有序数组中。</li>
<li><strong>查找插入位置</strong>：通过查找左边界或右边界，可以判断一个目标值应该插入数组的哪个位置，常用于实现<strong>二分插入排序</strong>。</li>
<li><strong>统计某个数的出现次数</strong>：通过查找左边界和右边界，可以快速统计某个数在有序数组中的出现次数。</li>
</ul>
<hr>
<h3 id="4-示例问题："><a href="#4-示例问题：" class="headerlink" title="4. 示例问题："></a><strong>4. 示例问题</strong>：</h3><h4 id="问题描述：-6"><a href="#问题描述：-6" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>已知一个有序数组 <code>10 10 19 25 27 30 32 37 42</code>，现在需要查找大于等于 26 的第一个数字的位置（即使用上边界的二分查找）。</p>
<h4 id="代码实现：-17"><a href="#代码实现：-17" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (array[mid] &gt;= <span class="hljs-number">26</span>)<br>        right = mid;<br>    <span class="hljs-keyword">else</span><br>        left = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right;  <span class="hljs-comment">// 返回第一个大于等于 26 的位置</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>二分查找</strong>是一种非常高效的查找算法，尤其适用于在有序数组或单调函数中查找目标值或边界值。</li>
<li>通过变形的二分查找，可以解决查找左边界、右边界、统计重复元素出现次数等问题。</li>
<li>实现二分查找时要注意终止条件和边界处理，确保不会出现死循环或越界问题。</li>
</ul>
<p>这张笔记继续探讨了<strong>二分查找</strong>，并展示了如何在排序数组中找到元素的<strong>第一个和最后一个位置</strong>，同时还探讨了<strong>求平方根的二分法</strong>。以下是详细总结：</p>
<hr>
<ul>
<li><h4 id="二分查找-找到最后一个小于等于-target-的位置"><a href="#二分查找-找到最后一个小于等于-target-的位置" class="headerlink" title="二分查找 - 找到最后一个小于等于 target 的位置"></a>二分查找 - 找到最后一个小于等于 <code>target</code> 的位置</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = -<span class="hljs-number">1</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br>while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span> + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;  // 向上取整<br>    <span class="hljs-built_in">if</span> (array[<span class="hljs-built_in">mid</span>] &lt;= target)<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>;<br>    else<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>&#125;<br>return <span class="hljs-built_in">left</span>;<br></code></pre></td></tr></table></figure>

<h4 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> findMin(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = nums.size() - <span class="hljs-number">1</span>;<br>    while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt;= nums[<span class="hljs-built_in">right</span>])<br>            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>        else<br>            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>    return nums[<span class="hljs-built_in">right</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">vector&lt;<span class="hljs-built_in">int</span>&gt; ans;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = nums.size();<br>while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &gt;= target)  // 查找位置第一个 &gt;= target 的数<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>    else<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>&#125;<br>ans.push_back(<span class="hljs-built_in">right</span>);<br><br><span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = nums.size() - <span class="hljs-number">1</span>;<br>while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt;= target)  // 查找位置最后一个 &lt;= target 的数<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>;<br>    else<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>&#125;<br>ans.push_back(<span class="hljs-built_in">right</span>);<br><br><span class="hljs-built_in">if</span> (ans[<span class="hljs-number">0</span>] == ans[<span class="hljs-number">1</span>]) return &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>return ans;<br></code></pre></td></tr></table></figure>

<h4 id="平方根计算"><a href="#平方根计算" class="headerlink" title="平方根计算"></a>平方根计算</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span> = x;<br>while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">mid</span> * <span class="hljs-built_in">mid</span> &lt;= x) &#123;<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>;<br>    &#125; else &#123;<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br>return <span class="hljs-built_in">right</span>;<br></code></pre></td></tr></table></figure>

<h4 id="实数平方根"><a href="#实数平方根" class="headerlink" title="实数平方根"></a>实数平方根</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">double</span> myRealSqrt(<span class="hljs-built_in">double</span> x) &#123;<br>    <span class="hljs-built_in">double</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = x;<br>    while (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span> &gt; <span class="hljs-number">1e-7</span>) &#123;<br>        <span class="hljs-built_in">double</span> mid = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt;= x) &#123;<br>            <span class="hljs-built_in">left</span> = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">right</span> = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">right</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>二分查找</strong>不仅能解决简单的查找问题，还能通过调整条件找到数组中目标值的边界位置，适用于有序数组的场景。</li>
<li><strong>平方根问题</strong>可以通过二分查找求解，不论是整数平方根还是精确平方根，通过调整精度可以得到不同的结果。</li>
</ul>
<p>这张笔记主要介绍了<strong>三分查找算法</strong>，以及如何应用三分查找解决峰值问题，随后还提到了一个<strong>分割数组</strong>的问题。以下是详细总结：</p>
<hr>
<h3 id="1-三分查找算法："><a href="#1-三分查找算法：" class="headerlink" title="1. 三分查找算法："></a><strong>1. 三分查找算法</strong>：</h3><h4 id="三分查找的适用场景："><a href="#三分查找的适用场景：" class="headerlink" title="三分查找的适用场景："></a><strong>三分查找的适用场景</strong>：</h4><ul>
<li><strong>函数单峰性问题</strong>：三分查找常用于寻找某个函数的极值点，适用于函数在某区间内具有单峰性（即该函数在区间内只有一个极大值或极小值），且能够保证递增或递减的规律。</li>
<li><strong>核心思想</strong>：与二分查找类似，不同之处在于每次将区间分成三份，分别计算中间两点 <code>lmid</code> 和 <code>rmid</code>，通过比较 <code>f(lmid)</code> 和 <code>f(rmid)</code> 的大小，缩小搜索范围。</li>
</ul>
<h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤</strong>：</h4><ul>
<li><strong>比较两点</strong> <code>lmid</code> 和 <code>rmid</code> 的函数值：<ul>
<li>如果 <code>f(lmid) &lt; f(rmid)</code>，则极值位于 <code>lmid</code> 的右边（排除 <code>lmid</code> 左侧区间），所以更新左边界 <code>left = lmid + 1</code>。</li>
<li>否则，极值位于 <code>rmid</code> 的左边（排除 <code>rmid</code> 右侧区间），更新右边界 <code>right = rmid - 1</code>。</li>
</ul>
</li>
<li>不断重复上述过程，直到区间收缩到极值点。</li>
</ul>
<h4 id="代码实现：-18"><a href="#代码实现：-18" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">int</span> lmid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> rmid = (lmid + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[lmid] &lt;= nums[rmid]) <br>        left = lmid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <br>        right = rmid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> right;<br><br></code></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a><strong>解释</strong>：</h4><ul>
<li>该算法通过三分查找，逐渐缩小区间直到找到数组的峰值位置。</li>
<li>在单峰函数中，这种方法能有效找到极值点。</li>
</ul>
<hr>
<h3 id="2-分割数组问题："><a href="#2-分割数组问题：" class="headerlink" title="2. 分割数组问题："></a><strong>2. 分割数组问题</strong>：</h3><h4 id="问题描述：-7"><a href="#问题描述：-7" class="headerlink" title="问题描述："></a><strong>问题描述</strong>：</h4><p>将数组 <code>nums</code> 分成 <code>m</code> 个连续的子数组，使得这些子数组中的<strong>最大和</strong>最小，并保证划分是合理的（即尽量均匀）。</p>
<h4 id="算法思路：-10"><a href="#算法思路：-10" class="headerlink" title="算法思路："></a><strong>算法思路</strong>：</h4><ul>
<li>通过二分查找来求解最大和的最小值。</li>
<li><strong>初始范围</strong>：最小值为数组中的最大元素，最大值为数组所有元素的和。</li>
<li><strong>判定条件</strong>：给定一个划分值 <code>T</code>，判断能否将数组划分成不超过 <code>m</code> 个子数组，使得每个子数组的和都不大于 <code>T</code>。</li>
</ul>
<h4 id="判定函数："><a href="#判定函数：" class="headerlink" title="判定函数："></a><strong>判定函数</strong>：</h4><ul>
<li>遍历数组，累加当前子数组的和 <code>sum</code>，一旦 <code>sum</code> 超过了 <code>T</code>，就开始划分新的一组，并重置 <code>sum</code>。</li>
<li>如果划分的组数超过了 <code>m</code>，则说明 <code>T</code> 不足够大，需要增大 <code>T</code>；否则，说明 <code>T</code> 是一个可行的值，尝试减小 <code>T</code>。</li>
</ul>
<h4 id="代码实现：-19"><a href="#代码实现：-19" class="headerlink" title="代码实现："></a><strong>代码实现</strong>：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数组中的最大值</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 数组所有元素的和</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canSplit</span>(nums, mid, m))<br>            right = mid;  <span class="hljs-comment">// 尝试减小最大值</span><br>        <span class="hljs-keyword">else</span><br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 增大最大值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canSplit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> maxSum, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        <span class="hljs-keyword">if</span> (sum &gt; maxSum) &#123;  <span class="hljs-comment">// 如果当前子数组的和超过了允许的最大值</span><br>            sum = num;<br>            count++;  <span class="hljs-comment">// 划分出新的子数组</span><br>            <span class="hljs-keyword">if</span> (count &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a><strong>解释</strong>：</h4><ul>
<li><strong>二分查找</strong>：二分查找用于确定最大子数组和的最小可能值。</li>
<li><strong>判定函数</strong>：通过不断尝试不同的 <code>mid</code> 值（即可能的最大子数组和），判断是否能够在不超过 <code>m</code> 次划分的前提下，将数组划分为子数组。</li>
</ul>
<hr>
<h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>三分查找</strong>适用于处理单峰性问题，尤其是在寻找极值点时，能够有效缩小区间。</li>
<li><strong>分割数组问题</strong>使用二分查找来确定最大子数组和的最小值，通过判定函数来检查当前划分是否满足条件。这种思路在需要均匀分配任务或资源时非常常用。</li>
</ul>
<h1 id="十四-排序"><a href="#十四-排序" class="headerlink" title="十四.排序"></a>十四.排序</h1><p>在 C++ 语言中，常见的排序算法可以分为基于比较的和非比较的两类。总结这些算法时，可以从算法的时间复杂度、空间复杂度以及适用场景的角度来进行编写。以下是每种排序算法的简要说明、代码实现和一些技巧：</p>
<h3 id="一、基于比较的排序"><a href="#一、基于比较的排序" class="headerlink" title="一、基于比较的排序"></a>一、基于比较的排序</h3><h4 id="1-交换类排序"><a href="#1-交换类排序" class="headerlink" title="1. 交换类排序"></a>1. 交换类排序</h4><p><strong>(1) 冒泡排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每一轮遍历可以把最大（或最小）的元素放在数组的末尾。</p>
<p><strong>(2) 快速排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(log n)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;<br>        arr[low] = arr[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++;<br>        arr[high] = arr[low];<br>    &#125;<br>    arr[low] = pivot;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partition</span>(arr, low, high);<br>        <span class="hljs-built_in">quickSort</span>(arr, low, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过分治法将数组划分为较小的子数组，递归排序。</p>
<h4 id="2-插入类排序"><a href="#2-插入类排序" class="headerlink" title="2. 插入类排序"></a>2. 插入类排序</h4><p><strong>(1) 直接插入排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> key = arr[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合小规模数据集，具有局部性特点的数据性能较好。</p>
<p><strong>(2) 希尔排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> key = arr[i];<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123;<br>                arr[j] = arr[j - gap];<br>                j -= gap;<br>            &#125;<br>            arr[j] = key;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：通过缩小增量逐步优化插入排序。</p>
<h4 id="3-选择类排序"><a href="#3-选择类排序" class="headerlink" title="3. 选择类排序"></a>3. 选择类排序</h4><p><strong>(1) 选择排序</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> minIdx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;<br>                minIdx = j;<br>            &#125;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：每轮找到最小（或最大）值并交换到对应位置。</p>
<p><strong>(2) 堆排序</strong></p>
<ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = i;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;<br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;<br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[largest]);<br>        <span class="hljs-built_in">heapify</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-built_in">heapify</span>(arr, n, i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        std::<span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：利用堆结构维护最大或最小堆。</p>
<h4 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h4><ul>
<li>时间复杂度：O(n log n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n1 = m - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n2 = r - m;<br>    <span class="hljs-type">int</span> L[n1], R[n2];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++) L[i] = arr[l + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; j++) R[j] = arr[m + <span class="hljs-number">1</span> + j];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = l;<br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) arr[k++] = L[i++];<br>        <span class="hljs-keyword">else</span> arr[k++] = R[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; n1) arr[k++] = L[i++];<br>    <span class="hljs-keyword">while</span> (j &lt; n2) arr[k++] = R[j++];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr, l, m);<br>        <span class="hljs-built_in">mergeSort</span>(arr, m + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">merge</span>(arr, l, m, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：递归分割数组，合并时排序。</p>
<h3 id="二、非比较类排序"><a href="#二、非比较类排序" class="headerlink" title="二、非比较类排序"></a>二、非比较类排序</h3><h4 id="1-计数排序"><a href="#1-计数排序" class="headerlink" title="1. 计数排序"></a>1. 计数排序</h4><ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(k)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> max)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count[max + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> output[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[arr[i]]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[arr[i]] - <span class="hljs-number">1</span>] = arr[i];<br>        count[arr[i]]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合范围较小的整数排序。</p>
<h4 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2. 桶排序"></a>2. 桶排序</h4><ul>
<li>时间复杂度：O(n + k)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-type">float</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">float</span>&gt; buckets[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> idx = n * arr[i];<br>        buckets[idx].<span class="hljs-built_in">push_back</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::<span class="hljs-built_in">sort</span>(buckets[i].<span class="hljs-built_in">begin</span>(), buckets[i].<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;val : buckets[i]) &#123;<br>            arr[idx++] = val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：适合分布均匀的实数排序。</p>
<h4 id="3-基数排序"><a href="#3-基数排序" class="headerlink" title="3. 基数排序"></a>3. 基数排序</h4><ul>
<li>时间复杂度：O(nk)</li>
<li>空间复杂度：O(n + k)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSortForRadix</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> exp)</span> </span>&#123;<br>    <span class="hljs-type">int</span> output[n], count[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) count[(arr[i] / exp) % <span class="hljs-number">10</span>]++;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) count[i] += count[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        output[count[(arr[i] / exp) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = arr[i];<br>        count[(arr[i] / exp) % <span class="hljs-number">10</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) arr[i] = output[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max = <span class="hljs-built_in">getMax</span>(arr, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> exp = <span class="hljs-number">1</span>; max / exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) <span class="hljs-built_in">countingSortForRadix</span>(arr, n, exp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>技巧</strong>：按位排序，从低位到高位逐一处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>算法选择</strong>：根据数据的规模、分布特点选择合适的算法。快速排序在多数情况下表现良好，但对于极端情况可能退化；归并排序的稳定性和性能较优但占用额外空间；堆排序在处理大规模数据时表现优异。</li>
<li><strong>非比较排序</strong>：如计数排序、桶排序和基数排序，适合特定场景，通常用于整型或有范围限制的数据。</li>
</ul>
<h1 id="十五-贪心"><a href="#十五-贪心" class="headerlink" title="十五. 贪心"></a>十五. 贪心</h1><h1 id="十六-动态规划"><a href="#十六-动态规划" class="headerlink" title="十六.动态规划"></a>十六.动态规划</h1><h1 id="十七-字典树-并查集"><a href="#十七-字典树-并查集" class="headerlink" title="十七.字典树,并查集"></a>十七.字典树,并查集</h1><h1 id="十八-图论"><a href="#十八-图论" class="headerlink" title="十八.图论"></a>十八.图论</h1><h1 id="十九-字符串处理"><a href="#十九-字符串处理" class="headerlink" title="十九.字符串处理"></a>十九.字符串处理</h1><h1 id="二十-高级搜索"><a href="#二十-高级搜索" class="headerlink" title="二十.高级搜索"></a>二十.高级搜索</h1><h1 id="二十一-平衡二叉树"><a href="#二十一-平衡二叉树" class="headerlink" title="二十一.平衡二叉树"></a>二十一.平衡二叉树</h1><h1 id="二十二-跳跃表"><a href="#二十二-跳跃表" class="headerlink" title="二十二.跳跃表"></a>二十二.跳跃表</h1><h1 id="二十三-线段树"><a href="#二十三-线段树" class="headerlink" title="二十三.线段树"></a>二十三.线段树</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法笔记</div>
      <div>https://theganlove.github.io/2024/09/09/算法笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>uert</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/" title="服务器部署">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">服务器部署</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/08/%E9%9A%90%E5%86%99/" title="隐写">
                        <span class="hidden-mobile">隐写</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
